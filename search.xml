<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[码出高效-面向对象（类）]]></title>
    <url>%2F2018%2F11%2F13%2F%E7%A0%81%E5%87%BA%E9%AB%98%E6%95%88-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E7%B1%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[码出高效-面向对象（类）1、接口与抽象类接口与抽象类的同与不同我们知道面向对象的基本特征就是（抽象、封装、继承、多态）。接口与抽象类就是更高层次的抽象，仅定义公共行为和特征。接口与抽象类的共同点在于都不能被实例化，但是可以定义引用变量指向实例对象。 但是我们经常讨论的是这两者的不同点。下面列举一个表格展示一下。 语法维度 抽象类 定义关键字 abstract interface 子类继承或实现关键字 extends implements 方法实现 可以 不可以（JAVA8中允许有default方法） 方法访问控制符 无限制 有，默认为public abstract类型 属性访问控制符 无限制 有，默认为public abstract类型 静态方法 可以 不可 static{}静态代码块 可以 不可 本类型之间扩展 单继承 多继承 本类型之间扩展关键字 extends extends 抽象类与接口的关系上面的基本总结了接口与抽象类在语法规则与使用上面的不同。但是在关系上两者也有着很大的不同。 抽象类是is-a的关系，抽象类通常是对同类事物相对具体的抽象，通常包含抽象方法、实体方法、属性变量。如果抽象类中只有一个抽象方法，就等同于一个接口。is-a的关系需要符合里氏置换原则（就是说任何父类可以出现的地方，父类都可以出现） 接口在被实现的时候体现的是can-do关系。can-do关系体现的是接口隔离原则，实现类要有能力去实现并执行接口中定义的方法。例如飞机会飞，鸟也会飞。应该把fly()定义为一个接口，而不是把fly()放在一个抽象类中。因为很难抽取飞机与鸟之间的共同特征。 抽象类与接口的设计模式 抽象类是模板设计，而接口是契约式设计。抽象类包含一组相对具体的特征，比如车，就必须有内饰，发动机，轮胎，刹车。根据不同档次的去实现不同的车型。可以存在不同版本的实现。接口是开放的，就像一个标准，定义了方法名、参数、返回值、异常抛出类型。你要去做就按照这个标准去实现。 接口是顶级的“类”，接口位于顶层，而抽象类对各个接口进行了组合，然后实现部分接口的行为，AbstractCollection就是示例。 Q：接口为什么可以多继承Java中类使用单继承的方式，是为了避免继承泛滥，菱形继承、循环继承。接口之所以允许多继承的原因是因为接口是契约式设计，没有任何具体的实现和属性，某个实体类在实现多重继承后的接口，只是说明这个接口 “can do many things”。当犹豫使用两者哪一个的时候，推荐使用接口，遵循接口隔离原则，按照多种维度去划分接口，再用抽象类去implements某些接口，有利于重构和扩展。 2、内部类内部类定义在.java源文件中，只能定义一个类名与文件名完全一样的公开类，使用public class关键字修饰。但是可以在一个类的内部定义其他类，这个就叫做内部类，内部类就是类的一个属性。举个例子就是，在集合框架中，HashMap代码中就有Node内部类，是用来作为数据存储的节点。 内部类分类 静态内部类，如：static class StaticInnerClass{} 成员内部类，如：private class InstanceInnerClass{} 局部内部类，定义在方法或者表达式内部。 匿名内部类，如：（new Thread(){}）.start(); 下面是代码的展示： 12345678910111213141516171819202122public class OuterClass &#123; //成员内部类 private class InstanceInnerClass &#123; &#125; //静态内部类 static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; //匿名内部类 (new Thread () &#123; &#125;).start (); (new Thread () &#123; &#125;).start (); //方法内部类 class MethodClass1 &#123; &#125; class MethodClass2 &#123; &#125; &#125;&#125; 静态内部类的好处在JDK源码中，定义包内静态内部类的方式很常见。这样做的好处是： 作用域不会扩散到包外。 可以通过“外部类.内部类”的方式直接方法问。 内部类可以访问外部类中的所有静态属性和方法。 3、访问权限控制面向对象的核心思想就是封装，只把有限的方法和成员变量公开给别人。只就是迪米特法则(使外部调用方对方法内在的实现细节尽可能的知道的少)。实现封装的关键就在于访问权限的控制。使用某些关键字来限制类外部对类内方法和属性随意访问。 四种访问权限控制符 访问权限控制符 任何地方 包外子类 包内 类内 public ok ok ok ok protected NO ok ok ok 无 NO NO ok ok private NO NO NO ok public：访问权限最松散的一级，被修饰的类、属性和方法。不仅可以在包内访问，还可以跨类、跨包访问。 protected：只能修饰属性和方法，表示受保护的，其修饰的属性和方法能被包内及包外子类访问。 无：无任何访问权限修饰符，与default有区别。无访问修饰符仅包内可见。 private：只能修饰属性、方法和内部类。表示私有。其修饰的属性和方法只允许在本类中访问。 注意事项 如果不允许直接通过new对象，构造方法必须是private。 工具类不允许有public或者default构造方法。 类非static成员变量并且与子类分享，必须是protected。 类非static成员变量并且仅在本类中使用，必须是private。 类static成员变量并且仅在本类中使用，必须是private。 若是static成员变量，必须考虑是否为final。 类成员方法只供类内部调用，必须是private。 类成员方法只对继承公开，那么限制符为protected。 4、this与super5、类关系]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[码出高效-面向对象]]></title>
    <url>%2F2018%2F10%2F31%2F%E7%A0%81%E5%87%BA%E9%AB%98%E6%95%88-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是面向对象？之前面试的时候，有时候会问到一个很简单的问题，什么是面向对象编程思想？其实这个平时接触的很多,但是感觉越熟悉的东西却越无法表达出一个精髓。最近有幸看到《码处高效》，总结一些书里面的面向对象思想，也当做一个读书笔记。 OOP目标面向对象编程（Object Oriented Programming），简称OOP。其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。模型是用来反映现实世界中事物特征的。 面向对象实践了软件工程的三个主要目标：可维护性、可重用性、可扩展性。 面向过程与面向对象的区别面向过程是让程序有步骤地顺序做事。是一种过程化的叙事思路。但是缺点是面向大型软件开发的过程中。软件维护、代码复用产生了巨大的问题。代码写的就像流水账，代码耦合度大。往往会产生牵一发而动全身。 首先举个例子：比如现在需要打开门，面向过程的思想去编程是open（Door door），door是做作为参数去传入方法中的。面向过程的思想是创建一个Door的对象，这个对象其中有属性（颜色，材质…），然后door这个对象必然有close()、open()的方法。 从上面的例子就可以看出，面向过程强调是流程化的解决问题，结构松散，而面向对象是高内聚、低耦合，先去抽象模型，定义共性行为，再去解决实际问题。 面向对象的四个特征一般来说面向对象有三大特征：封装、继承、多态。但是还有一个很重要的特性：抽象，抽象是作为程序猿核心的要素之一，体现程序猿对业务的建模能力，以及架构的宏观掌控力。 面向对象思维，就是以对象模型为核心，丰富模型的内涵，扩展模型的外延，通过模型的行为组合去解决一类问题。封装使功能内聚的体现，使模块之间的耦合度降低，具有维护性；继承使子类能够继承父类，获得父类的属性和行为，提高复用性；多态是在复用性的基础上更具有扩展性，使运行期更具有想象力。 抽象是面向对象的基础能力。正确的建模分析是封装、继承、多态的基础。在软件开发中，抽象分为归纳和演绎。前者是从具体到本质，从个性到共性，将一类事物的共同特性去做归一化的逻辑。后者是从本质到具体，从共性到个性，是逐渐形象化的过程。归纳需要从抽象出对象的共性和属性。演绎是在已有问题解决方案的情况下，正确的找出合适的场景。（比如查多改少的业务，应使用数组而不是链表）。最优秀的抽象就是高斯林（Java之父）写的Object类。 封装是在抽象的基础上决定信息是否公开，核心的问题是以什么样的方式暴露信息，抽象是要找属性和行为的共性，但是属性具有敏感性（不能直接暴露）。封装的任务就是对属性、数据、部分内容的敏感部分进行隐藏。对属性的访问和修改通过定义的公共接口去进行，某些敏感方法不需要外部感知。封装使面向对象变的简单，耦合度变低，更利于维护。举一个生活中的例子。我们不需要知道洗衣机的内部构造。我们只使用开启/关闭按钮去操纵洗衣机去洗衣服。对于内部构造我们不了解。降低了用户使用的成本，有效的保护了内部数据的安全。其实这个符合面向对象设计的迪米特法则:即A模块使用B模块的某个接口行为，对B模块中除此行为之外的其他信息尽可能的少知道。这样子就尽可能降低耦合。 我们平时使用的封装使private属性值，提供相应的get()/set()方法去获取属性值。但是这中方式和之前直接去取属性值之间的区别是什么？—–&gt;比如有一天需要做权限校验和日志。这是在直接获取属性值是无法实现的，但是可以在set方法中去实现。 继承允许创建具有逻辑等级结构的类体系，形成一个继承树。这样做的好处是，某些基础模块可以直接被复用或间接复用，父类的能力通过基础赋予子类。使代码具有层次感，更具扩展性。基础是is-a的关系。其实这就使用了面向对象的里氏置换原则（LSP）—-&gt;就是在任何父类出现的地方都可以用子类替换。比如说：“放下武器”，其中武器是父类，我们可以用子类替换，放下手枪。这种情况是可以编译成功并执行的。所以武器和手枪就是is-a的关系。继承的成本很低，只需要关键字就可以，所以现在产生了继承滥用的问题。即方法污染和方法爆炸。方法污染是指父类具备的属性，通过继承传递给子类。子类不拥有执行此行为的能力。比如小黄鸭继承鸭子，但是小黄鸭不具备游泳的特性。方法爆炸是指继承树不断的扩大，底层类拥有的方法虽然都可以执行，但由于方法众多，很容易产生选择困难症。带来不便和安全隐患。提倡优先采用组合或聚合的类关系来复合其他类的能力。 多态是以上三个的特性为基础，根据运行时的实际对象类型，同一个方法产生不同的结果，使同一个行为具有不同的表现形式。我们明确两个概念“overload”和“override”，“override”为覆写，是子类实现接口。或继承父类时，保持方法的签名完全相同，实现不同的方法体，是垂直方向上行为的不同实现（一个类中就一个方法，父类，子类都有）。“overload”是重载，方法名称相同，参数个数和类型不同。是水平方向上行为的不同实现（一个类中多个重名方法）。多态是指在编译层面无法具体确定最终调用的方法体，以覆写为基础实现面向对象特征，在运行期由JVM通过动态绑定，调用合适的覆写方法体来执行。重载是编译期确定方法调用，属于静态绑定，本质上重载的结果是不同的方法。五克拉的碳元素，可以是钻石，也可以是煤。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口的区别]]></title>
    <url>%2F2018%2F09%2F29%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[抽象类和接口的区别 参数 抽象类 接口 默认的方法实现 它可以有默认的方法实现 接口完全是抽象的。它根本不存在方法的实现 实现 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 构造器 抽象类可以有构造器 接口不能有构造器 与正常Java类的区别 除了你不能实例化抽象类之外，它和普通Java类没有任何区别 接口是完全不同的类型 访问修饰符 抽象方法可以有public、protected和default这些修饰符 接口方法默认修饰符是public。你不可以使用其它修饰符。 main方法 抽象方法可以有main方法并且我们可以运行它 接口没有main方法，因此我们不能运行它。 多继承 抽象方法可以继承一个类和实现多个接口 接口只可以继承一个或多个其它接口 速度 它比接口速度要快 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。 添加新方法 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。 上面的一些只是其使用上的不同，简单来说的话，其实就是接口是对动作的抽象，抽象类是对根源的抽象。 抽象类表示的是，这个对象是什么，接口表示的是这个对象能干什么。 比如，男人、女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。 人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它. 所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 第一点． 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。 第二点． 接口可以多继承，抽象类不行 第三点． 接口定义方法，不能实现，而抽象类可以实现部分方法。 第四点． 接口中基本数据类型为static 而抽类象不是的。 当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap与HashTable的终极区别]]></title>
    <url>%2F2018%2F09%2F29%2FHashMap%E4%B8%8EHashTable%E7%9A%84%E7%BB%88%E6%9E%81%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ 这两个其实区别挺大的，有时候面试也会经常问，今天做题又遇见了，所以做一个总结，希望查漏补缺一下。不同分为6个方向。 继承不同 123public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map 同步 Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 键是否课为null Hashtable中，key和value都不允许出现null值。 在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 内部遍历方法 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 哈希值的使用 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 扩容方法 Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM-内存模型]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ 入门学习JVM首先从几个面试题开始入门： 请谈谈你对JVM的理解?java8的虚拟机有什么更新？ 什么是OOM？什么是StackOverflowError?有哪些方法分析？ JVM的常用参数调优你知道哪些？ 内存快照抓取和MAT分析DUMP文件知道吗？ 谈谈JVM中，对类加载器你的认识？ 这个是几个主要的面试题。就是说我们学习完JVM之后至少要解决上面的问题。 JVM体系结构概述其实JVM的知识主要集中在对于JVM内部体系结构的了解，关键内容就是下图： 图要牢记 从上往下看，其实这里面的内容就包括了整个class文件加载的过程，以及JVM主要的学习内容（不包括GC算法）。 从图中我们可以看到包含的内容有类文件结构，类加载机制以及类加载引擎。然后是Java的内存区域（灰色区域不是线程共享的，不存在GC）。 类加载器我们就按照上面的图例解释下来的知识。类加载器的功能： 负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定 看这个图可以理解为就是car.class是一个图纸，创建出的car1、car2、car3都是根据图纸建造的车。 Java中的类加载分类 虚拟机自带的加载器 启动类加载器（Bootstrap） C++ 扩展类加载器（Extension） Java 应用程序类加载器（AppClassLoader）Java也叫系统类加载器，加载当前应用的classpath的所有类 用户自定义加载器 Java.lang.ClassLoader的子类，用户可以定制类的加载方式 双亲委派模型+沙箱安全机制 简单的说就是：我爸是李刚，有事找我爹。自顶向下，从Bootstrap开始执行。作用就是避免恶意代码对java源代码的修改。 双亲委派模型要求除顶层的启动类加载器外，其他的类加载器都应有自己的父类加载器。（这里的类加载器之间的父子关系一般不会以继承来实现。而是使用组合关系实现父类加载器）。 双亲委派模型的工作过程： 如果一个类的加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的请求最终都会传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（它的搜索范围内没有这个类）时，子加载器才会尝试自己去加载。 双亲委派机制的代码主要集中在java.lang.ClassLoader的loadClass()方法中，具体的逻辑是：先检查是否被加载过，若没有加载，则调用父类加载器loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器 native关键字native方法依靠的都是JNI=Java Native Interface调用其他语言的接口，大部分为C语言的函数库。 Native Interface本地接口 本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序， Java 诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies。目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket通信，也可以使用Web Service等等，不多做介绍。 Native Method Stack（本地方法栈） 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。 PC寄存器（程序计数器）作用是计数和调度。 每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。 方法区（Metyhod Area）方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区属于共享区间。 静态变量+常量+类信息(构造方法/接口定义)+运行时常量池存在方法区中 But 实例变量存在堆内存中,和方法区无关 栈(Java Stack)栈的简介 栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。 8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。 出现的异常为java.lang.StackOverflowError 栈存储的什么数据？栈帧中主要保存3 类数据： 本地变量（Local Variables）:输入参数和输出参数以及方法内的变量； 栈操作（Operand Stack）:记录出栈、入栈的操作； 栈帧数据（Frame Data）:包括类文件、方法等等。 栈运行原理栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧 F1，并被压入到栈中，A方法又调用了 B方法，于是产生栈帧 F2 也被压入栈，B方法又调用了 C方法，于是产生栈帧 F3 也被压入栈，……执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧…… 遵循“先进后出”/“后进先出”原则。 图示在一个栈中有两个栈帧： 栈帧 2是最先被调用的方法，先入栈， 然后方法 2 又调用了方法1，栈帧 1处于栈顶的位置， 栈帧 2 处于栈底，执行完毕后，依次弹出栈帧 1和栈帧 2， 线程结束，栈释放。 每执行一个方法都会产生一个栈帧，保存到栈(后进先出)的顶部，顶部栈就是当前的方法，该方法执行完毕 后会自动将此栈帧出栈。 栈+堆+方法区的交互关系 HotSpot是使用指针的方式来访问对象： Java堆中会存放访问类元数据的地址， reference存储的就直接是对象的地址 Java堆体系结构概述Heap 堆一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分： Young Generation Space —&gt;新生区—&gt;Young/New Tenure generation space—&gt;养老区—&gt;Old/ Tenure Permanent Space—&gt;永久区—&gt;Perm Java7之前——————————-&gt; 一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行。 堆内存逻辑上分为三部分：新生+养老+永久 java8：新生+养老+元空间 产生OOM异常的原因:养老区已经经过full GC后还是无法有足够空间，将产生OOM异常。 新生区 新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的类都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。若幸存 0区也满了，再对该区进行垃圾回收，然后移动到 1 区。那如果1 区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生MajorGC（FullGC），进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。 如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二： （1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。 （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。 永久区 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。 如果出现java.lang.OutOfMemoryError: PermGen space，说明是Java虚拟机对永久代Perm内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。 Jdk1.6及之前： 有永久代, 常量池1.6在方法区 Jdk1.7： 有永久代，但已经逐步“去永久代”，常量池1.7在堆 Jdk1.8及之后： 无永久代，常量池1.8在元空间 实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。(类似于中国与中国台北的关系) 对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)” ，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区(相当于是一个接口interface)的一个实现，jdk1.7的版本中，已经将原本放在永久代的字符串常量池移走。 常量池（Constant Pool）是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GC算法]]></title>
    <url>%2F2018%2F09%2F01%2FGC%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ GC算法就是Java虚拟机的内存回收算法。总体的大纲已经上传，需要学习的其实这个大纲已经足够，其他的更加深入的内容，可以去看《深入理解java虚拟机》。 这个就是整个学习的大纲，具体的xmind文件上传到百度云。链接：https://pan.baidu.com/s/1C3smD1fyN2v-FlZgkNOwlA 密码：ll8o欢迎下载]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC]]></title>
    <url>%2F2018%2F08%2F28%2FJUC%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ 这次主要写的是关于JUC的一些知识点，其实就是高并发的一些内容，多线程的深入理解。脑图有限，就先放一张图片，需要的请下载，里面有代码和图片的示例。 链接：https://pan.baidu.com/s/19rkwxlc2R6NKx3xjE8CCUw 密码：f44x]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis(三)]]></title>
    <url>%2F2018%2F08%2F20%2FRedis-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ redis的事务Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 Redis事务的操作 这是事务的简单操作。具体的过程主要为下面的几种 Case1：正常执行 MULTI 开启事务 。。。执行操作 EXEC 执行事务 Case2：放弃事务 MULTI 开启事务 。。。执行操作 DISCARD 放弃执行 Case3：全体连坐 MULTI 开启事务 。。。执行操作 。。。出现错误（注意，是在开启事务之后，代码中直接报错） EXEC 执行事务 程序报错，全部未执行 Case4：冤头债主 MULTI 开启事务 。。。执行操作 。。。出现错误代码（注意，是在开启事务之后，代码思路有错，就像运行时异常，程序并没有报错） EXEC 执行事务 程序报错，出现错误的一行未执行 Case5：watch监控 WATCH balance 监视balance这一列 set balance 300 加塞篡改 MULTI 开启事务 增加balance 减少dept EXEC 执行事务 未修改成功，因为监控了key，如果key被修改了，后面一个事务的执行失效 UNWATCH 取消监控 一旦执行了exec之前加的监控锁都会被取消掉了 总结： Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变， 比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行 通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生 了变化， EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用 者事务执行失败 Redis事务的三阶段 开启：以MULTI开始一个事务 入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面 执行：由EXEC命令触发事务 Redis事务的三特性 单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行， 也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题。 不保证原子性(部分支持事务)：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。 redis的订阅发布进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 命令及案例： ++案例：++ 先订阅后发布后才能收到消息， 1 可以一次性订阅多个，SUBSCRIBE c1 c2 c3 2 消息发布，PUBLISH c2 hello-redis 3 订阅多个，通配符， PSUBSCRIBE new4 收取消息， PUBLISH new1 redis2015 redis的主从复制主从复制我们经常听到，用行话讲就是：主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主 主要是用来做读写分离和容灾恢复。 主要的操作步骤： 配从(库)不配主(库) 从库配置：slaveof 主库IP 主库端口 每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件 Info replication 修改配置文件细节操作 拷贝多个redis.conf文件 开启daemonize yes Pid文件名字 指定端口 Log文件名字 Dump.rdb名字 常用3招（详细的记录请查询脑图） 一主二仆 一个Master两个Slave 薪火相传 上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力 反客为主 使当前数据库停止与其他数据库的同步，转成主数据库 主从复制的具体原理Slave启动成功连接到master后会发送一个sync命令 Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步 但是只要是重新连接master,一次完全同步（全量复制)将被自动执行 哨兵模式其实我们观察了上面三种的主从模型，可以发现都有弊端。我们需要一个理想的模型：在主服务器坏了之后，立刻可以选出一个主服务器。并在主服务器恢复之后还可以加入到这个服务器集群中。反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。 调整结构，6379带着80、81 自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错 配置哨兵,填写内容 sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1 上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机 启动哨兵 Redis-sentinel /myredis/sentinel.conf 上述目录依照各自的实际情况配置，可能目录不同 正常主从演示 原有的master挂了 投票新选 重新主从继续开工,info replication查查看 问题：如果之前的master重启回来，会不会双master冲突？答：大家可以看下图，就是具体的操作演示，我们可以看到最后6379节点在恢复之后加入了6380节点的下面。所以说哨兵模式可以自己去调节 复制的缺点： ++复制延时++：由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。 Jedis的使用首先要使用Jedis，需要导入jar或者maven配置 Commons-pool-1.6.jar Jedis-2.1.0.jar 连接Redis数据库测试连通性123456789@Test public void test() &#123; Jedis jedis = new Jedis (&quot;119.23.xx.xxx&quot;);//默认端口是6379,如果不是记得再加一个参数。 if (jedis.ping ().equals (&quot;PONG&quot;)) &#123; System.out.println (&quot;连接成功&quot;); &#125; else &#123; System.out.println (&quot;连接失败&quot;); &#125; &#125; https://github.com/jh0904/Learn_More/tree/master/src/main/java/redis下面的操作和在linux里面的操作没有什么区别，大家可以去参考一下，我的GIT里面把简单的都实现了，大家可以看看。 操作基本的数据类型和键操作Jedis的事务操作Jedis的主从复制Jedis的连接池（单服务器的连接池，多服务器使用哨兵池）]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis（二）]]></title>
    <url>%2F2018%2F08%2F19%2FRedis2%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ redis的基本数据类型Redis主要有五种数据类型 String（字符串） String（字符串） string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。 string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。 string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M. Hash（哈希，类似java里的Map） Hash（哈希） Redis hash 是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 类似Java里面的Map&lt;String,Object&gt; List（列表） List（列表） Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。 它的底层实际是个链表 Set（集合） Set（集合） Redis的Set是string类型的无序集合。它是通过HashTable实现实现的， Zset(sorted set：有序集合) zset(sorted set：有序集合) Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。 redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。 Redis键的操作哪里去获得redis常见数据类型操作命令 Http://redisdoc.com/ keys * 查询所有的键 exists key的名字，判断某个key是否存在 move key db —&gt;当前库就没有了，被移除了 expire key 秒钟：为给定的key设置过期时间 ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期 type key 查看你的key是什么类型 Redis五大数据结构对于五大基本数据结构，增加，删除，遍历。Jedis代码和Redis操作基本无差异，已将代码上传到GIT，大家可以参考。 https://github.com/jh0904/Learn_More/blob/master/src/main/java/Redis1/RedisTest.java redis的持久化RDB（Redis DataBase）在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方 式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 Rdb 保存的是dump.rdb文件 如何触发RDB 配置文件中默认的快照配置 冷拷贝后重新使用 可以cp dump.rdb dump_new.rdb需要牢记的一点是三种情况—&gt;save 900 1 save 300 10 save 60 10000 就是说保存的机制是900秒改动一次就保存。依次类比。 命令save或者是bgsave Save：save时只管保存，其它不管，全部阻塞 BGSAVE：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义 如何恢复 将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可 CONFIG GET dir获取目录 优势 适合大规模的数据恢复 对数据完整性和一致性要求不高 缺点 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就 会丢失最后一次快照后的所有修改 Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑 停止 动态所有停止RDB保存规则的方法：redis-cli config set save “” 具体的分析大家可以参考下图： AOF(Append Only File)Aof保存的是appendonly.aof文件 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 AOF启动/修复/恢复 正常恢复 启动：设置Yes 修改默认的appendonly no，改为yes 将有数据的aof文件复制一份保存到对应目录(config get dir) 恢复：重启redis然后重新加载 异常恢复 启动：设置Yes 修改默认的appendonly no，改为yes 备份被写坏的AOF文件 修复： Redis-check-aof --fix进行修复 恢复：重启redis然后重新加载 Rewrite 是什么： AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof 重写原理 AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)， 遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件， 而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似 触发机制 Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发 优势 每修改同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好 每秒同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失 不同步：appendfsync no 从不同步 劣势 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同 具体的分析大家可以参考下图： 两者的对比和总结RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储 AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些 命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大 ++同时开启两种持久化方式++ 在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整. RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ 作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NoSQL简述]]></title>
    <url>%2F2018%2F08%2F17%2FNoSQL%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ 什么是nosqlNoSQL数据库概述NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。 NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。特点是： 不遵守SQL标准 不支持ACID（事务） 远超过SQL的性能 NoSQL使用场景 对数据高并发的读写 海量数据的读写 对数据高可扩展性的 NoSQL不适用场景 需要事务支持 基于sql的结构化查询存储，处理复杂的关系,需要即席查询。 主要的NoSQL数据库的介绍 Memcached 很早出现的NoSql数据库 数据都在内存中，一般不持久化 支持简单的key-value模式 一般是作为++缓存数据库++辅助持久化的数据库 Redis 几乎覆盖了Memcached的绝大部分功能 数据都在内存中，支持持久化，主要用作备份恢复 除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。 一般是作为++缓存数据库++辅助持久化的数据库 mongoDB 高性能、开源、模式自由(schema free)的++文档型数据库++ 数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘 虽然是key-value模式，但是对value（尤其是json）提供了丰富的查询功能 支持二进制数据及大型对象 可以根据数据的特点替代RDBMS ，成为独立的数据库。或者配合RDBMS，存储特定的数据。 CAP原理和BASE关系型数据库遵循ACID规则 事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性： 1、A (Atomicity) 原子性原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。 2、C (Consistency) 一致性一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。 3、I (Isolation) 独立性所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的 4、D (Durability) 持久性 持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。但是现在我们使用了NoSQL数据库，它遵守的是CAP原理。 CAP原理是指： C : Consistency（强一致性） A : Availability（可用性）P : Partition tolerance（分区容错性） CAP理论虽然说很好，但是实际上最多只可以实现两个。分区容忍性是我们必须要实现的，所以我们要在强一致性和可用性做选择。 没有NoSQL数据库能同时保证这三点 CA 传统Oracle数据库（单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。） AP 大多数网站架构的选择（满足一致性，分区容忍必的系统，通常性能不是特别高。） CP Redis、Mongodb （满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。） 注意：分布式架构的时候必须做出取舍。一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。因此牺牲C换取P，这是目前分布式数据库产品的方向。 CAP理论的核心：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。 有一个CAP的图片很形象，很清晰的说明了三个的分类和区别： BASE原理BASE其实是下面三个术语的缩写： 基本可用（Basically Available） 软状态（Soft state） 最终一致（Eventually consistent） BASE就是为了解决数据库强一致性引起的问题而引起的可用性降低的解决方案。具体的思想就是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法 简单的了解一下分布式和集群 分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。 集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis(一)]]></title>
    <url>%2F2018%2F08%2F17%2FRedis%E4%B8%80%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ 初识redisRedis的简单介绍Redis是一个开源的key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis的安装（Linux安装）Windows安装比较简单，所以不做概述。安装具体过程： 下载获得redis-3.0.4.tar.gz后将它放入我们的Linux目录/opt /opt目录下，解压命令:tar -zxvf redis-3.0.4.tar.gz 解压完成后出现文件夹：redis-3.0.4 进入目录:cd redis-3.0.4 在redis-3.0.4目录下执行make命令 如果make完成后继续执行make 安装完成后的界面： 文件的简单介绍 名称 功能 Redis-benchmark 性能测试工具，可以在自己本子运行，看看自己本子性能如何 Redis-check-aof 修复有问题的AOF文件，rdb和aof后面讲 Redis-check-dump 修复有问题的dump.rdb文件 Redis-cli 客户端，操作入口 Redis-sentinel redis集群使用 Redis-server 1 Redis服务器启动命令 注意事项：修改redis.conf文件将里面的daemonize no 改成 yes，让服务在后台启动；将默认的redis.conf拷贝到自己定义好的一个路径下，比如/myconf（保护Redis的安全） Redis的启动及杂项启动 12redis-server /myredis/redis.confredis-cli -p 6379 测试连通 123ping--&gt;PONG (出现这个表示连接成功) 关闭 12单实例关闭：redis-cli shutdown多实例关闭，指定端口关闭:redis-cli -p 6379 shutdown 杂项知识讲解 单进程模型来处理客户端的请求。对读写等事件的响应是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率 默认16个数据库，类似数组下表从零开始，初始默认使用零号库 Select命令切换数据库 Dbsize查看当前数据库的key的数量 Flushdb：清空当前库 Flushall；通杀全部库 统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上 Redis索引都是从零开始]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习TCP/UDP]]></title>
    <url>%2F2018%2F08%2F09%2FTCP%E7%9A%84%E7%9F%A5%E8%AF%86%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[用户数据报协议UDP概述 UDP是无连接的 UDP使用尽最大努力支付 UDP是面向报文 UDP是没有拥塞控制的 UDP支持一对一、一对多、多对一和多对多的交互通信 UDP首部开销小 首部格式 (1) 源端口 源端口号。在需要对方回信时选用。不需要时可用全0。 (2) 目的端口 目的端口号。 这在终点交付报文时必须要使用到。 (3) 长度 UDP用户数据报的长度，其最小值是8（仅有首部） (4) 检验和 检测UDP用户数据报在传输中是否有错。有错就丢弃。 传输控制协议TCP概述(1).TCP是面向连接的传输层协议。 (2).TCP连接只能有两个端点，TCP是点到点的。 (3).TCP提供可靠的交付服务，保证 传输的数据无差错，不可重，有序，不丢失。 (4).TCP提供全双工通信，TCP允许通信双 方任何时间都能发送数据，因此TCP两端都设有发送和接收缓存。 (5).TCP是面向字节流的。 TCP连接的端点是Socket。Socket=（ip地址:端口号）每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确认 TCP连接 ::={socket1,socket2}={(IP1:port1),(IP2,port2)} 可靠传输的工作原理停止等待协议无差错等待 出现差错 出现差错至少等待一轮发送时间，在重新发送请求。只有在收到确认之后才会删除之前的数据包缓存。 确认丢失或确认迟到 确认和重传机制就可以在不可靠的网路上实现可靠通信 连续ARQ协议在说连续ARQ协议之前，先说一下信道利用率。之前我们的传输是这样子的信道利用率的公式为 信道利用率U = TD / (TD + RTT + TA) 这样的信道利用率太低，很多时间都在等待确认的时候。所以出现了流水线传输（高信道利用率）。就类似于这样子一次性发送很多，再去等待确认。一般采用累计确认的方法，就是对到达的最后一个分组进行确认。连续ARQ指的就是发送方维持的发送窗口，把位于窗口内的5个分组都发送出去，而不需要等待对方的确认。 TCP报文格式 源端口和目的端口:各占 2 字节.端口是传输层与应用层的服务接口.传输层的复用和分用功能都要通过端口才能实现 序号: 占 4 字节.TCP 连接中传送的数据流中的每一个字节都编上一个序号.序号字段的值则指的是本报文段所发送的数据的第一个字节的序号 确认号: 占 4 字节,是期望收到对方的下一个报文段的数据的第一个字节的序号 数据偏移/首部长度: 占 4 位,它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远.“数据偏移”的单位是 32 位字(以 4 字节为计算单位) 保留: 占 6 位,保留为今后使用,但目前应置为 0 紧急URG: 当 URG=1 时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据) 确认ACK: 只有当 ACK=1 时确认号字段才有效.当 ACK=0 时,确认号无效 PSH(PuSH): 接收 TCP 收到 PSH = 1 的报文段,就尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付 RST (ReSeT): 当 RST=1 时,表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）,必须释放连接,然后再重新建立运输连接 同步 SYN: 同步 SYN = 1 表示这是一个连接请求或连接接受报文 终止 FIN: 用来释放一个连接.FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接 检验和: 占 2 字节.检验和字段检验的范围包括首部和数据这两部分.在计算检验和时,要在 TCP 报文段的前面加上 12 字节的伪首部 紧急指针: 占 16 位,指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面） 选项: 长度可变.TCP 最初只规定了一种选项,即最大报文段长度 MSS.MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节.” [MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度.数据字段加上 TCP 首部才等于整个的 TCP 报文段] 填充: 这是为了使整个首部长度是 4 字节的整数倍 在其中ACK应该和SYN放在一起学习 ACK：确认 当ACK=1时，字段有效，ACK=0时，字段无效。SYN：同步。当SYN=1而ACK=0时，请求连接。当SYN=1，ACK=1时同意连接 TCP可靠传输的实现主要使用的是滑动窗口，主要实现如下： 特点: 以字节为单位的滑动窗口 A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后） 要求: TCP 标准没有规定对不按序到达的数据应如何处理.通常是先临时存放在接收窗口中,等到字节流中所缺少的字节收到后,再按序交付上层的应用进程 TCP 要求接收方必须有累积确认的功能,这样可以减小传输开销 还有一个就是选择确认SACK，就是说比如之前发送了这样的数据包 [1,2,3][4,5,6]…[10,11,12] 从上图我们可以看出丢失了[7,8,9]这几个数据包，下次应该从6开始重新发，但是[10,11,12]都已经接收了，需要把这些已经接收了的数据告诉发送法，不用在发送这些数据包了。 TCP流量控制流量控制就是让发送方的数据不要太快，要让接收方来得及接收在A向B发送数据，建立连接的时候。B就告诉了A。它的接收窗口（rwnd）的大小。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。 TCP拥塞控制拥塞控制的原理：就是网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这就是拥塞。 拥塞控制的几个方法：发送方维持一个拥塞窗口，拥塞窗口取决于网络的拥塞程度，一直在动态变化着。发送方让自己的发送窗口等于拥塞窗口。网络没有出现拥塞，拥塞窗口就大一点。出现就小一点。 慢开始就是由小到大逐渐增大发送窗口。每次加倍。 拥塞避免就是让拥塞窗口cwnd缓慢的增大，每经过一个往返时间RTT就把发送方的拥塞窗口加一，而不是加倍。 快重传和快恢复： 快重传：一连收到三个重复确认的请求之后，就立即重传未被确认的报文段 快恢复：当发送方接收到了三个重复请求之后，就执行“乘法减小”算法，把慢开始门限减半，而不是像慢开始降为1。 发送方窗口的上限值=Min[rend,cwnd]；发送方的发送窗口一定不能超过对方给出的接收窗口值。 TCP的运输连接管理这个问题就比较经典了。主要就是连接时候的三次握手和断开连接的四次挥手协议。 三次握手 步骤: A 的 TCP 向 B 发出连接请求报文段,其首部中的同步位 SYN = 1,并选择序号 seq = x,表明传送数据时的第一个数据字节的序号是 x B 的 TCP 收到连接请求报文段后,如同意,则发回确认(B 在确认报文段中应使 SYN = 1,使 ACK = 1,其确认号ack = x﹢1,自己选择的序号 seq = y) A 收到此报文段后向 B 给出确认,其 ACK = 1,确认号 ack = y﹢1(A 的 TCP 通知上层应用进程,连接已经建立,B 的 TCP 收到主机 A 的确认后,也通知其上层应用进程：TCP 连接已经建立)四次挥手 步骤: 数据传输结束后,通信的双方都可释放连接.现在 A 的应用进程先向其 TCP 发出连接释放报文段,并停止再发送数据,主动关闭 TCP 连接(A 把连接释放报文段首部的 FIN = 1,其序号seq = u,等待 B 的确认) B 发出确认,确认号 ack = u＋1,而这个报文段自己的序号 seq = v(TCP 服务器进程通知高层应用进程.从 A 到 B 这个方向的连接就释放了,TCP 连接处于半关闭状态.B 若发送数据,A 仍要接收) 若 B 已经没有要向 A 发送的数据,其应用进程就通知 TCP 释放连接 A 收到连接释放报文段后,必须发出确认,在确认报文段中 ACK = 1,确认号 ack=w﹢1,自己的序号 seq = u + 1]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP面试考点]]></title>
    <url>%2F2018%2F08%2F09%2FHTTP%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ Http与Https的区别 HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头 HTTP 是不安全的，而 HTTPS 是安全的 HTTP 标准端口是80 ，而 HTTPS 的标准端口是443 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层 HTTP 无法加密，而HTTPS 对传输的数据进行加密 HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书什么是Http协议无状态协议?怎么解决Http协议无状态协议? 无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息 也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。 可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。 HTTPS的工作原理上面这个图片具体解析了HTTPS的一个传输过程具体的步骤如下： 一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验； 二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）； 三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名； 四、发送给服务端，此时只有服务端（RSA私钥）能解密。 五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。URI、URL、URN URIURI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。URI一般由三部组成： ①访问资源的命名机制 ②存放资源的主机名 ③资源自身的名称，由路径表示，着重强调于资源。URLURL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成： ①协议(或称为服务方式) ②存有该资源的主机IP地址(有时也包括端口号) ③主机资源的具体地址。如目录和文件名等 URNRN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。 三者区别URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。 在java中的区别在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。 在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。 相反的是，URL类可以打开一个到达资源的流。 常见的HTTP方法有哪些 GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器 POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。 HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。 DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 OPTIONS：查询相应URI支持的HTTP方法。 HTTP请求报文与响应报文格式a、请求行：包含请求方法、URI、HTTP版本信息 b、请求首部字段 c、请求内容实体 d、空行a、状态行：包含HTTP版本、状态码、状态码的原因短语 b、响应首部字段 c、响应内容实体 d、空行 常见的HTTP相应状态码2xx200：请求被正常处理 204：请求被受理但没有资源可以返回 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。 3xx301：永久性重定向 302：临时重定向 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上 304：发送附带条件的请求时，条件不满足时返回，与重定向无关 307：临时重定向，与302类似，只是强制要求使用POST方法 4xx400：请求报文语法有误，服务器无法识别 401：请求需要认证 403：请求的对应资源禁止被访问 404：服务器无法找到对应资源 5xx500：服务器内部错误 503：服务器正忙 HTTP优化方案 TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。 内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。压缩：将文本数据进行压缩，减少带宽 SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速 TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。 为什么TCP需要第三次握手？三次握手是建立连接的过程，主要第一次是客户端请求服务端通信，第二次是服务端相应请求，接收通信。第三次就开始传输数据。第三次的意义就在于，为了防止之前的连接请求报文段突然又传送到了服务器，因而发生错误。所以第三次请求。 这是服务器的一种异常状况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才能到达B。 本来这是一个早已失效的报文段。 但B收到此失效的连接请求报文段后，就误认为A又发出了一次新的连接请求。 于是又向A发出确认报文段，同意建立连接。 假定不采用三次握手，那么只要B发出确认，新的连接就建立了。 由于现在A并没有发出建立连接的请求，因此不会理财B的确认，也不会向B发送数据。 但B却以为新的运输连接已经建立了，并一直等待A发来数据。 B的许多资源就这样浪费了。 访问一个URl会发生什么？这个图是我在阅读深入分析Java Web技术内幕时候的一张图片，其实很好。这个其实比较像我们日常生活中经常使用的网页访问发生的过程。 首先抛出一个问题：我们在访问 www.jh0904.top,会发生什么？ 过程的大概路径应该是这样子的： 访问DNS域名服务器 发起连接（TCP的3次握手） 建立TCP连接后发起http请求 服务器响应http请求，浏览器得到html代码 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天谈谈正则表达式]]></title>
    <url>%2F2018%2F08%2F08%2F%E4%BB%8A%E5%A4%A9%E8%B0%88%E8%B0%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式的概述 编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 就像我们在数据库中的“*”。 正则表达式的基本语法 正则表达式是由 == 原意文本字符 == (a,b,c,1,2,3等)和 == 元字符 == ( . * ? 等)组成来匹配指定内容的表达式。 原意文本字符 原意文本其实很好理解，就是我们平时经常使用的意义。比如说 a在正则中表示匹配a这个字符 1在正则中表示匹配1这个字符原意文本就是没有没有特殊的含义。元字符元字符指在正则表达式中有特殊含义的专用字符，比如： 元字符 含义 举例 \ 转义字符，将后一个字符标记为特殊字符或将元字符转为原意字符 1、\表示匹配原意字符\； 2、.表示匹配英文句号“.” ； 3、\d表示匹配数字。 . 匹配除换行(\n)以外的所有字符 abc.能匹配到“abc”后面的那个字符，比如“abc”后面的空格、字母、数字、汉字等 ^ 匹配字符串的开始位置，在集合([])中表示“非” 1、^\d\d\d能匹配“123”、“666”等，但不能匹配“a123”、“b123”、“-123”等； 2、^\w+\b表示匹配第一个单词； 3、[^ajl]匹配除了“a”、“j”、“l”以外的任意字符。 $ 匹配字符串的结束位置 ^\d\d.\d\d$能匹配“12.01”和“00.00”等，但不能匹配“0.00”、“12.0”、“123.00”等 ? 匹配前面子表达式0次或一次 good?可以匹配“goo”和“good”等，但是不能匹配“go”等 + 匹配1或多个正好在它之前的那个字符。 正则表达式9+匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。 * 匹配前面子表达式0次或多次 zo*能匹配“zo”、“zoo”、“zooo” () 标记一个子表达式的开始和结束位置，其结束符号“)”是元字符 [ 字符组的起始符号，其结束符号“]”不是元字符 { 标记限定符的开始，其结束符号“}”不是元字符 \ 表示“或” 1、(a\b\c)匹配“a”、“b”、“c”之中的一个； 如果要匹配元字符本身可以用\来取消元字符的特殊含义，比如.匹配英文句号”.”；*匹配“*”本身；+匹配“+”本身……常用表达式举例 表达式 含义 举例 \w 匹配字母、数字、下划线 abc\w表示匹配“abc”开头并且后面跟着一个字母或数字或下划线的字符串 \W 匹配非字母、非数字、非下划线 \W相当于[^\w] \d 匹配数字 \d\d\d表示匹配3个连续的数字 \D 匹配非数字 \D相当于[^\d] \b 匹配单词的开始或结束 \bgo\w*\b表示匹配“go”开头的一个单词 \B 匹配非单词的开始或结束 \B相当于[^\b] \s 匹配任何空白字符，如回车、空格、制表符等 \s相当于[\f\n\r\t\v] \S 匹配任何非空白字符 \S相当于[^\s] {n} 匹配前面子表达式n次 \d{11}表示匹配连续的11个数字 {n,m} 匹配前面子表达式n到m次 \d{7,11}表示匹配连续的7-11个数字 {n,} 匹配前面子表达式n次以上 \d{5,}表示匹配连续的5个以上的数字 [xyz] 表示字符集，匹配所包含的任意一个字符 1、[abc]能匹配“a”或“b”或“c”；2、[!?.]表示匹配“!”、“?”、“”、“.”中的任意一个；3、[^0-9]匹配所有非0到9的字符，相当于\D。 [a-z] 表示字符范围，能匹配范围内的任意一个字符 1、[a-z]能匹配26个小写字母中任意字母；2、[0-9]能匹配0到9的任意数字，和\d一样的效果；3、[1-9]能匹配1到9的任意数字； 4、[\u4e00-\u9fa5]能匹配所有汉字。 (abc) 组合，将几个项组合成为一个单元，可以对这个单元使用限定符 (\.[a-z]+)+$可以匹配“.com”、“.net”、“.com.cn”等结尾的字符 运算符优先级 正则表达式是从左向右进行运算的，并遵循优先级顺序。优先级顺序如下表（先高后低）： 运算符 优先级 说明 \ 最高 转义字符 () (?:) (?=) [] 高 圆括号和方括号 * + ? {n} {n,} {n,m} 中 限定符 ^ $ \任何元字符 任何字符 低 定位点和序列（位置和顺序） \ 最低 选择符“或” 常用的正则表达式汉字 [\u4e00-\u9fa5] //中文ACALL码的范围 邮箱 邮箱这个比较重要了，一般都会用到。就比如我们在写表单校验的时候。 邮箱一般为“名称@域名”的格式，由于名称部分格式太多（有些邮箱名称允许有中文）不好限制，所以本文只验证名称和域名有“英文字母”、“数字”、“下划线”、“中划线(-)”、“英文句号(.)”的邮箱。 \w可以匹配“英文字母、数字、下划线” .可以匹配英文句号“ . ” -可以匹配原意字符“ - ”本身 @可以匹配原意字符“ @ ”本身 ([.-]\w+)可以匹配“ photo-google ”中的“ -google ”、“ photo.google ”中的“ .google ” (.[a-zA-z0-9-]+)+可以匹配“ .com ”、“ .com.cn ”等 表达式：^\w+([.-]\w+)*@[\w-]+(.[a-zA-z0-9-]+)+$ 手机号 于号码段在不断更新，本文只验证“13”、“15”、“17”、“18”开头后面有9个数字的号码（如表达式1） 表达式1：^(13|15|17|18)\d{9}$ 表达式2：^(13[0-9]|15[0-9]|17[07]|18[05689])\d{8}$ 座机号 座机号一般为“区号[-]号码”的格式，如果区号部分是3位则号码部分为8位，如021-67678989、02167678989；如果区号部分是4位则号码部分是7位，如0765-6767676、02167678989。 表达式1：^\d{3}-?\d{8}|\d{4}-?\d{7}$ 表达式2：^(\d{3}-?\d{8})|(\d{4}-?\d{7})$（由于选择符“|”优先级最低，所以组合符号“()”加与不加都行） 身份证 身份证号码是由18个字符组成，前17个必须为数字(\d)，第一位不能为0([1-9])，最后一位可能是数字(\d)也可能是“x/X”([xX])。 表达式：^[1-9]\d{16}[\dxX]$ 正则表达式匹配规则 一切从最基本的开始。模式，是正规表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如： ^once 这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。 bucket$ 这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符^和$同时使用时，表示精确匹配（字符串与模式一样）。例如： ^bucket$ 只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式 once 与字符串There once was a man from NewYorkWho kept all of his cash in a bucket.是匹配的。 在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些??表符等），要用到转义序列。所有的转义序列都用反斜杠(\)打头。制表符的转义序列是：\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式： ^\t 类似的，用\n表示“新行”，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\表示，句号.用.表示，以此类推。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之序列化是什么鬼？]]></title>
    <url>%2F2018%2F08%2F05%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ java的序列化和反序列化是java中很常见的一种。我们其实平时对集合、线程或是反射什么了解比较多，其实序列化在我们编写java程序中也起很大的作用。序列化的主要工作是把一个java对象变成二进制的字节流，反序列化就是把二进制字节流变成java对象。接下来我们来看一下具体的操作。 序列化和反序列化的概念 对象的序列化：把对象转换为字节序列的过程称为对象的序列化。 对象的反序列化：把字节序列恢复为对象的过程称为对象的反序列化。 对象序列化的作用：其实序列化主要有两个用途： 把对象的字节序列化永久的保存到硬盘上，通常保存在一个文件中。 在网络上传输对象的字节序列。 把对象保存到文件中，离开内存，长住物理硬盘。常见的应用就是Web服务器中的Session对象，当10万用户并发访问时，就有可能出现10万个session对象，内存不够，所以先保存一些到硬盘中去。需要的时候，再拿出来还原到内存中。 当两个进程在进行远程通信的时候，彼此可以传输数据。但是不论什么类型的数据，都以二进制序列的形式在网络上传输。如下图： 从某种意义上来说，可以让java对象跨越时间和空间，获得永生。但是永生也是有代价的，就是必须使用java语言（哈哈，java序列化肯定是java语言）。 Java中的序列化API java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。 java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 只有实现了Serializable或Externalizable接口的类的对象才能被序列化。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。对象序列化包括如下步骤： 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流； 通过对象输出流的writeObject()方法写对象. 对象反序列化的步骤： 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流 通过对象输入流的readObject()方法读取对象。 代码实现：定义一个POJO类，实现Serializable接口。123456789101112131415161718192021222324252627282930313233343536373839404142434445package day02;import java.io.Serializable;/** * &lt;p&gt;ClassName: Person&lt;p&gt; * &lt;p&gt;Description:测试对象序列化和反序列化&lt;p&gt; * * @author xudp * @version 1.0 V * @createTime 2014-6-9 下午02:33:25 */public class Person implements Serializable &#123; /** * 序列化ID */ private static final long serialVersionUID = -5809782578272943999L; private int age; private String name; private String sex; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public String getSex() &#123; return sex; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; Main方法的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 package day02;import day02.Person;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.text.MessageFormat;/** * &lt;p&gt;ClassName: TestObjSerializeAndDeserialize&lt;p&gt; * &lt;p&gt;Description: 测试对象的序列化和反序列&lt;p&gt; * @author xudp * @version 1.0 V * @createTime 2014-6-9 下午03:17:25 */public class TestObjSerializeAndDeserialize &#123; public static void main(String[] args) throws Exception &#123; SerializePerson();//序列化Person对象 Person p = DeserializePerson();//反序列Perons对象 System.out.println(MessageFormat.format("name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;", p.getName(), p.getAge(), p.getSex())); &#125; /** * MethodName: SerializePerson * Description: 序列化Person对象 * @author xudp * @throws FileNotFoundException * @throws IOException */ private static void SerializePerson() throws FileNotFoundException, IOException &#123; Person person = new Person(); person.setName("gacl"); person.setAge(25); person.setSex("男"); // ObjectOutputStream 对象输出流，将Person对象存储到E盘的Person.txt文件中，完成对Person对象的序列化操作 ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream( new File("D:/Person.txt"))); oo.writeObject(person); System.out.println("Person对象序列化成功！"); oo.close(); &#125; /** * MethodName: DeserializePerson * Description: 反序列Perons对象 * @author xudp * @return * @throws Exception * @throws IOException */ private static Person DeserializePerson() throws Exception, IOException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream( new File("D:/Person.txt"))); Person person = (Person) ois.readObject(); System.out.println("Person对象反序列化成功！"); return person; &#125;&#125; 结果的展示：这个是程序运行的结果，主要是一些字节码的文件。打开看一下，就是这个样子的： 大家会发现什么都看不懂，其实很正常，给计算机看的又不是给我们看的。我们可以看反序列化之后，就成为了一个简单的对象。是不是很酷！ serialVersionUID的作用serialVersionUID表示：“串行化版本统一标识符”（serial version universal identifier），简称UID serialVersionUID必须定义成下面这种形式：static final long serialVersionUID = xxxL; serialVersionUID 用来表明类的不同版本间的兼容性。有两种生成方式： 一个是默认的1L；另一种是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段 。。 如果你添加了serialVersionUID，在反序列旧有实例时，新添加或更改的字段值将设为初始化值（对象为null，基本类型为相应的初始默认值），字段被删除将不设置。 具体的还是代码演示一下具有说服力： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class TestSerialversionUID &#123; public static void main(String[] args) throws Exception &#123; SerializeCustomer();// 序列化Customer对象 Customer customer = DeserializeCustomer();// 反序列Customer对象 System.out.println(customer); &#125; /** * MethodName: SerializeCustomer * Description: 序列化Customer对象 * @author xudp * @throws FileNotFoundException * @throws IOException */ private static void SerializeCustomer() throws FileNotFoundException, IOException &#123; Customer customer = new Customer("gacl",25); // ObjectOutputStream 对象输出流 ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream( new File("E:/Customer.txt"))); oo.writeObject(customer); System.out.println("Customer对象序列化成功！"); oo.close(); &#125; /** * MethodName: DeserializeCustomer * Description: 反序列Customer对象 * @author xudp * @return * @throws Exception * @throws IOException */ private static Customer DeserializeCustomer() throws Exception, IOException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream( new File("E:/Customer.txt"))); Customer customer = (Customer) ois.readObject(); System.out.println("Customer对象反序列化成功！"); return customer; &#125;&#125;/** * &lt;p&gt;ClassName: Customer&lt;p&gt; * &lt;p&gt;Description: Customer实现了Serializable接口，可以被序列化&lt;p&gt; * @author xudp * @version 1.0 V * @createTime 2014-6-9 下午04:20:17 */class Customer implements Serializable &#123; //Customer类中没有定义serialVersionUID private String name; private int age; public Customer(String name, int age) &#123; this.name = name; this.age = age; &#125; /* * @MethodName toString * @Description 重写Object类的toString()方法 * @author xudp * @return string * @see java.lang.Object#toString() */ @Override public String toString() &#123; return "name=" + name + ", age=" + age; &#125;&#125; 对上面的Customer类没有定义serialVersionUID，执行序列化操作是没有问题的，但是如果我们对这个类进行一些修改。比如新添加一个属性： 12345678910111213141516171819202122232425262728293031class Customer implements Serializable &#123; //Customer类中没有定义serialVersionUID private String name; private int age; //新添加的sex属性 private String sex; public Customer(String name, int age) &#123; this.name = name; this.age = age; &#125; public Customer(String name, int age,String sex) &#123; this.name = name; this.age = age; this.sex = sex; &#125; /* * @MethodName toString * @Description 重写Object类的toString()方法 * @author xudp * @return string * @see java.lang.Object#toString() */ @Override public String toString() &#123; return "name=" + name + ", age=" + age; &#125;&#125; 我们新添加一个属性sex，但是现在序列化的同时出现了错误。 Exception in thread “main” java.io.InvalidClassException: Customer; local class incompatible: stream classdesc serialVersionUID = -88175599799432325, local class serialVersionUID = -5182532647273106745 其实出现错误的原因是这样的：就是文件中和classpath中的class，现在不一致了。处于安全的考虑，程序此时就出现了错误。并且拒绝载入。如果想解决这种问题，就去自己指定一个serialVersionUID。只要我们的文件进行了修改，得到的UID就不同，可以保证就算有多个类，我们的UID也一致。显示定义的用途已经在下面写了。希望对大家有一点帮助。 serialVersionUID的取值 serialVersionUID的取值是Java运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。 类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。 显式地定义serialVersionUID有两种用途： 1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID； 2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之IO这个硬骨头（二）]]></title>
    <url>%2F2018%2F08%2F04%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8BIO%E8%BF%99%E4%B8%AA%E7%A1%AC%E9%AA%A8%E5%A4%B4%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ 上一次基本讲解了一下IO中字节流的一些知识点和操作，总的来说字符流的操作和字节流差不多，关键在于编码集的一些问题。这篇文章就主要讲解java中字符流和字符集。 字符集的操作字符集是什么尼？字符集就是是各种文字和符号的总称，简单来说就是由字符和对应的数值组成的一张表。 推荐一篇文章 字符集详解（一看就懂系列） ，这篇文章详细的介绍了字符集的一些知识，以及字符集的演变。 常见的字符集：下面用一个图片来解释一下简单的字符集：这张图介绍了常用的字符集。 java中的CharSet这些知识使我们从网上查到的，我们在代码中如何知道有什么字符集尼？12345678@Test public void test5() &#123; SortedMap&lt;String, Charset&gt; stringCharsetSortedMap = Charset.availableCharsets (); Set&lt;Map.Entry&lt;String, Charset&gt;&gt; entries = stringCharsetSortedMap.entrySet (); for (Map.Entry&lt;String, Charset&gt; entry : entries) &#123; System.out.println (entry.getKey () + "---" \+ entry.getValue ()); &#125; &#125; 通过这样，我们可以查找出所有的字符集。 转码对于大多数程序猿来说，乱码都是经常发生的事情，但是为什么会乱码？其实这个问题很简单，就像上面编码表的那张图片一样，就是因为编码和解码用的码制不一样，大家可以看下面的例子，用GBK进行编码，用GBK解码，就可以解码出数据，但是使用UTF-8进行数据的解码，就出现问题，此时的数据就成了乱码，我们就无法解析了。所以说，只要编码和解码的码制一样，就不会乱码。12345678910111213141516171819202122232425262728293031@Test public void test6() throws CharacterCodingException &#123; Charset gbk = Charset.forName ("GBK"); //获取编码器 CharsetEncoder ce = gbk.newEncoder (); //获取解码器 CharsetDecoder cd = gbk.newDecoder (); CharBuffer allocate = CharBuffer.allocate (1024); allocate.put ("爱生活爱java"); allocate.flip (); //编码 ByteBuffer encode = ce.encode (allocate); for (int i = 0; i &lt; 12; i++) &#123; System.out.println (encode.get ()); &#125; //解码 encode.flip (); CharBuffer decode = cd.decode (encode); System.out.println (decode.toString ()); System.out.println ("------------------------"); encode.flip (); Charset utf = Charset.forName ("UTF-8"); CharBuffer decode1 = utf.decode (encode); System.out.println (decode1.toString ()); &#125; 字符流的基本操作上面介绍了编码的一些知识点，之所以解释这个是因为字符流其实就是编码表加上字节流，下来介绍字符流的操作吧。 转换流转换流是什么尼？其实因为字节流处理中文不是很方便，有时候需要字符流处理文字，所以出现了转换流。转换流的作用就是把一个字节流转换成一个字符流。 转换流其实本质上就是一个字节流加上编码表 InputStreamReader代码展示12345678910111213141516171819202122232425262728293031import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;/* * InputStreamReader(InputStream is):用默认的编码读取数据 * InputStreamReader(InputStream is,String charsetName):用指定的编码读取数据 */public class InputStreamReaderDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建对象 // InputStreamReader isr = new InputStreamReader(new FileInputStream( // "osw.txt")); // InputStreamReader isr = new InputStreamReader(new FileInputStream( // "osw.txt"), "GBK"); InputStreamReader isr = new InputStreamReader(new FileInputStream( "osw.txt"), "UTF-8"); // 读取数据 // 一次读取一个字符 int ch = 0; while ((ch = isr.read()) != -1) &#123; System.out.print((char) ch); &#125; // 释放资源 isr.close(); &#125;&#125; OutputStreamWriter代码展示1234567891011121314151617181920212223242526import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;/* * OutputStreamWriter(OutputStream out):根据默认编码把字节流的数据转换为字符流 * OutputStreamWriter(OutputStream out,String charsetName):根据指定编码把字节流数据转换为字符流 * 把字节流转换为字符流。 * 字符流 = 字节流 +编码表。 */public class OutputStreamWriterDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建对象 // OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream( // "osw.txt")); // 默认GBK // OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream( // "osw.txt"), "GBK"); // 指定GBK OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream( "osw.txt"), "UTF-8"); // 指定UTF-8 // 写数据 osw.write("中国"); // 释放资源 osw.close(); &#125;&#125; 字符流其实我们怎么创建一个字符流尼，其实上面的转换流就可以帮我们完成这个需求。但是，每次创建字符流都要先创建一个字节流，感觉很麻烦，所以就有这个流的出现—&gt;FileWriter/FileReaderd，接下来介绍一下具体的代码实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;/* * 由于我们常见的操作都是使用本地默认编码，所以，不用指定编码。 * 而转换流的名称有点长，所以，Java就提供了其子类供我们使用。 * OutputStreamWriter = FileOutputStream + 编码表(GBK) * FileWriter = FileOutputStream + 编码表(GBK) * * InputStreamReader = FileInputStream + 编码表(GBK) * FileReader = FileInputStream + 编码表(GBK) * /* * 需求：把当前项目目录下的a.txt内容复制到当前项目目录下的b.txt中 * * 数据源： * a.txt -- 读取数据 -- 字符转换流 -- InputStreamReader -- FileReader * 目的地： * b.txt -- 写出数据 -- 字符转换流 -- OutputStreamWriter -- FileWriter */public class CopyFileDemo2 &#123; public static void main(String[] args) throws IOException &#123; // 封装数据源 FileReader fr = new FileReader("a.txt"); // 封装目的地 FileWriter fw = new FileWriter("b.txt"); // 一次一个字符 // int ch = 0; // while ((ch = fr.read()) != -1) &#123; // fw.write(ch); // &#125; // 一次一个字符数组 char[] chs = new char[1024]; int len = 0; while ((len = fr.read(chs)) != -1) &#123; fw.write(chs, 0, len); fw.flush(); &#125; // 释放资源 fw.close(); fr.close(); &#125;&#125; 上面就是一个简单的字符流的使用方法，实现了一个文件复制的功能。我们在学习字节流的时候，就有缓冲流（BufferInputStream/BufferOutputStream）来实现数据的高速缓冲传送,其实在字符流中也有这个方法。比如（BufferedReader/BufferedWriter），下面就举一个小例子来 看一下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;/* * 字符缓冲流的特殊方法： * BufferedWriter: * public void newLine():根据系统来决定换行符 * BufferedReader: * public String readLine()：一次读取一行数据 * 包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null */public class BufferedDemo &#123; public static void main(String[] args) throws IOException &#123; // write(); read(); &#125; private static void read() throws IOException &#123; // 创建字符缓冲输入流对象 BufferedReader br = new BufferedReader(new FileReader("bw2.txt")); // public String readLine()：一次读取一行数据 // String line = br.readLine(); // System.out.println(line); // line = br.readLine(); // System.out.println(line); // 最终版代码 String line = null; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; //释放资源 br.close(); &#125; private static void write() throws IOException &#123; // 创建字符缓冲输出流对象 BufferedWriter bw = new BufferedWriter(new FileWriter("bw2.txt")); for (int x = 0; x &lt; 10; x++) &#123; bw.write("hello" + x); // bw.write("\r\n"); bw.newLine(); bw.flush(); &#125; bw.close(); &#125;&#125; 缓冲流的具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * BufferedReader * 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 * 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。 * * BufferedReader(Reader in) */public class BufferedReaderDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建字符缓冲输入流对象 BufferedReader br = new BufferedReader(new FileReader("bw.txt")); // 方式1 // int ch = 0; // while ((ch = br.read()) != -1) &#123; // System.out.print((char) ch); // &#125; // 方式2 char[] chs = new char[1024]; int len = 0; while ((len = br.read(chs)) != -1) &#123; System.out.print(new String(chs, 0, len)); &#125; // 释放资源 br.close(); &#125;&#125;--------------------------------------------------/* * 字符流为了高效读写，也提供了对应的字符缓冲流。 * BufferedWriter:字符缓冲输出流 * BufferedReader:字符缓冲输入流 * * BufferedWriter:字符缓冲输出流 * 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 * 可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。 */public class BufferedWriterDemo &#123; public static void main(String[] args) throws IOException &#123; // BufferedWriter(Writer out) // BufferedWriter bw = new BufferedWriter(new OutputStreamWriter( // new FileOutputStream("bw.txt"))); BufferedWriter bw = new BufferedWriter(new FileWriter("bw.txt")); bw.write("hello"); bw.write("world"); bw.write("java"); bw.flush(); bw.close(); &#125;&#125; IO的常用的流总结其实IO简单的字节流和字符流并不难学，总的来说就是太复杂，其实实际操作不是很困难 。现在来总结一下，我们学过的流。 IO流 |--字节流 |--字节输入流 InputStream int read():一次读取一个字节 int read(byte[] bys):一次读取一个字节数组 |--FileInputStream |--BufferedInputStream |--字节输出流 OutputStream void write(int by):一次写一个字节 void write(byte[] bys,int index,int len):一次写一个字节数组的一部分 |--FileOutputStream |--BufferedOutputStream |--字符流 |--字符输入流 Reader int read():一次读取一个字符 int read(char[] chs):一次读取一个字符数组 |--InputStreamReader |--FileReader |--BufferedReader String readLine():一次读取一个字符串 |--字符输出流 Writer void write(int ch):一次写一个字符 void write(char[] chs,int index,int len):一次写一个字符数组的一部分 |--OutputStreamWriter |--FileWriter |--BufferedWriter void newLine():写一个换行符 void write(String line):一次写一个字符串 在插入一个图片有助于理解和帮助。 从图中我们就可以看到清晰的一个思路，各种流及其常用的实现类，在上面都有。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之IO这个硬骨头（一）]]></title>
    <url>%2F2018%2F08%2F01%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8BIO%E8%BF%99%E4%B8%AA%E7%A1%AC%E9%AA%A8%E5%A4%B4%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ IO的概述首先，我们要了解一下什么是IO，首先IO就是计算机中指Input/Output,也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。流的概念：Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。 IO如何学习？IO重点的类IO的学习我认为最主要的就是五个类和一个接口，把这些学好，基本就没什么问题：File、OutputStream、InputStream、Writer、Reader和接口Serializable。 类 说明 File 文件类 OutputStream 字节输出流 InputStream 字节输入流 Writer 字符输流 Reader 字符输入流 File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。 InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。 OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。 Reader（文件格式操作）：抽象类，基于字符的输入操作。 Writer（文件格式操作）：抽象类，基于字符的输出操作。 上面是对这几个类的简单概述基本就是这几个较为重点，当然还有扩展的FileInputStream等等，但是我认为最基础的还是这几个。 IO的分类从上面我们学习了流的概念；一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。下图是一个描述输入流和输出流的类层次图。 从图中我们可以看到简单的分类是字符流与字节流，接下来我在解释一下：先来说一下输入、输出流： 输入流：程序从输入流读取数据源。数据源包括外界(键盘、文件、网络…)，即是将数据源读入到程序的通信通道 输出流程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络…）的通信通道。 采用数据流的目的就是使得输出输入独立于设备。 输入流( Input Stream )不关心数据源来自何种设备（键盘，文件，网络）。 输出流( Output Stream )不关心数据的目的是何种设备（键盘，文件，网络）。 流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种： 1) 字节流：数据流中最小的数据单元是字节2) 字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。 字符流的由来： Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。所以说：字符流=字节流+编码表。这个编码表我们后来再进行讲解。 注意：a.如果没有明确说按照什么区分，默认按照数据类型进行分。b.除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。 InputStream/OutputStream的代码实现 通过上面的分析后我们知道要使用：OutputStream 但是通过查看API，我们发现该流对象是一个抽象类，不能实例化。 所以，我们要找一个具体的子类。 而我们要找的子类是什么名字的呢?这个时候，很简单，我们回想一下，我们是不是要往文件中写东西。 文件是哪个单词——&gt;File 然后用的是字节输出流，联起来就是：FileOutputStream注意：每种基类的子类都是以父类名作为后缀名。 XxxOutputStream XxxInputStream XxxReader XxxWriter 所以我们从FileInputStream和FileOutputStream来演示对字节流的操作。 FileOutputStream读取数据操作步骤 创建字节输入流对象 调用read()方法 释放资源代码实现 123456789101112131415 // 创建字节输出流对象 FileOutputStream fos = new FileOutputStream("fos.txt");/* * 创建字节输出流对象了做了几件事情： * A:调用系统功能去创建文件 * B:创建fos对象 * C:把fos对象指向这个文件 *///写数据fos.write("hello,IO".getBytes());fos.write("java".getBytes());//释放资源//关闭此文件输出流并释放与此流有关的所有系统资源。fos.close(); 注意的问题1. 创建字节输出流对象做了几件事情? FileOutputStream(File file) File file = new File(&quot;fos.txt&quot;); FileOutputStream fos = new FileOutputStream(file); FileOutputStream(String name) 其实先根据文件名称，使用File把这个文件创建出来，然后再把这个文件传入FileOutputStream(file);2. 为什么要关闭资源？释放资源的目的是要让流对象变成垃圾，这样就可以被垃圾回收器回收了，其次是通知系统去释放跟该文件相关的资源3. 如何实现数据换行？为什么现在没有换行呢?因为你值写了字节数据，并没有写入换行符号。如何实现呢?写入换行符号即可呗。刚才我们看到了有写文本文件打开是可以的，通过windows自带的那个不行，为什么呢?因为不同的系统针对不同的换行符号识别是不一样的? windows:\r\nlinux:\nMac:\r 而一些常见的个高级记事本，是可以识别任意换行符号的。为了使得同一个java程序的换行符在所有的操作系统中都有一样的表现，使用 %n，就可以做到平台无关的换行。 4. 如何实现数据的追加写入？ 用构造方法带第二个参数是true的情况即可12// 创建一个向具有指定 name 的文件中写入数据的输出文件流。如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处。 FileOutputStream fos = new FileOutputStream("fos3.txt", true); 这样创建就可以实现数据的追加。 FileInputStream读取数据操作步骤 创建字节输入流对象 调用read()方法 释放资源 代码体现：12345678910111213141516171819 //创建FileInputStreamFileInputStream fis = new FileInputStream("fos.txt"); //read（）方法读取数据//方式1int by = 0;while((by=fis.read())!=-1) &#123; System.out.print((char)by);&#125; //方式2byte[] bys = new byte[1024];int len = 0;while((len=fis.read(bys))!=-1) &#123; System.out.print(new String(bys,0,len));&#125;//关闭资源fis.close(); 案例分析复制文本文件12345678910111213141516171819202122232425262728293031323334353637import java.io.FileOutputStream;import java.io.IOException;/* * 复制文本文件。 * * 数据源：从哪里来 * a.txt -- 读取数据 -- FileInputStream * * 目的地：到哪里去 * b.txt -- 写数据 -- FileOutputStream * * java.io.FileNotFoundException: a.txt (系统找不到指定的文件。) * * 这一次复制中文没有出现任何问题，为什么呢? * 上一次我们出现问题的原因在于我们每次获取到一个字节数据，就把该字节数据转换为了字符数据，然后输出到控制台。 * 而这一次呢?确实通过IO流读取数据，写到文本文件，你读取一个字节，我就写入一个字节，你没有做任何的转换。 * 它会自己做转换。 */public class CopyFileDemo &#123; public static void main(String[] args) throws IOException &#123; // 封装数据源 FileInputStream fis = new FileInputStream("a.txt"); // 封装目的地 FileOutputStream fos = new FileOutputStream("b.txt"); byte[] bys = new byte[1024]; int len = 0; while ((len = fis.read(bys)) != -1) &#123; fos.write(bys, 0, len); &#125; // 释放资源(建议先关后创建的) fos.close(); fis.close(); &#125;&#125; 复制图片123456789101112131415161718192021222324252627282930313233package cn.itcast_03;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 需求：把e:\\林青霞.jpg内容复制到当前项目目录下的mn.jpg中 * * 数据源： * e:\\林青霞.jpg --读取数据--FileInputStream * 目的地： * mn.jpg--写出数据--FileOutputStream */public class CopyImageDemo &#123; public static void main(String[] args) throws IOException &#123; // 封装数据源 FileInputStream fis = new FileInputStream("e:\\林青霞.jpg"); // 封装目的地 FileOutputStream fos = new FileOutputStream("mn.jpg"); // 复制数据 byte[] bys = new byte[1024]; int len = 0; while ((len = fis.read(bys)) != -1) &#123; fos.write(bys, 0, len); &#125; // 释放资源 fos.close(); fis.close(); &#125;&#125; 思考问题：计算机如何识别中文123456789101112131415161718/* * 计算机是如何识别什么时候该把两个字节转换为一个中文呢? * 在计算机中中文的存储分两个字节： * 第一个字节肯定是负数。 * 第二个字节常见的是负数，可能有正数。但是没影响。 */public class StringDemo &#123; public static void main(String[] args) &#123; // String s = "abcde"; // // [97, 98, 99, 100, 101] String s = "我爱你中国"; // [-50, -46, -80, -82, -60, -29, -42, -48, -71, -6] byte[] bys = s.getBytes(); System.out.println(Arrays.toString(bys)); &#125;&#125; 字符缓冲区流BufferedOutputStream（字符缓冲输出流）/BufferedInputStream（字符缓冲输入流）构造方法为1234//创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。创建一个内部缓冲区数组并将其存储在 buf 中,该buf的大小默认为8192。 public BufferedInputStream(InputStream in); //创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。创建一个长度为 size 的内部缓冲区数组并将其存储在 buf 中。 public BufferedInputStream(InputStream in,int size); BufferedOutputStream的思想进行简单说明：BufferedOutputStream通过字节数组来缓冲数据，当缓冲区满或者用户调用flush()函数时，它就会将缓冲区的数据写入到输出流中。话不多说，上代码——–&gt; 文件复制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package cn.itcast_06;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 需求：把e:\\哥有老婆.mp4复制到当前项目目录下的copy.mp4中 * * 字节流四种方式复制文件： * 基本字节流一次读写一个字节： 共耗时：117235毫秒 * 基本字节流一次读写一个字节数组： 共耗时：156毫秒 * 高效字节流一次读写一个字节： 共耗时：1141毫秒 * 高效字节流一次读写一个字节数组： 共耗时：47毫秒 */public class CopyMp4Demo &#123; public static void main(String[] args) throws IOException &#123; long start = System.currentTimeMillis(); // method1("e:\\哥有老婆.mp4", "copy1.mp4"); // method2("e:\\哥有老婆.mp4", "copy2.mp4"); // method3("e:\\哥有老婆.mp4", "copy3.mp4"); method4("e:\\哥有老婆.mp4", "copy4.mp4"); long end = System.currentTimeMillis(); System.out.println("共耗时：" + (end - start) + "毫秒"); &#125; // 高效字节流一次读写一个字节数组： public static void method4(String srcString, String destString) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream( srcString)); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(destString)); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); &#125; bos.close(); bis.close(); &#125; // 高效字节流一次读写一个字节： public static void method3(String srcString, String destString) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream( srcString)); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(destString)); int by = 0; while ((by = bis.read()) != -1) &#123; bos.write(by); &#125; bos.close(); bis.close(); &#125; // 基本字节流一次读写一个字节数组 public static void method2(String srcString, String destString) throws IOException &#123; FileInputStream fis = new FileInputStream(srcString); FileOutputStream fos = new FileOutputStream(destString); byte[] bys = new byte[1024]; int len = 0; while ((len = fis.read(bys)) != -1) &#123; fos.write(bys, 0, len); &#125; fos.close(); fis.close(); &#125; // 基本字节流一次读写一个字节 public static void method1(String srcString, String destString) throws IOException &#123; FileInputStream fis = new FileInputStream(srcString); FileOutputStream fos = new FileOutputStream(destString); int by = 0; while ((by = fis.read()) != -1) &#123; fos.write(by); &#125; fos.close(); fis.close(); &#125;&#125; 我们可以看出，经过BufferedxxxputStream修饰的字节流，速度快了很多，其实这也是一种设计模式的体现，装饰者设计模式。今天就到这里，明天再来讲解字符流和其他流的知识。谢谢！！！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础之异常]]></title>
    <url>%2F2018%2F07%2F31%2Fjava%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！ 本来今天是准备写一点IO的东西，但是想了一下，想之前先说一下File类，但是File的时候还会出现很多错误，所以先写一篇异常的文章。就从异常开始说吧！ 异常的概述异常：异常就是Java程序在运行过程中出现的错误。异常由来：问题也是现实生活中一个具体事务，也可以通过java 的类的形式进行描述，并封装成对象。其实就是Java对不正常情况进行描述后的对象体现。 异常的体系下面是异常的大概分类： 我们可以看到Throwable类是 Java 语言中所有错误或异常的超类。下面具体有两个异常类：Error、Exception。 Error：用于指示合理的应用程序不应该试图捕获的严重问题。（不需要我们处理） Exception：合理的应用程序想要获取的条件。 |---RuntimeException 运行期异常，我们需要修正代码 |---非RuntimeException 编译期异常，必须处理的，否则程序编译不通过 RuntimeException有以下一些例子： NullPointerException - 空指针引用异常 ClassCastException - 类型强制转换异常。 IllegalArgumentException - 传递非法参数异常。 ArithmeticException - 算术运算异常 IndexOutOfBoundsException - 下标越界异常 NumberFormatException - 数字格式异常 UnsupportedOperationException - 不支持的操作异常 异常的处理 JVM默认的处理 把异常的名称，原因，位置打印在控制台，但是不处理，程序停止，不在执行。 自己处理1. try...catch...finally 自己编写处理代码,后面的程序可以继续执行 2.throws 把自己处理不了的，在方法上声明，告诉调用者，这里有问题。 finally关键字 finally用于释放资源（JDBC、流操作），它的代码永远会执行。特殊情况：在执行到finally之前jvm退出。下面的打印是不会执行的，因为JVM已经退出了。 123456try &#123; // do something Syst... System.exit(1); &#125;finally&#123; System.out.println("Hello,World!"); &#125; 异常处理的变形 try...catch...finally try...catch... try...catch...catch... try...catch...catch...fianlly try...finally 自定义异常继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可。这个不是考察的重点，不做多的赘述。 异常的注意事项 父类方法有异常抛出，子类方法的重写方法在抛出异常时必须小于等于父类的异常。 父类的方法没有异常抛出，子类的重写方法不能有异常抛出。 父类的方法抛出多个异常，子类的重写方法必须必父类少或者小。 异常的面试题编译期异常和运行期异常的区别?答：编译期异常，必须要处理的，否则无法通过编译，程序不能运行。 运行期异常不一定会发生，不一定处理，也可以处理，比如空指针异常，这就不一定会发生。 throw和throws是的区别？答：throw： 在方法体中,后面跟的是异常对象名,并且只能是一个 throw抛出的是一个异常对象，说明这里肯定有一个异常产生了. throws： 在方法声明上,后面跟的是异常的类名,可以是多个throws是声明方法有异常，是一种可能性，这个异常并不一定会产生. final,finally,finalize的区别?这个问题我之前做过深入的解析，可以查看我的博文 final、finally、finalize的区别 如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后答：会，前。finally和return123456789101112131415161718public static void main(String\[\] args) &#123; System.out.println(getInt()); &#125; public static int getInt() &#123; int a = 10; try &#123; System.out.println(a / 0); a = 20; &#125; catch (ArithmeticException e) &#123; a = 30; return a; &#125; finally &#123; System.out.println ("hello"); //return a; &#125; return a; &#125; 程序运行结果 hello 30 try-with-resources这个是JDK1.7新加入的一个异常的新特性。try-with-resources语句是一个声明一个或多个资源的try语句。一个资源作为一个对象，必须在程序结束之后关闭。try-with-resources语句确保在语句的最后每个资源都被关闭，任何实现了java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resource来实现异常处理和关闭资源。具体使用见下：123try (BufferedReader br = new BufferedReader(new FileReader(path))) &#123; return br.readLine(); &#125; 把需要关闭的对象写在括号中，其中要关闭的对象必须实现java.lang.AutoCloseable和java.io.Closeable。 finally和return这些事在finally中return数值？在finally中return数值，最后的返回值是finally中的值。可以参考代码：12345678910111213141516171819public class Demo1 &#123; public static void main(String\[\] args) &#123; System.out.println(getInt()); &#125; public static int getInt() &#123; int a = 10; try &#123; System.out.println(a / 0); a = 20; &#125; catch (ArithmeticException e) &#123; a = 30; return a; &#125; finally &#123; a=40; return a; &#125; &#125; &#125; 最后的运行结果是40,并且其中有提示说： 不能在finally块中使用return，finally块中的return返回后方法结束执行，不会再执行try块中的return语句。 Negative example: public static Long readFileLength(String fileName) { try { File file = new File(fileName); RandomAccessFile randomAccessFile = new RandomAccessFile(file, &quot;r&quot;); return randomAccessFile.length(); } catch (Exception e) { logger.error(e.getMessage(), e); } finally { countDownLatch.countDown(); return 0L; } } catch捕获异常时，finally改变返回值我们可以从上面看出来，当finally块中有return语句时，将会覆盖函数中其他的return语句。 此外，由于一个方法内部定义的变量都存储子在栈中，当这个函数结束后，其对应的栈就被回收，此时方法中的变量就不存在了。因此return在返回时不是直接返回变量的值，而是复制一份，然后返回。因此，对于基本数据类型的数据，在finally块中改变return的值，不会有影响，对于引用数据类型会有影响。 可以参考下面代码理解1234567891011121314151617181920212223242526272829303132333435363738package Exception; /** \* Exception * \* @author jh \* @date 2018/7/31 20:26 \* description: */public class Demo1 &#123; public static int testFinally1()&#123; int result=1; try &#123; result=2; return result; &#125; catch (Exception e) &#123; return 0; &#125; finally &#123; result=3; System.out.println ("testFinally1"); &#125; &#125; public static StringBuffer testFinally2()&#123; StringBuffer s=new StringBuffer ("hello"); try &#123; return s; &#125; catch (Exception e) &#123; return null; &#125; finally &#123; s.append ("world"); System.out.println ("testFinally2"); &#125; &#125; public static void main(String\[\] args) &#123; int i = testFinally1 (); System.out.println (i); StringBuffer finally2 = testFinally2 (); System.out.println (finally2); &#125; &#125; 从上面的代码我们可以看出程序在执行return时会首先将返回值存储在一个指定的位置，其次去执行finally块，最后再返回。在方法testFinally1中调用return前，先把return的值存储在一个指定的位置，然后再去执行finally块中的代码，此时修改result的值不会影响程序的返回结果。testFinally2中，在调用return之前把s保存在一个指定的位置，但是因为s为引用类型，因此在finally块中修改s的值会发生变化。会影响程序的返回结果。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解java虚拟机（一）]]></title>
    <url>%2F2018%2F07%2F28%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ 今天主要学习了《深入理解java虚拟机》的前两章节，第一章主要讲解了java语法的一些特性，及java发展的历史，还有java虚拟机的一些知识。第二章主要讲了java内存区域与内存溢出异常。主要的内容我都总结了思维导图，如果需要导图，可以从百度云下载java虚拟机导图 ，密码是0n73 好了，废话不说，直接上图。有不正确的地方，欢迎大家指正。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阶段性总结]]></title>
    <url>%2F2018%2F07%2F24%2F%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ 实训总结今天是实训结束，实训期间主要还是自己状态不是很好，主要学习了Mybatis和Spring MVC的一些东西。其次实训单位让做一个简单的项目。我们小组做了一个简单的易买网项目.具体项目我已经上传到服务器，大家可以去访问。链接放在这里：易买网。时间短，任务比较重，所以就大概这个样子啦，其中还有很多缺陷，还要继续完善，希望大家指正。 学习计划现在在学校东门租了房子，准备利用这个时间，好好的去复习一下之前的知识，并且去加深印象。去备战9月的秋招。大概学习计划如下： java基础 反射的总结、集合的总结、IO的总结、NIO的总结。（博客） 对于基础部分，还有笔试题的任务，每天规定做20-30道牛客的题目。编程题1道。（习题） 每日的博客（主要是面试题） 其次，还有对高并发的学习。java8的了解，java9暂时不考虑。 还有对java虚拟机的学习。 对之前几本武林秘籍的复习。 框架和web开发 学习《web开发指南》了解web开发的基本业务逻辑。 首先前段时间学习了Mybatis和Spring MVC,但是基础不牢靠，需要总结。（博客） 学习SSM的整合项目，并且根据尚硅谷的视频搭载一个简单的项目。 复习Spring的开发，复习方法有：1.学习spring的注解开发（视频）2.阅读spring实战（书籍）数据库 复习数据库的知识，简单的操作，并且还有高级的开发（索引的一些东西） 学习NoSQL数据库（Redis），主要以视频为主，书籍为辅导资料。 练习简单的sql语句练习题（牛客网） 数据结构 熟悉简单的排序方法，了解基本思想，每周写一遍。 练习编程题，每日一道。 学习java视频（主要是简单的算法和letcood的视频） 结尾以上是我对假期的一些安排和期望，希望我能在接下来的一个月中，砥砺前行，不忘初心。加油！！！ 我对我的寄语： 加油，相信自己。想要改变世界，先改变自己。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>自我总结</tag>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念一次json解析错误！！！]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%BA%AA%E5%BF%B5%E4%B8%80%E6%AC%A1json%E8%A7%A3%E6%9E%90%E9%94%99%E8%AF%AF%EF%BC%81%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ 今天做了一个简单的ssm项目，在用spring mvc解析json数据时，网页一直返回数据显示406错误。对于这个错误，头疼了一天。首先介绍一下我的小项目。 项目代码与思路首先先创建一个jsp页面，json数据的传输有两种： 一、请求json，输出是json 二、请求key/value，输出是json 接下来首先分析一下请求json返回也是json的形式（第二种不做简述，照猫画虎，思想一致，只提供代码）使用jquery的ajax提交json串，对输出的json结果进行解析。12345678910111213141516171819&lt;script type=&quot;text/javascript&quot;&gt; //请求json，输出是json function requestJson() &#123; alert(&quot;requestJson&quot;); $.ajax(&#123; type: &apos;post&apos;, url: &apos;$&#123;pageContext.request.contextPath &#125;/requestJson&apos;, contentType: &apos;application/json;charset=utf-8&apos;, //数据格式是json串,商品信息 data: &apos;&#123;&quot;name&quot;:&quot;手机&quot;,&quot;price&quot;:999&#125;&apos;, success: function (data) &#123;//返回json结果 alert(data); &#125; &#125;); &#125; &lt;/script&gt; &lt;input type=&quot;button&quot; onclick=&quot;requestJson()&quot; value=&quot;请求json，输出是json&quot;/&gt; 然后在controller中写一个JsonTest类存储方法。123456789101112131415161718192021package com.how2java.controller;import com.how2java.pojo.ItemsCustom;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class JsonTest &#123; //请求json串(商品信息)，输出json(商品信息) //@RequestBody将请求的商品信息的json串转成itemsCustom对象 //@ResponseBody将itemsCustom转成json输出 @RequestMapping("/requestJson") public @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom)&#123; //@ResponseBody将itemsCustom转成json输出 return itemsCustom; &#125;&#125; 这个代码的意思就是从jsp发送到controller中，然后其中的@RequestBody标明传输json数据，最后在返回数据到页面上。 错误问题在写完上述代码之后，出现了网页无法解析json数据的状况，检查头文件发现后端传数据过来到前端了，但是显示406错误。总共出现了两个问题： 问题一：jar问题导入的jar包不正确，之前一直使用的是1.9.2版本的下面三个jar包，在网上查询了之后发现，spring3.* 支持1.9.2 ,在spring4.0之后已经不支持了，所以把jar全部更新到2.4.1的jar包。我使用的是maven工程，具体的依赖可以看下12345678910111213141516171819 &lt;!--jackson--&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt;&lt;/dependency&gt; 问题二：spring MVC.xml配置文件出现问题在需要解析json1的时候需要在spring MVC.xml添加如下配置：12345678910111213141516171819&lt;!-- 避免IE执行AJAX时,返回JSON出现下载文件 --&gt; &lt;bean id="mappingJacksonHttpMessageConverter" class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动Spring MVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;ref bean="mappingJacksonHttpMessageConverter" /&gt;&lt;!-- json转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 但是加入之后依然报错，显示无法加载org.springframework.http.converter.json.MappingJacksonHttpMessageConverter 网上查询之后发现，在导入jackson2.0版本以上的时候，其中的配置文件已经更换了更换为 org.springframework.http.converter.json.MappingJackson2HttpMessageConverter 配置完成之后，重新启动项目，发现项目没有问题了，成功运行。这次再配置的过程中浪费太多时间，为了避免下次还是出现此类问题，故此写了这篇文章，以便以后查阅和修改代码。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>java项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java提供了那些IO方式？NIO如何实现多路复用？]]></title>
    <url>%2F2018%2F07%2F21%2Fjava%E6%8F%90%E4%BE%9B%E4%BA%86%E9%82%A3%E4%BA%9BIO%E6%96%B9%E5%BC%8F%EF%BC%9FNIO%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ 概述Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。 首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。 java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。 很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。 第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。 第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。 考点分析上面所列出的回答是一种常见的分类方式，即所谓的BIO、NIO、AIO。 主要考察的点有： 基础的API设计与功能InputStream/OutputStream和Reader/Writer的区别和使用。 NIO、NIO2的基本组成。 不同场景下，分析BIO和NIO的设计和实现原理。 NIO提供高性能的原理 NIO还存在那些问题？改进的想法？ 知识扩展基本概念 区分同步或异步（synchronous/asynchronous） 所谓同步是指一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成，这是一个可靠的任务序列。要成功都成功，要失败都失败，两个任务的状态可以保持一致。异步不需要等待依赖的任务完成。只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了，至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。 区分阻塞与非阻塞（blocking/non-blocking） 在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。 对于IO，做一下总结： IO不仅仅是对文件的操作，在网络编程中，比如socket通信，都是典型的IO操作目标。 输入流、输出流（InputStream/OutputStream）适用于读取或者写入字节，例如图片操作文件。 Reader/Writer则是用于操作字符的，增加字符编解码的功能，适用于从文件中读取或者写入文本信息2，本质上计算机操作的都是字节，不管是从网络通信还是文件读取，Reader/Writer相当于构建了应用逻辑与原始数据之间的桥梁。 BufferedOutputStream等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。 参考下面这张类图，很多 IO工具类都实现了 Closeable接口，因为需要进行资源的释放。比如，打开 FileInputStream，它就会获取相应的文件描述符（ FileDescriptor），需要利用 try- with- resources、 try- finally等机制保证 FileInputStream被明确关闭，进而相应文件描述符也会失效，否则将导致资源无法被释放。利用专栏前面的内容提到的 Cleaner或 finalize机制作为资源释放的最后把关，也是必要的。 NIO的概览 首先了解一下NIO的基本组成部分： Chnnel 由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。File 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过 Socket 获取 Channel，反之亦然。 Buffer 一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的 Selector 是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在 Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理。Selector 同样是基于底层操作系统机制，不同模式、不同版本都存在区别，例如，在最新的代码库里，相关实现如下：在Linux中依赖于epoll在Windows中依赖于iocp模型 Chartset 提供 Unicode 字符串定义，NIO 也提供了相应的编解码器等，例如，通过下面的方式进行字符串到 ByteBuffer 的转换： 1CharSet.defaultCharSet().encode("Hello,World") NIO的具体作用 未完待续…]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对比HashMap、HashTable、TreeMap之间的区别]]></title>
    <url>%2F2018%2F07%2F18%2F%E5%AF%B9%E6%AF%94HashMap%E3%80%81HashTable%E3%80%81TreeMap%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。 Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。 HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。 TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。 考点分析我感觉这三个Map中最重要的肯定是HashMap，首先看一下我之前的文章了解一下：HashMap的源码解析，我认为学习集合框架，首先要了解基本的操作用法，这个应该去读API。其次，应当去学习源码，去了解怎么实现的具体代码。 对于三者的区别，我主要从三方面来说： 1.语法上面的区别：1）HashMap允许键值为空，Hashtable不允许。 2）HashMap包含了containsvalue和containsKey，不包含有contains。 2.安全方面的区别HashTable支持线程安全的，而HashMap不支持线程同步，是非线程安全的。因此，HashMap相对来说效率可能会高于Hashtable。 3.源码级别的区别Hashtable，hash数组默认的大小是11，增加的方式是old*2+1,而HashMap中，hash数组的默认大小是16，而且一定是2的指数。 相较于HashMap和HashTable，TreeMap是利用红黑树来实现的，实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap来进行。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程（二）]]></title>
    <url>%2F2018%2F07%2F17%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ 这是多线程的第二篇文章，主要介绍一写java多线程的简单锁机制和死锁、线程池等一些概念，多线程的高级部分过一段时间加上。 (1)JDK5以后的针对线程的锁定操作和释放操作之前的同步方法，我们学习了简单的synchronized同步代码块，还有用synchronized修饰方法，形成同步方法。还有静态同步方法。现在我们要了解简单的锁机制。Lock锁是JDK5之后加入的，为了更清晰的表达如何加锁和释放锁。具体的使用方法参考下面代码： 123456789101112131415161718192021222324252627282930313233343536package cn.itcast_01;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class SellTicket implements Runnable &#123; // 定义票 private int tickets = 100; // 定义锁对象 private Lock lock = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; try &#123; // 加锁 lock.lock(); if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在出售第" + (tickets--) + "张票"); &#125; &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; &#125;&#125; 具体的Main方法1234567891011121314151617181920212223242526package cn.itcast_01;/* * 虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁， * 为了更清晰的表达如何加锁和释放锁,JDK5以后提供了一个新的锁对象Lock。 * * Lock： * void lock()： 获取锁。 * void unlock():释放锁。 * ReentrantLock是Lock的实现类. */public class SellTicketDemo &#123; public static void main(String[] args) &#123; // 创建资源对象 SellTicket st = new SellTicket(); // 创建三个窗口 Thread t1 = new Thread(st, "窗口1"); Thread t2 = new Thread(st, "窗口2"); Thread t3 = new Thread(st, "窗口3"); // 启动线程 t1.start(); t2.start(); t3.start(); &#125;&#125; Lock的主要方法还是Lock &nbsp;&nbsp;&nbsp;&nbsp; void lock() &nbsp;&nbsp;&nbsp;&nbsp; void unlock() &nbsp;&nbsp;&nbsp;&nbsp; ReentrantLock 死锁问题的描述和代码体现死锁问题是java中一个比较重要的问题。一般面试经常会问，这个需要牢记。 什么是死锁 我们先看看这样一个生活中的例子：在一条河上有一座桥，桥面较窄，只能容纳一辆汽车通过，无法让两辆汽车并行。如果有两辆汽车A和B分别由桥的两端驶上该桥，则对于A车来说，它走过桥面左面的一段路（即占有了桥的一部分资源），要想过桥还须等待B车让出右边的桥面，此时A车不能前进；对于B车来说，它走过桥面右边的一段路（即占有了桥的一部分资源），要想过桥还须等待A车让出左边的桥面，此时B车也不能前进。两边的车都不倒车，结果造成互相等待对方让出桥面，但是谁也不让路，就会无休止地等下去。这种现象就是死锁。如果把汽车比做进程，桥面作为资源，那麽上述问题就描述为：进程A占有资源R1，等待进程B占有的资源Rr；进程B占有资源Rr，等待进程A占有的资源R1。而且资源R1和Rr只允许一个进程占用，即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。 死锁的原因主要有以下四个必要条件。总的来说死锁的原因还是资源的相互占有，无法释放。 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，⋯⋯，Pn正在等待已被P0占用的资源。即肯定存在相互等待的死循环。 死锁的代码DieLock的实现（zhonmgdi）1234567891011121314151617181920212223242526272829package cn.itcast_02;public class DieLock extends Thread &#123; private boolean flag; public DieLock(boolean flag) &#123; this.flag = flag; &#125; @Override public void run() &#123; if (flag) &#123; synchronized (MyLock.objA) &#123; System.out.println("if objA"); synchronized (MyLock.objB) &#123; System.out.println("if objB"); &#125; &#125; &#125; else &#123; synchronized (MyLock.objB) &#123; System.out.println("else objB"); synchronized (MyLock.objA) &#123; System.out.println("else objA"); &#125; &#125; &#125; &#125;&#125; MyLock—-&gt;创建锁对象1234567package cn.itcast_02;public class MyLock &#123; // 创建两把锁对象 public static final Object objA = new Object(); public static final Object objB = new Object();&#125; Demo类，开启线程12345678910111213141516171819202122232425262728package cn.itcast_02;/* * 同步的弊端： * A:效率低 * B:容易产生死锁 * * 死锁： * 两个或两个以上的线程在争夺资源的过程中，发生的一种相互等待的现象。 * * 举例： * 中国人，美国人吃饭案例。 * 正常情况： * 中国人:筷子两支 * 美国人:刀和叉 * 现在： * 中国人：筷子1支，刀一把 * 美国人：筷子1支，叉一把 */public class DieLockDemo &#123; public static void main(String[] args) &#123; DieLock dl1 = new DieLock(true); DieLock dl2 = new DieLock(false); dl1.start(); dl2.start(); &#125;&#125; 生产者和消费者多线程体现(线程间通信问题)具体的生产者消费者的模式如下图：以学生作为资源来实现的 资源类：Student 设置数据类：SetThread(生产者) 获取数据类：GetThread(消费者) 测试类：StudentDemo 上图就是对生产者消费者的解释。具体的代码实现：Student1234567package cn.itcast_05;public class Student &#123; String name; int age; boolean flag; // 默认情况是没有数据，如果是true，说明有数据&#125; SetThread 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast_05;public class SetThread implements Runnable &#123; private Student s; private int x = 0; public SetThread(Student s) &#123; this.s = s; &#125; @Override public void run() &#123; while (true) &#123; synchronized (s) &#123; //判断有没有 if(s.flag)&#123; try &#123; s.wait(); //t1等着，释放锁 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (x % 2 == 0) &#123; s.name = "林青霞"; s.age = 27; &#125; else &#123; s.name = "刘意"; s.age = 30; &#125; x++; //x=1 //修改标记 s.flag = true; //唤醒线程 s.notify(); //唤醒t2,唤醒并不表示你立马可以执行，必须还得抢CPU的执行权。 &#125; //t1有，或者t2有 &#125; &#125;&#125; GetThread 123456789101112131415161718192021222324252627282930313233package cn.itcast_05;public class GetThread implements Runnable &#123; private Student s; public GetThread(Student s) &#123; this.s = s; &#125; @Override public void run() &#123; while (true) &#123; synchronized (s) &#123; if(!s.flag)&#123; try &#123; s.wait(); //t2就等待了。立即释放锁。将来醒过来的时候，是从这里醒过来的时候 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(s.name + "---" + s.age); //林青霞---27 //刘意---30 //修改标记 s.flag = false; //唤醒线程 s.notify(); //唤醒t1 &#125; &#125; &#125;&#125; StudentDemo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package cn.itcast_05;/* * 分析： * 资源类：Student * 设置学生数据:SetThread(生产者) * 获取学生数据：GetThread(消费者) * 测试类:StudentDemo * * 问题1：按照思路写代码，发现数据每次都是:null---0 * 原因：我们在每个线程中都创建了新的资源,而我们要求的时候设置和获取线程的资源应该是同一个 * 如何实现呢? * 在外界把这个数据创建出来，通过构造方法传递给其他的类。 * * 问题2：为了数据的效果好一些，我加入了循环和判断，给出不同的值,这个时候产生了新的问题 * A:同一个数据出现多次 * B:姓名和年龄不匹配 * 原因： * A:同一个数据出现多次 * CPU的一点点时间片的执行权，就足够你执行很多次。 * B:姓名和年龄不匹配 * 线程运行的随机性 * 线程安全问题： * A:是否是多线程环境 是 * B:是否有共享数据 是 * C:是否有多条语句操作共享数据 是 * 解决方案： * 加锁。 * 注意： * A:不同种类的线程都要加锁。 * B:不同种类的线程加的锁必须是同一把。 * * 问题3:虽然数据安全了，但是呢，一次一大片不好看，我就想依次的一次一个输出。 * 如何实现呢? * 通过Java提供的等待唤醒机制解决。 * * 等待唤醒： * Object类中提供了三个方法： * wait():等待 * notify():唤醒单个线程 * notifyAll():唤醒所有线程 * 为什么这些方法不定义在Thread类中呢? * 这些方法的调用必须通过锁对象调用，而我们刚才使用的锁对象是任意锁对象。 * 所以，这些方法必须定义在Object类中。 */public class StudentDemo &#123; public static void main(String[] args) &#123; //创建资源 Student s = new Student(); //设置和获取的类 SetThread st = new SetThread(s); GetThread gt = new GetThread(s); //线程类 Thread t1 = new Thread(st); Thread t2 = new Thread(gt); //启动线程 t1.start(); t2.start(); &#125;&#125; 上述是具体的实现方法和操作，其中的注释可以参考着观看，有助于理解程序代码。 线程的转化状态主要参考下图 线程组线程组（ThreadGroup）就是由线程组成的管理线程的类，这个类是java.lang.ThreadGroup类。 在Java中每一个线程都归属于某个线程组管理的一员，例如在主函数main()主工作流程中产生一个线程，则产生的线程属于main这个线程组管理的一员。定义一个线程组，通过以下代码可以实现。ThreadGroup group=new ThreadGroup(“group”);Thread thread=new Thread(group,”the first thread of group”);具体的java例子代码可以见下： MyRunnable—–&gt;实现线程123456789101112package cn.itcast_06;public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(Thread.currentThread().getName() + ":" + x); &#125; &#125;&#125; ThreadGroupDemo—–&gt;首先先构建一个线程组，然后在线程构造的时候指定线程组，设置好线程可以通过tg.getThreadGroup().getName()获取当前的线程组名称。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.itcast_06;/* * 线程组： 把多个线程组合到一起。 * 它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。 */public class ThreadGroupDemo &#123; public static void main(String[] args) &#123; // method1(); // 我们如何修改线程所在的组呢? // 创建一个线程组 // 创建其他线程的时候，把其他线程的组指定为我们自己新建线程组 method2(); // t1.start(); // t2.start(); &#125; private static void method2() &#123; // ThreadGroup(String name) ThreadGroup tg = new ThreadGroup("这是一个新的组"); MyRunnable my = new MyRunnable(); // Thread(ThreadGroup group, Runnable target, String name) Thread t1 = new Thread(tg, my, "林青霞"); Thread t2 = new Thread(tg, my, "刘意"); System.out.println(t1.getThreadGroup().getName()); System.out.println(t2.getThreadGroup().getName()); //通过组名称设置后台线程，表示该组的线程都是后台线程 tg.setDaemon(true); &#125; private static void method1() &#123; MyRunnable my = new MyRunnable(); Thread t1 = new Thread(my, "林青霞"); Thread t2 = new Thread(my, "刘意"); // 我不知道他们属于那个线程组,我想知道，怎么办 // 线程类里面的方法：public final ThreadGroup getThreadGroup() ThreadGroup tg1 = t1.getThreadGroup(); ThreadGroup tg2 = t2.getThreadGroup(); // 线程组里面的方法：public final String getName() String name1 = tg1.getName(); String name2 = tg2.getName(); System.out.println(name1); System.out.println(name2); // 通过结果我们知道了：线程默认情况下属于main线程组 // 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组 System.out.println(Thread.currentThread().getThreadGroup().getName()); &#125;&#125; 线程池概述程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。 线程池的实现方法 线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池 线程池具体方法JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法 public static ExecutorService newCachedThreadPool() 创建一个具有缓存功能的线程池 缓存：百度浏览过的信息再次访问 public static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用的，具有固定线程数的线程池 public static ExecutorService newSingleThreadExecutor() 创建一个只有单线程的线程池，相当于上个方法的参数是1 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法 Future&lt;?&gt; submit(Runnable task) &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) 线程池的代码实现MyRunnable接口实现线程。1234567891011public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(Thread.currentThread().getName() + ":" + x); &#125; &#125;&#125; ExecutorsDemo12345678910111213141516171819202122232425262728293031323334package cn.itcast_08;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/* * 线程池的好处：线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。 * * 如何实现线程的代码呢? * A:创建一个线程池对象，控制要创建几个线程对象。 * public static ExecutorService newFixedThreadPool(int nThreads) * B:这种线程池的线程可以执行： * 可以执行Runnable对象或者Callable对象代表的线程 * 做一个类实现Runnable接口。 * C:调用如下方法即可 * Future&lt;?&gt; submit(Runnable task) * &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) * D:我就要结束，可以吗? * 可以。 */public class ExecutorsDemo &#123; public static void main(String[] args) &#123; // 创建一个线程池对象，控制要创建几个线程对象。 // public static ExecutorService newFixedThreadPool(int nThreads) ExecutorService pool = Executors.newFixedThreadPool(2); // 可以执行Runnable对象或者Callable对象代表的线程 pool.submit(new MyRunnable()); pool.submit(new MyRunnable()); //结束线程池 pool.shutdown(); &#125;&#125; 多线程的面试题具体的面试题可以参考我的往期文章：多线程面试题 在看面试题的时候，要注意，自己是否是自己真的理解了透彻了。先去思考问题，再去想自己的语言如何回答，自己如果面试遇到这种问题了应该如何处理。之后再去看答案和解析，这样更有收获，一起加油ヾ(◍°∇°◍)ﾉﾞ。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程（一）]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ 多线程(一)多线程概念多线程：一个应用程序有多条执行路径 进程：正在执行的应用程序 线程：进程的执行单元，执行路径 单线程：一个应用程序只有一条执行路径 多线程：一个应用程序有多条执行路径 并发和并行的区别：简单的说，并行是指同一时刻同时做多件事情，而并发是指同一时间间隔内做多件事情。 并发是两个任务可以在重叠的时间段内启动，运行和完成。并行是任务在同一时间运行，例如，在多核处理器上。并发是独立执行过程的组合，而并行是同时执行（可能相关的）计算。并发是一次处理很多事情，并行是同时做很多事情。应用程序可以是并发的，但不是并行的，这意味着它可以同时处理多个任务，但是没有两个任务在同一时刻执行。应用程序可以是并行的，但不是并发的，这意味着它同时处理多核CPU中的任务的多个子任务。一个应用程序可以即不是并行的，也不是并发的，这意味着它一次一个地处理所有任务。应用程序可以即是并行的也是并发的，这意味着它同时在多核CPU中同时处理多个任务。 多进程的意义?单进程的计算机只能做一件事情,而我们现在的计算机都可以做多件事情。 举例:一边玩游戏(游戏进程),一边听音乐(音乐进程)。 也就是说现在的计算机都是支持多进程的,可以在一个时间段内执行多个任务。 并且呢,可以提高CPU的使用率。 多线程的意义?多线程的存在,不是提高程序的执行速度。其实是为了提高应用程序的使用率。 程序的执行其实都是在抢CUP的资源,CPU的执行权。 多个进程是在抢这个资源,而其中的某一个进程如果执行路径比较多,就会有更高的几率抢到CPU的执行权。 我们是不敢保证哪一个线程在哪个时刻抢到,所以线程的执行有随机性。 举例:一个美女抛绣球(CPU执行权),A,B,C…等,ABC(进程)三个人抢绣球(CPU执行权),但是由于B(进程)使用分身术(多条执行路径),而他抢到绣球的机率将会很高,但是不一定能抢到 Java程序的运行原理及JVM的启动是多线程的吗? Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。 JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。多线程的实现方案 继承Thread类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * cn.thread * * @author jh * @date 2018/7/2 18:18 * description:实现Thread方法，继承Thread类，然后再去重写run（）方法。 * 不是所有类需要被多线程执行，run（）方法里面是被线程执行的代码。 */public class ThreadTest1 extends Thread &#123; @Override public void run() &#123; int count=1000; for (int i = 0; i &lt; count; i++) &#123; System.out.println (getName ()+"------&gt;"+i); try &#123; Thread.sleep (1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace (); &#125; &#125; &#125;/*** getName ()源码public Thread() &#123; init(null, null, "Thread-" + nextThreadNum(), 0); &#125;* */ public static void main(String[] args) &#123; ThreadTest1 t = new ThreadTest1 (); ThreadTest1 t1 = new ThreadTest1 (); t.setName ("magic"); t1.setName ("jh"); /* 启动线程 t.run (); t.run ();*/ // java.lang.IllegalThreadStateException(非法的状态异常，相当于main线程启动了两次) /* t.start (); t.start ();*/ //如何获取线程的名称 public String getName() t.start (); t1.start (); /* * run方法调用就相当于普通方法的调用，单线程的执行 * 面试题：start和run的区别： * run：仅仅是封装被线程执行的代码，直接是调用是普通方法。 * start：首先启动线程，然后再由JVM虚拟机调用该线程的run（）方法。 */ &#125;&#125; 实现Runnable接口首先先实现一个线程，其次重写run()方法；下面这是一个卖票的多线程程序。 1234567891011121314151617181920212223package cn.thread;/** * cn.thread * * @author jh * @date 2018/7/3 8:22 * description: */public class MyThread1 implements Runnable &#123; private static int count =10000; private static Object obj=new Object (); @Override public void run() &#123; while (true)&#123; synchronized (obj)&#123; if (count &gt; 0) &#123; System.out.println (Thread.currentThread ().getName ()+"正在售票---&gt;"+(count--)); &#125; &#125; &#125; &#125;&#125; 接下来是Main的方法123456789101112public static void main(String[] args) &#123; MyThread1 my = new MyThread1 (); Thread t = new Thread (my, "一号窗口"); Thread tt = new Thread (my, "二号窗口"); Thread ttt = new Thread (my, "三号窗口"); t.start (); tt.start (); ttt.start (); &#125; 实现Callable接口实现Callable接口，重写call（）方法；具体代码见下：12345678910111213141516171819202122232425import java.util.concurrent.Callable;/* * 线程求和案例(实现Callable接口，重写了call()方法) * Callable:是带泛型的接口。 * 这里指定的泛型其实是call()方法的返回值类型。 */public class MyCallable implements Callable&lt;Integer&gt; &#123; private int number; public MyCallable(int number) &#123; this.number = number; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for (int x = 1; x &lt;= number; x++) &#123; sum += x; &#125; return sum; &#125;&#125; Main方法1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/* * 多线程实现的方式3： * A:创建一个线程池对象，控制要创建几个线程对象。 * public static ExecutorService newFixedThreadPool(int nThreads) * B:这种线程池的线程可以执行： * 可以执行Runnable对象或者Callable对象代表的线程 * 做一个类实现Runnable接口。 * C:调用如下方法即可 * Future&lt;?&gt; submit(Runnable task) * &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) * D:我就要结束，可以吗? * 可以。 */public class CallableDemo &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; // 创建线程池对象 ExecutorService pool = Executors.newFixedThreadPool(2); // 可以执行Runnable对象或者Callable对象代表的线程 Future&lt;Integer&gt; f1 = pool.submit(new MyCallable(100)); Future&lt;Integer&gt; f2 = pool.submit(new MyCallable(200)); // V get() Integer i1 = f1.get(); Integer i2 = f2.get(); System.out.println(i1); System.out.println(i2); // 结束 pool.shutdown(); &#125;&#125; 总结：总的来说，虽然实现多线程有两种方式，但是还是推荐使用实现Runable接口的方式，让程序具有可扩展性。 线程的调度和优先级问题 线程的调度 分时调度，所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度 (Java采用的是该调度方式)，优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 获取和设置线程优先级 默认是5 范围是1-10在Java中，线程的优先级用setPriority()方法就行，线程的优先级分为1-10这10个等级，如果小于1或大于10，则抛出异常throw new IllegalArgumentException()，默认是5。主要的方法是： public final int getPriority() 获取线程优先级public final void setPriority(int newPriority)设置线程优先级（1-10） 12345678910package cn.itcast_04;public class ThreadPriority extends Thread &#123; @Override public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(getName() + ":" + x); &#125; &#125;&#125; Main方法示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.itcast_04;/* * 我们的线程没有设置优先级,肯定有默认优先级。 * 那么，默认优先级是多少呢? * 如何获取线程对象的优先级? * public final int getPriority():返回线程对象的优先级 * 如何设置线程对象的优先级呢? * public final void setPriority(int newPriority)：更改线程的优先级。 * * 注意： * 线程默认优先级是5。 * 线程优先级的范围是：1-10。 * 线程优先级高仅仅表示线程获取的 CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到比较好的效果。 * * IllegalArgumentException:非法参数异常。 * 抛出的异常表明向方法传递了一个不合法或不正确的参数。 * */public class ThreadPriorityDemo &#123; public static void main(String[] args) &#123; ThreadPriority tp1 = new ThreadPriority(); ThreadPriority tp2 = new ThreadPriority(); ThreadPriority tp3 = new ThreadPriority(); tp1.setName("东方不败"); tp2.setName("岳不群"); tp3.setName("林平之"); // 获取默认优先级 // System.out.println(tp1.getPriority()); // System.out.println(tp2.getPriority()); // System.out.println(tp3.getPriority()); // 设置线程优先级 // tp1.setPriority(100000); //设置正确的线程优先级 tp1.setPriority(10); tp2.setPriority(1); tp1.start(); tp2.start(); tp3.start(); &#125;&#125; 线程的控制(常见方法)A:休眠线程 (public static void sleep(long millis))代码示例：12345678910111213141516171819package cn.itcast_04;import java.util.Date;public class ThreadSleep extends Thread &#123; @Override public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(getName() + ":" + x + ",日期：" + new Date()); // 睡眠 // 困了，我稍微休息1秒钟 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Main方法的示例123456789101112131415161718192021package cn.itcast_04;/* * 线程休眠 * public static void sleep(long millis) */public class ThreadSleepDemo &#123; public static void main(String[] args) &#123; ThreadSleep ts1 = new ThreadSleep(); ThreadSleep ts2 = new ThreadSleep(); ThreadSleep ts3 = new ThreadSleep(); ts1.setName("林青霞"); ts2.setName("林志玲"); ts3.setName("林志颖"); ts1.start(); ts2.start(); ts3.start(); &#125;&#125; B:加入线程 (public final void join())示例代码：12345678910package cn.itcast_04;public class ThreadJoin extends Thread &#123; @Override public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(getName() + ":" + x); &#125; &#125;&#125; Main方法1234567891011121314151617181920212223242526package cn.itcast_04;/* * public final void join():等待该线程终止。 */public class ThreadJoinDemo &#123; public static void main(String[] args) &#123; ThreadJoin tj1 = new ThreadJoin(); ThreadJoin tj2 = new ThreadJoin(); ThreadJoin tj3 = new ThreadJoin(); tj1.setName("李渊"); tj2.setName("李世民"); tj3.setName("李元霸"); tj1.start(); try &#123; tj1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; tj2.start(); tj3.start(); &#125;&#125; C:礼让线程 (public static void yield())示例代码：1234567891011package cn.itcast_04;public class ThreadYield extends Thread &#123; @Override public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(getName() + ":" + x); Thread.yield(); &#125; &#125;&#125; Main方法123456789101112131415161718package cn.itcast_04;/* * public static void yield():暂停当前正在执行的线程对象，并执行其他线程。 * 让多个线程的执行更和谐，但是不能靠它保证一人一次。 */public class ThreadYieldDemo &#123; public static void main(String[] args) &#123; ThreadYield ty1 = new ThreadYield(); ThreadYield ty2 = new ThreadYield(); ty1.setName("林青霞"); ty2.setName("刘意"); ty1.start(); ty2.start(); &#125;&#125; D:后台线程 (public final void setDaemon(boolean on))示例代码：12345678910package cn.itcast_04;public class ThreadDaemon extends Thread &#123; @Override public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(getName() + ":" + x); &#125; &#125;&#125; Main方法1234567891011121314151617181920212223242526272829package cn.itcast_04;/* * public final void setDaemon(boolean on):将该线程标记为守护线程或用户线程。 * 当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 * * 游戏：坦克大战。 */public class ThreadDaemonDemo &#123; public static void main(String[] args) &#123; ThreadDaemon td1 = new ThreadDaemon(); ThreadDaemon td2 = new ThreadDaemon(); td1.setName("关羽"); td2.setName("张飞"); // 设置收获线程 td1.setDaemon(true); td2.setDaemon(true); td1.start(); td2.start(); Thread.currentThread().setName("刘备"); for (int x = 0; x &lt; 5; x++) &#123; System.out.println(Thread.currentThread().getName() + ":" + x); &#125; &#125;&#125; E:终止线程 (public final void stop()/public void interrupt())示例代码：1234567891011121314151617181920package cn.itcast_04;import java.util.Date;public class ThreadStop extends Thread &#123; @Override public void run() &#123; System.out.println("开始执行：" + new Date()); // 我要休息10秒钟，亲，不要打扰我哦 try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); System.out.println("线程被终止了"); &#125; System.out.println("结束执行：" + new Date()); &#125;&#125; Main方法123456789101112131415161718192021package cn.itcast_04;/* * public final void stop():让线程停止，过时了，但是还可以使用。 * public void interrupt():中断线程。 把线程的状态终止，并抛出一个InterruptedException。 */public class ThreadStopDemo &#123; public static void main(String[] args) &#123; ThreadStop ts = new ThreadStop(); ts.start(); // 你超过三秒不醒过来，我就干死你 try &#123; Thread.sleep(3000); // ts.stop(); ts.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 线程的生命周期(参照 线程生命周期图解.bmp)A:新建B:就绪C:运行D:阻塞E:死亡如图所示： 电影院卖票程序的实现A:继承Thread类B:实现Runnable接口 电影院卖票程序出问题 为了更符合真实的场景，加入了休眠100毫秒。 卖票问题 同票多次 负数票多线程安全问题的原因 是否有多线程环境 是否有共享数据 是否有多条语句操作共享数据同步解决线程安全问题 同步代码块 synchronized(对象) { 需要被同步的代码; } 这里的锁对象可以是任意对象。 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast_09;public class SellTicket implements Runnable &#123; // 定义100张票 private int tickets = 100; //创建锁对象 private Object obj = new Object();// @Override// public void run() &#123;// while (true) &#123;// synchronized(new Object())&#123;// if (tickets &gt; 0) &#123;// try &#123;// Thread.sleep(100); // &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// System.out.println(Thread.currentThread().getName() + "正在出售第"// + (tickets--) + "张票");// &#125;// &#125;// &#125;// &#125; @Override public void run() &#123; while (true) &#123; synchronized (obj) &#123; if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在出售第" + (tickets--) + "张票"); &#125; &#125; &#125; &#125;&#125; Main方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.itcast_09;/* * 如何解决线程安全问题呢? * * 要想解决问题，就要知道哪些原因会导致出问题:(而且这些原因也是以后我们判断一个程序是否会有线程安全问题的标准) * A:是否是多线程环境 * B:是否有共享数据 * C:是否有多条语句操作共享数据 * * 我们来回想一下我们的程序有没有上面的问题呢? * A:是否是多线程环境 是 * B:是否有共享数据 是 * C:是否有多条语句操作共享数据 是 * * 由此可见我们的程序出现问题是正常的，因为它满足出问题的条件。 * 接下来才是我们要想想如何解决问题呢? * A和B的问题我们改变不了，我们只能想办法去把C改变一下。 * 思想： * 把多条语句操作共享数据的代码给包成一个整体，让某个线程在执行的时候，别人不能来执行。 * 问题是我们不知道怎么包啊?其实我也不知道，但是Java给我们提供了：同步机制。 * * 同步代码块： * synchronized(对象)&#123; * 需要同步的代码; * &#125; * * A:对象是什么呢? * 我们可以随便创建一个对象试试。 * B:需要同步的代码是哪些呢? * 把多条语句操作共享数据的代码的部分给包起来 * * 注意： * 同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。 * 多个线程必须是同一把锁。 */public class SellTicketDemo &#123; public static void main(String[] args) &#123; // 创建资源对象 SellTicket st = new SellTicket(); // 创建三个线程对象 Thread t1 = new Thread(st, "窗口1"); Thread t2 = new Thread(st, "窗口2"); Thread t3 = new Thread(st, "窗口3"); // 启动线程 t1.start(); t2.start(); t3.start(); &#125;&#125; 同步方法 把同步加在方法上。 这里的锁对象是this 1234567891011121314151617181920212223242526272829303132package cn.itcast_10;public class SellTicket implements Runnable &#123; // 定义100张票 private int tickets = 100; // 定义同一把锁 private Object obj = new Object(); @Override public void run() &#123; while (true) &#123; // t1,t2,t3都能走到这里 // 假设t1抢到CPU的执行权，t1就要进来 // 假设t2抢到CPU的执行权，t2就要进来,发现门是关着的，进不去。所以就等着。 // 门(开,关) synchronized (obj) &#123; // 发现这里的代码将来是会被锁上的，所以t1进来后，就锁了。(关) if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); // t1就睡眠了 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在出售第" + (tickets--) + "张票 "); //窗口1正在出售第100张票 &#125; &#125; //t1就出来可，然后就开门。(开) &#125; &#125;&#125; Main方法1234567891011121314151617181920212223242526272829303132package cn.itcast_10;/* * 举例： * 火车上厕所。 * * 同步的特点： * 前提： * 多个线程 * 解决问题的时候要注意： * 多个线程使用的是同一个锁对象 * 同步的好处 * 同步的出现解决了多线程的安全问题。 * 同步的弊端 * 当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。 */public class SellTicketDemo &#123; public static void main(String[] args) &#123; // 创建资源对象 SellTicket st = new SellTicket(); // 创建三个线程对象 Thread t1 = new Thread(st, "窗口1"); Thread t2 = new Thread(st, "窗口2"); Thread t3 = new Thread(st, "窗口3"); // 启动线程 t1.start(); t2.start(); t3.start(); &#125;&#125; 静态同步方法 把同步加在方法上。 这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package cn.itcast_11;public class SellTicket implements Runnable &#123; // 定义100张票 private static int tickets = 100; // 定义同一把锁 private Object obj = new Object(); private Demo d = new Demo(); private int x = 0; //同步代码块用obj做锁// @Override// public void run() &#123;// while (true) &#123;// synchronized (obj) &#123;// if (tickets &gt; 0) &#123;// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// System.out.println(Thread.currentThread().getName()// + "正在出售第" + (tickets--) + "张票 ");// &#125;// &#125;// &#125;// &#125; //同步代码块用任意对象做锁// @Override// public void run() &#123;// while (true) &#123;// synchronized (d) &#123;// if (tickets &gt; 0) &#123;// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// System.out.println(Thread.currentThread().getName()// + "正在出售第" + (tickets--) + "张票 ");// &#125;// &#125;// &#125;// &#125; @Override public void run() &#123; while (true) &#123; if(x%2==0)&#123; synchronized (SellTicket.class) &#123; if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在出售第" + (tickets--) + "张票 "); &#125; &#125; &#125;else &#123;// synchronized (d) &#123;// if (tickets &gt; 0) &#123;// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// System.out.println(Thread.currentThread().getName()// + "正在出售第" + (tickets--) + "张票 ");// &#125;// &#125; sellTicket(); &#125; x++; &#125; &#125;// private void sellTicket() &#123;// synchronized (d) &#123;// if (tickets &gt; 0) &#123;// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// System.out.println(Thread.currentThread().getName()// + "正在出售第" + (tickets--) + "张票 ");// &#125;// &#125;// &#125; //如果一个方法一进去就看到了代码被同步了，那么我就再想能不能把这个同步加在方法上呢?// private synchronized void sellTicket() &#123;// if (tickets &gt; 0) &#123;// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// System.out.println(Thread.currentThread().getName()// + "正在出售第" + (tickets--) + "张票 ");// &#125;// &#125; private static synchronized void sellTicket() &#123; if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在出售第" + (tickets--) + "张票 "); &#125;&#125;&#125;class Demo &#123;&#125; Main方法1234567891011121314151617181920212223242526272829303132package cn.itcast_11;/* * A:同步代码块的锁对象是谁呢? * 任意对象。 * * B:同步方法的格式及锁对象问题? * 把同步关键字加在方法上。 * * 同步方法是谁呢? * this * * C:静态方法及锁对象问题? * 静态方法的锁对象是谁呢? * 类的字节码文件对象。(反射会讲) */public class SellTicketDemo &#123; public static void main(String[] args) &#123; // 创建资源对象 SellTicket st = new SellTicket(); // 创建三个线程对象 Thread t1 = new Thread(st, "窗口1"); Thread t2 = new Thread(st, "窗口2"); Thread t3 = new Thread(st, "窗口3"); // 启动线程 t1.start(); t2.start(); t3.start(); &#125;&#125; 回顾以前的线程安全的类 StringBufferVectorHashtable 如何把一个线程不安全的集合类变成一个线程安全的集合类有两种方法，首先寻找原本就线程安全的类：CopyOnWriteArrayList、ConcurrentHashMap等方法来实现。用Collections工具类的方法即可。比如synchronizedSet(Set s)的静态方法，具体见下图。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vector、ArrayList、LinkedList之间的区别？]]></title>
    <url>%2F2018%2F07%2F14%2FVector%E3%80%81ArrayList%E3%80%81LinkedList%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ 基本概述这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。 Vector 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。 ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。 LinkedList 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。 考点分析一般来说，不同容器适合不同的场景。 Vector和ArrayList都是动态数组，其内部元素以数组的顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会比较差，比如我们在元素中间插入一个元素，需要移动后续所有元素。 而LinkedList进行节点插入、删除效率很高，但是随机访问性能则要比动态数组慢很多。对于Vector的分析可以看我之前的文章Vector的源码解析，还有我在CSDN上面写的关于ArrayList的文章：ArrayList源码分析有什么不对请大家指正，感谢❤集合框架的整体设计可以如下图所示（并没有Map。虽然通常概念上它作为集合 框架的一部分，但是本本身并不是真正的集合）： 我们可以看到java的集合框架，Collection接口是所有的根，然后主要扩展了三大类集合： List,也就是我们前面介绍最多的有序集合，它提供了方便的访问、插入、删除等操作。 SetSet 是不允许重复元素的，这是和 List 最明显的区别，也就是不存在两个对象 equals 返回 true。我们在日常开发中有很多需要保证元素唯一性的场合。 Queue则是 Java 提供的标准队列结构的实现，除了集合的基本功能，它还支持类似先入先出（FIFO， First-in-First-Out）或者后入先出（LIFO，Last-In-First-Out）等特定行为。这里不包括 BlockingQueue，因为通常是并发编程场合，所以被放置在并发包里。 其实总的来说，集合框架的学习还是重在源码的学习，里面有很多优秀的设计思路，也封装了很多数据结构，并且在并发编程的时候，还要注意使用不同的集合或是使用Collections的同步方法。下面我放一些我对源码解析的文章（未完待续…大家一起学习，一起进步） Collection概述 ArrayList源码分析 Vector源码解析 HashMap的源码解析 未完待续]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int和Integer的区别？Integer的值缓存范围？]]></title>
    <url>%2F2018%2F07%2F13%2Fint%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FInteger%E7%9A%84%E5%80%BC%E7%BC%93%E5%AD%98%E8%8C%83%E5%9B%B4%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ 概述int 是我们常说的整形数字，是 Java 的 8 个原始数据类型（Primitive Types），boolean、byte 、short、char、int、float、double、long之一。Java 语言虽然号称一切都是对象，但原始数据类型是例外。 Integer 是 int 对应的包装类，它有一个 int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间转换等。在 Java 5 中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。 关于 Integer 的值缓存，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，这个值默认缓存是 -128 到 127 之间。 考点分析理解自动拆箱，自动装箱。自动装箱实际是一种语法糖，语法糖是指java平台为我们自动进行了一些转换，保证不同写法在运行时等价，它们发生在编译阶段，而且生成的字节码是一致的。就像之前说的int整数，javac会替我们自动装箱为Integer.valueOf()，把拆箱自动转换成Integer.valueOf()。我们可以看一下java的class文件反编译后的结果。大致的包装类有： int——Integerfloat——Floatdouble——Doublebyte——Bytelong——Longchar——Characterboolean——Booleanshort——Short 这是一个简单的自动拆/装箱的程序。1234567public class Demo &#123; public static void main(String[] args) &#123; Integer i=99; int totalprim = i; &#125;&#125; 反编译输出：12345678910111213public class Demo&#123; public Demo() &#123; &#125; public static void main(String args[]) &#123; Integer i = Integer.valueOf(99); i.intValue(); &#125;&#125; 仔细观察，其实就是通过Integer.valueOf(99)实现自动装箱。i.intValue()实现自动拆箱。 123456Integer i1=100; Integer i2=100; Integer i3=300; Integer i4=300; System.out.println(i1==i2);//true System.out.println(i3==i4);//false 在源码中，Integer.valueOf(int i)的源码如下：123456public static Integer valueOf(int i) &#123; if(i &gt;= -128 &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + 128]; else return new Integer(i); &#125; 我们可以看到当i&gt;=-128且i&lt;=IntegerCache.high时，直接返回IntegerCache.cache[i + 128]。其中，IntegerCache为Integer的内部静态类。我们可以清楚地看到，IntegerCache有静态成员变量cache，为一个拥有256个元素的数组。在IntegerCache中也对cache进行了初始化，即第i个元素是值为i-128的Integer对象。而-128至127是最常用的Integer对象，这样的做法也在很大程度上提高了性能。也正因为如此，“Integeri1=100;Integer i2=100;”，i1与i2得到是相同的对象。 也就是说在-128—127的范围内为自动拆装箱。超过范围则不会自动转换，应该注意！！！其实在阿里巴巴Java开发手册中，已经有介绍： 所有的包装类对象之间值的比较，全部使用equals方法比较。说明：对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。12345Integer a = 235; Integer b = 235; if (a.equals(b)) &#123; // code &#125; 源码分析整体看一下Integer的职责，主要包括各种基础的常量，比如最大值、最小值、位数等。首先，java默认大小是-128-127之间，其实这个值是可以修改的，可以通过JVM参数修改。1-xx:AutoBoxCacheMax=N 这些实现都体现在java.lang.Integer中，并且实现在IntegerCache的静态初始化块中。1234567891011121314private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); ... // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; ... &#125; 第二，我们在分析字符串的设计实现时，提到过字符串是不可变的，保证了基本的信息安全和并发编程中的线程安全。如果你去看包装类里存储数值的成员变量“ value”，你会发现，不管是 Integer还 Boolean等，都被声明为“ private final”，所以，它们同样是不可变类型！这种设计是可以理解的，或者说是必须的选择。想象一下这个应用场景，比如 Integer提供了 getInteger()方法，用于方便地读取系统属性，我们可以用属性来设置服务器某个服务的端口，如果我可以轻易地把获取到的 Integer对象改变为其他数值，这会带来产品可靠性方面的严重问题。第三， Integer等包装类，定义了类似 SIZE或者 BYTES这样的常量，这反映了什么样的设计考虑呢？如果你使用过其他语言，比如 C、 C++，类似整数的位数，其实是不确定的，可能在不同的平台，比如32位或者64位平台，存在非常大的不同。那么，在32位 JDK或者64。其实，这种移植对于 Java来说相对要简单些，因为原始数据类型是不存在差异的，这些明确定义在 Java语言规范里面，不管是32位还是64位环境，开发者无需担心数据的位数差异。 原始类线程安全原始数据类型是不是线程安全？ 原始数据类型的变量，显然要通过使用并发相关手段，才能保证线程安全。如果需要线程安全这样的需求，可以直接考虑使用线程安全的类，比如：AtomicInteger/AtomicLong. 特别是一些比较宽的数据类型，比如float、do，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半的数据位。 java原始数据类型和应用类型的局限性原始数据类型的一些局限性： 原始数据类型不能和java泛型配合使用。这是因为 Java 的泛型某种程度上可以算作伪泛型，它完全是一种编译期的技巧，Java 编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为 Object。 无法高效地表达数据，也不能表达复杂的数据结构，不如vector和tuple。我们知道 Java 的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。Java 为对象内建了各种多态、线程安全等方面的支持，但这不是所有场合的需求，尤其是数据处理重要性日益提高，更加高密度的值类型是非常现实的需求。目前，针对这些方面的增强，OpenJDK也在开发中，估计之后会有更好的发展。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理基于什么原理？]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ 概述反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。 动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。 实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。 考点分析这道题会让人下意识的感觉是在考反射，但是实现动态代理的方式有很多，不止是反射一种。功能才是目的，实现的方法有很多。主要的考察点： 考察对反射的了解程度。 动态代理解决了什么问题，应用场景是什么？ JDK的动态代理的设计和实现和cgilb的方式有什么不同，如何选择两者？ 反射JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.通过反射可以动态获取Constructors、Method、Class、Field。这些只能获取公共的方法，要想获取私有的方法，需要加上getDeclared+…，。其中还有反射提供的AccessibleObject.setAccessible(boolean flag),这里的Accessible可以理解为修改成修饰成员public、protected、private。可以修改为false，取消java语法检查。这意味着可以在运行时修改成员变量的访问限制。setAccessible 的应用场景非常普遍，遍布我们的日常开发、测试、依赖注入等各种框架中。比如，在 O/R Mapping 框架中，我们为一个 Java 实体对象，运行时自动生成 setter、getter 的逻辑，这是加载或者持久化数据非常必要的，框架通常可以利用反射做这个事情，而不需要开发者手动写类似的重复代码。 需要注意的是在java9以后，这个方法有一些改变，因为新增的模块化系统，处于对系统封装性的考虑，对反射进行了一些限制,Jigsaw引入了所谓的open的概念，只有当被反射对象操作的模块和指定的包对反射调用者模块open，才能使用setAccessible，否则被认为不合法（illegal）。 具体的操作可以参考我写的Demo：reflect 动态代理代理可以看做对调用目标的一个包装，这样我们可以对目标代码的调用不是直接发生的，而是通过代理完成的。动态代理的作用可以用来做AOP。可以去做一些重复的工作（比如权限呢检验，日志记录），用动态代理去抽取出来。增强代码的易用性。 具体介绍一下java里面内置的Proxy类的一些简单操作：在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib。 Proxy类中的方法创建动态代理类对象1public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 最终会调用InvocationHandler的方法1InvocationHandler Object invoke(Object proxy,Method method,Object[] args) 动态代理的具体实现可以参考我的GitHub：Proxy。 cgilb实现动态代理：1待续... 动态代理的使用场景：AOP 通过（动态）代理机制可以让开发者从这些繁琐事项中抽身出来，大幅度提高了代码的抽象程度和复用度。从逻辑上来说，我们在软件设计和实现中的类似代理，如 Facade、Observer 等很多设计目的，都可以通过动态代理优雅地实现。 JDK的动态代理的设计和实现和cgilb的方式有什么不同?我大概简单介绍一下：对于JDK Proxy的优势： 最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。 平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。 代码实现简单。 cglib框架的优势： 有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。 只操作我们关心的类，而不必为其他相关类增加工作量。 高性能。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer、StringBuilder的区别？]]></title>
    <url>%2F2018%2F07%2F11%2FString%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ StringString 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。 StringBufferStringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。 StringBuilderStringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。 三者区别 String StringBuffer StringBuilder 对象类型 字符串常量 字符串变量 字符串变量 线程安全 不安全 不安全 安全 执行效率 低 高 中 使用场景 操作少，数据少 单线程，操作多，数据多 多线程，操作多，数据多 String为什么设计成final？原因无非就是下面几点： 为了实现字符串池 为了线程安全 为了实现String可以创建HashCode不可变性 首先要了解final关键字的含义，在之前的文章已经介绍过什么是fina具体可以查看之前的文章：final、finally、finalize的区别我大概简述一下：final可以修饰类，方法和变量，并且被修饰的类或方法，被final修饰的类不能被继承，即它不能拥有自己的子类，被final修饰的方法不能被重写， final修饰的变量，无论是类属性、对象属性、形参还是局部变量，都需要进行初始化操作。字符串在内存存储的样子如下图： 实现字符串池所以只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。线程安全如果字符串是可变的，那么会引起很严重的安全问题。因为字符串是不可变的，所以它的值是不可改变的，否则改变字符串指向的对象的值，造成安全漏洞。因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。HashCode不可变性因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强引用、软引用、弱引用、幻象引用有什么区别？]]></title>
    <url>%2F2018%2F07%2F10%2F%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ 强引用（StrongReference）强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：1Object o=new Object(); // 强引用 通过关键字new创建对象，所关联的引用就是强引用。当JVM内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：1o=null; // 帮助垃圾收集器回收此对象 显式的将o设置为null；或者超出对象的生命周期范围，则gc认为该对象不存在引用。这样就可以被垃圾收集了，具体回收时机还是要看垃圾回收机制。例子：1234public void test()&#123; Object o=new Object(); //...&#125; 对于上述代码，可以看出方法的内部有一个强引用，这个引用保存在栈中，真正的引用内容（Object）保存在堆中。当这个方法运行完成之后就会退出方法栈，则引用内容的引用就不存在了，这个Object会被回收。但是当这个o是全局变量时，就需要在不使用这个对象时要赋值为null，因为强引用不会被垃圾回收。 12345678910111213/** * Removes all of the elements from this list. The list will * be empty after this call returns. */ public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 这个就是在java源码中的体现。就是在需要清除的时候，需要把elementData里面全部置为空，因为elementData是全局变量。 软引用（SoftReference）是一种相对强引用的弱化一些的引用，可以让豁免一些垃圾收集，只有当JVM尝试内存不足时。才会尝试回收软引用指定的对象。JVM会确保在抛出OutOfMemoryError之前，会先清理软引用指定的对象。软引用通常用于内存敏感的高速缓存，如果还有空内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。1234String str=new String("abc"); // 强引用SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str);// 软引用 当内存不足时，等价于：1234If(JVM.内存不足()) &#123; str = null; // 转换为软引用 System.gc(); // 垃圾回收器进行回收&#125; 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。 弱引用（WeakReference）弱引用并不能对对象实现豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系。比如，维护一种非强制性的映射关系，如果试图获取时对象还存在，就使用它，否则重现实例化。它同样是对缓存实现的选择。123String str=new String("abc"); WeakReference&lt;String&gt; abcWeakRef = new WeakReference&lt;String&gt;(str);str=null; 当垃圾回收器进行扫描时,等同于12str = null;System.gc(); 弱引用和软引用之间的去区别：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 虚引用（PhantomReference） “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。 总结 Java4种引用的级别由高到低依次为： 强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用 可以看一下在垃圾回收时候的图解： 当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章： 通过表格来说明一下，如下： 引用类型 被垃圾回收时间 用途 生存时间 强引用 从来不会 对象的一般状态 JVN停止运行时终止 软引用 在内存不足时 对象缓存 内存不足时终止 弱引用 在垃圾回收时 对象缓存 GC运行后终止 虚引用 Unknow Unknow Unknow]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final、finally、finalize的区别]]></title>
    <url>%2F2018%2F07%2F09%2Ffinal%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ 概述首先，要我说，这个面试题，其中是三个其实没有什么联系，只不过是因为长的比较像，就拉出来考…但是从另一个方面看的话，这三个关键字还是很重要的。接下来简单介绍一下。 final关键字final可以用来修饰类、方法、变量，分别有不同的意义，final修饰的类不可以继承的扩展。final修饰的方法不可以被重写（overrride），final修饰的变量则为常量（即不可修改的量）。 finally关键字finally则是java保证重点代码一定要被执行的一种机制，我们可以使用try-catch-fianlly或者try-finally来进行关闭JDBC连接、或者用于关闭一些流对象（现在也有新方法，就是try-with-catch可以不使用fianlly）。 finalize方法finalize是基础类java.lang.Object的一个方法。它的设计目的是保证对象在垃圾收集前完成特定资源的回收。JDK9中已不推荐使用。 考点分析深入理解final关键字在java类库中的定义和源码中，在java.lang包下，相当一部分被声明成final class ？因为这可以有效避免API使用者更改基础功能，某种程度上，这是保证平台安全性的必要手段。 使用fianl修饰变量或者参数，也可以清楚地避免意外赋值导致的编程错误。甚至有人明确推荐将所有的方法参数、本地变量、成员变量都声明成final。 final变量产生了某种程度上的不可变（immutable）的效果,所以，可以用来保护只读数据，尤其在并发编程中，因为明确地不能再赋值fianl变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。 final还有性能上的好处下面这段话摘自《Java编程思想》第四版第143页： “使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。 注：类的private方法会隐式地被指定为final方法。 深入理解finally关键字对于finally来说，最常见的还是在try-catch-finally中。在Java语言的异常处理中，finally块的作用就是为了保证无论出现什么情况，finally块里的代码一定会被执行。但是其中有一些特殊情况。比如说出现java虚拟机退出的时候。123456try &#123; // do something Syst... System.exit(1);&#125;finally&#123; System.out.println("Hello,World!"); &#125; 就像出现上面的代码的时候，finally中并不会有任何反应。对于finally还有其他的问题，比如，finally中return值到底会返回谁？12345678910111213141516171819202122232425public class FinallyDemo2 &#123; public static void main(String[] args) &#123; System.out.println(getInt()); &#125; public static int getInt() &#123; int a = 10; try &#123; System.out.println(a / 0); a = 20; &#125; catch (ArithmeticException e) &#123; a = 30; return a; /* * return a在程序执行到这一步的时候，这里不是return a而是return 30;这个返回路径就形成了。 * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 * 再次回到以前的返回路径，继续走return 30; */ &#125; finally &#123; a = 40; return a;//如果这样结果就是40了。 &#125; // return a; &#125;&#125; 大家仔细观察，其实最后的返回值是30，并没有返回其中的40，这就是说明返回值时，还是返回的是当时的值，和finally中的值并没有关系。这个是比较重要的一点。 其中在JDK1.7中有一个新特性：try-with-resourcestry-with-resources语句是一个声明一个或多个资源的try语句。一个资源作为一个对象，必须在程序结束之后关闭。try-with-resources语句确保在语句的最后每个资源都被关闭，任何实现了java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resource来实现异常处理和关闭资源。具体使用见下：123try (BufferedReader br = new BufferedReader(new FileReader(path))) &#123; return br.readLine(); &#125; 把需要关闭的对象写在括号中，其中要关闭的对象必须实现java.lang.AutoCloseable和java.io.Closeable。 深入理解finalize方法finalize方法是比较难理解的一个方法，其中涉及了java垃圾回收机制的一些知识。java提供finalize()方法，垃圾回收器准备释放内存的时候，会先调用finalize()。 对象不一定会被回收。 垃圾回收不是析构函数。 垃圾回收只与内存有关。 垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。上面的解释来自《java编程思想》，本人对其了解也不是很多。有待提升。 这就是今天的内容，来自于杨晓峰老师的讲解和一些自己的理解和认识。有能力的同学可以支持一下，共同进步，共同努力。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exception与Error的区别]]></title>
    <url>%2F2018%2F07%2F08%2FException%E4%B8%8EError%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[爱女票，爱Java❤❤❤ 标准回答Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。 Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。 Error是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。 Exception又分为可检查（checked）异常和不检查（unchecked）异常 可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。 不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。 考点分析我们还需要注意两个方面的问题。 一、理解Throwable、Exception、Error的设计和分类下面是一个类的结构图，有助于我们去理解和掌握下面的子类 12345Throwable |--Error 严重问题，我们不处理。 |--Exception |--RuntimeException 运行期异常，我们需要修正代码 |--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过 其中需要重点理解的是NoClassDefFoundError和NoClassFoundException的区别。 NoClassDefFoundError出现的时机是当你真正使用这个类的信息的时候，当class-path上没有这个类的时候会出现.如果jvm或者一个ClassLoader的实例尝试去载入一个class的定义内容（普通方法的调用或者用new去创建这个class的实例）但是没有找到这个class的信息。这个是无法捕获的。ClassNotFoundException出现的时机就是一些反射操作，通过名称在Runtime去动态加载这个类的信息。这个可以抛出异常。 二、掌握java语言中操作Throwable的元素和实践。比如try-catch-finally块。throw、throws关键字等。 抛出异常的一些注意事项： A:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)B:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常C:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws 编译期异常和运行期异常的区别? 编译期异常 必须要处理的，否则编译不通过 运行期异常 可以不处理，也可以处理 throw、throws的区别？throw:在方法体中,后面跟的是异常对象名,并且只能抛出一个异常对象名。表示抛出异常，由方法体内的语句进行处理。throw抛出的是一个异常对象，说明这里肯定有一个异常产生了throws:在方法声明后面,后面跟的是异常的类名,可以抛出多个异常，用”，”隔开。表示抛出异常，由方法调用者进行处理。throws是声明方法有异常，是一种可能性，这个异常并不一定会产生 简单说一下try-catch-finally的一些注意事项和面试题： finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了，比如System.exit(0)。 如果catch里面有return语句，请问finally里面的代码还会执行吗如果会，请问是在return前，还是return后。会。前。准确的说，应该是在中间。具体可以仔细体会下面的代码，思考一下a的值最后是多少？ 12345678910111213141516171819202122232425public class FinallyDemo2 &#123; public static void main(String[] args) &#123; System.out.println(getInt()); &#125; public static int getInt() &#123; int a = 10; try &#123; System.out.println(a / 0); a = 20; &#125; catch (ArithmeticException e) &#123; a = 30; return a; /* * return a在程序执行到这一步的时候，这里不是return a而是return 30;这个返回路径就形成了。 * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 * 再次回到以前的返回路径，继续走return 30; */ &#125; finally &#123; a = 40; return a;//如果这样结果就是40了。 &#125; // return a; &#125;&#125; 其中在JDK1.7中有一个新特性：try-with-resourcestry-with-resources语句是一个声明一个或多个资源的try语句。一个资源作为一个对象，必须在程序结束之后关闭。try-with-resources语句确保在语句的最后每个资源都被关闭，任何实现了java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resource来实现异常处理和关闭资源。具体使用见下：123try (BufferedReader br = new BufferedReader(new FileReader(path))) &#123; return br.readLine(); &#125; 把需要关闭的对象写在括号中，其中要关闭的对象必须实现java.lang.AutoCloseable和java.io.Closeable。 最后，衷心感谢杨晓峰老师的讲解。很清晰和透彻，也希望大家可以支持一下。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2018%2F07%2F04%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程1:多线程(理解) 多线程：一个应用程序有多条执行路径进程：正在执行的应用程序 线程：进程的执行单元，执行路径 单线程：一个应用程序只有一条执行路径 多线程：一个应用程序有多条执行路径 **多进程的意义?** 提高CPU的使用率 **多线程的意义?** 提高应用程序的使用率 Java程序的运行原理及JVM的启动是多线程的吗? A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。 B:JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。 多线程的实现方案(自己补齐步骤及代码 掌握) A:继承Thread类 B:实现Runnable接口 线程的调度和优先级问题A:线程的调度 a:分时调度 b:抢占式调度 (Java采用的是该调度方式) B:获取和设置线程优先级 a:默认是5 b:范围是1-10 线程的控制(常见方法)A:休眠线程 B:加入线程 C:礼让线程 D:后台线程 E:终止线程(掌握) 线程的生命周期(参照 线程生命周期图解.bmp)A:新建 B:就绪 C:运行 D:阻塞 E:死亡 电影院卖票程序的实现A:继承Thread类 B:实现Runnable接口 电影院卖票程序出问题A:为了更符合真实的场景，加入了休眠100毫秒。 B:卖票问题 a:同票多次 b:负数票 多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)A:是否有多线程环境 B:是否有共享数据 C:是否有多条语句操作共享数据 同步解决线程安全问题 A:同步代码块 synchronized(对象) { 需要被同步的代码; } 这里的锁对象可以是任意对象。 B:同步方法 把同步加在方法上。 这里的锁对象是this C:静态同步方法 把同步加在方法上。 这里的锁对象是当前类的字节码文件对象 回顾以前的线程安全的类A:StringBuffer B:Vector C:Hashtable D:如何把一个线程不安全的集合类变成一个线程安全的集合类 用Collections工具类的方法即可。 JDK5以后的针对线程的锁定操作和释放操作Lock锁 死锁问题的描述和代码体现 生产者和消费者多线程体现(线程间通信问题) 以学生作为资源来实现的 资源类：Student 设置数据类：SetThread(生产者) 获取数据类：GetThread(消费者) 测试类：StudentDemo 代码： A:最基本的版本，只有一个数据。 B:改进版本，给出了不同的数据，并加入了同步机制 C:等待唤醒机制改进该程序，让数据能够实现依次的出现 wait() notify() notifyAll() (多生产多消费) D:等待唤醒机制的代码优化。把数据及操作都写在了资源类中 线程组 线程池 多线程实现的第三种方案]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试题]]></title>
    <url>%2F2018%2F07%2F04%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[多线程面试题1、多线程有什么用？一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法： （1）发挥多核CPU的优势 随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。 （2）防止阻塞 从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。 （3）便于建模 这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 2、创建线程的方式比较常见的一个问题了，一般就是两种： （1）继承Thread类 （2）实现Runnable接口 至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。 3、start()方法和run()方法的区别只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。 4、Runnable接口和Callable接口的区别有点深的问题了，也看出一个Java程序员学习知识的广度。 Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。 5、CyclicBarrier和CountDownLatch的区别两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于： （1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行 （2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务 （3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了 6、Volatile关键字的作用一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个： （1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据 （2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率 从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。 7、什么是线程安全又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。 这个问题有值得一提的地方，就是线程安全也是有几个级别的： （1）不可变 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 （2）绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet （3）相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。 （4）线程非安全 这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类 8、Java中如何获取到线程dump文件死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步： （1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java （2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid 另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈， 9、一个线程如果出现了运行时异常会怎么样如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放 10、如何在两个线程之间共享数据通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的 11、sleep方法和wait方法有什么区别这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器 12、生产者消费者模型的作用是什么这个问题很理论，但是很重要： （1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用 （2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约 13、ThreadLocal有什么用简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了 14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁 15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。 16、为什么要使用线程池避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。 17、怎么检测一个线程是否持有对象监视器我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程。 18、synchronized和ReentrantLock的区别synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： （1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 （2）ReentrantLock可以获取各种锁的信息 （3）ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。 19、ConcurrentHashMap的并发度是什么ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？ 20、ReadWriteLock是什么首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。 因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 21、FutureTask是什么这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。 22、Linux环境下如何查找哪个线程使用CPU最长这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做： （1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过 （2）top -H -p pid，顺序不能改变 这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。 使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。 最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。 23、Java编程写一个会导致死锁的程序第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。 真正理解什么是死锁，这个问题其实不难，几个步骤： （1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁； （2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁 （3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的 这样，线程1″睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。 24、怎么唤醒一个阻塞的线程如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 25、不可变对象对多线程有什么帮助前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。 26、什么是多线程的上下文切换多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。 27、如果你提交任务时，线程池队列已满，这时会发生什么如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。 28、Java中用到的线程调度算法是什么抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 29、Thread.sleep(0)的作用是什么这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。 30、什么是自旋很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行地非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 31、什么是Java内存模型Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容： （1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去 （2）定义了几个原子操作，用于操作主内存和工作内存中的变量 （3）定义了volatile变量的使用规则 （4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的 32、什么是CASCAS，全称为Compare and Set，即比较-设置。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。 33、什么是乐观锁和悲观锁（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 （2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。 34、什么是AQS简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。 如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。 AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。 35、单例模式的线程安全性老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下： （1）饿汉式单例模式的写法：线程安全 （2）懒汉式单例模式的写法：非线程安全 （3）双检锁单例模式的写法：线程安全 36、Semaphore有什么作用Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。 37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？ 关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点： （1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性 （2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。 38、线程类的构造方法、静态块是被哪个线程调用的这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。 如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么： （1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的 （2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的 39、同步方法和同步块，哪个是更好的选择同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越少越好。 借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。 40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是： （1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换 （2）并发不高、任务执行时间长的业务要区分开看： a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换 （3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识NIO一]]></title>
    <url>%2F2018%2F06%2F22%2FNIO%2F</url>
    <content type="text"><![CDATA[NIO概述 [name=magic] Java NIO（New IO） 是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同， NIO支持面向缓冲区的、基于通道的IO操作。 NIO将以更加高效的方式进行文件的读写操作。 JDK之后的NIO：也叫做NIO2（BIO） Path：路径（与平台无关） Paths：有一个静态方法返回路径（返回Path的静态方法） public static Path get(URI uri); Files：提供静态方法（操作文件的工具类） public static long copy(Path source, OutputStream out) 将文件中的所有字节复制到输出流。 public static Path write(Path path, Iterable lines, Charset cs, OpenOption... options) 将文本行写入文件。 NIO与IO区别 IO NIO 面向流(Stream Oriented) 面向缓冲区(Buffer Oriented) 阻塞IO(Blocking IO) 非阻塞IO(Non Blocking IO) (无) 选择器(Selectors) 通道和缓冲区 Java NIO系统的核心在于：通道(Channel)和(Buffer)。通道表示打开到 IO 设备(例如：套接字)的连接。若需要使用 NIO 系统，需用于连接 IO 设备的通道以及用于容纳数据区。然后操作缓冲区，对数据进行处理 简而言之， Channel 负责传输， Buffer 负责存储 NIO缓冲区（Buffer） 缓冲区概述 缓冲区（Buffer） ：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类 Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的 Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。 都是通过如下方法获取一个 Buffer对象： static XxxBuffer allocate(int capacity) : 创建一个容量为 capacity 的 XxxBuffer 对象 Buffer 中的重要概念： 容量 (capacity) ： 表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。 限制 (limit)： 第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。 位置 (position)： 下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制 标记 (mark)与重置 (reset)： 标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position 并且 0 &lt; mark &lt;= position &lt;=limit &lt;= capacity 1. 分配一个缓冲区要获得一个Buffer对象，你必须首先分配它，通过allocate()分配了一个10字节大小的缓冲区。 12ByteBuffer buf = ByteBuffer.allocate(10); 2. 将数据写入缓冲区将数据写入缓冲区有两种方式： 1.利用 put() 存入数据到缓冲区中 1234String str = "abcde";buf.put(str.getBytes()); put的方法总结put(byte b)：将给定单个字节写入缓冲区的当前位置put(byte[] src)：将 src 中的字节写入缓冲区的当前位置put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position) 2.将数据从 Channel写入Buffer 1234int bytesRead = inChannel.read（buf）;//读入缓冲区。 3. filp() 该flip()方法将Buffer从写入模式切换到读取模式。调用flip()将position设置为0，并将其设置为limit 刚才的位置。 换句话说，position现在标记了读取位置，并limit标记了多少字节，字符等被写入缓冲区,可以读取的字节数，字节数等限制。 12buf.flip(); 4. 从缓冲区读取数据有两种方法可以从Buffer中读取数据。 1.将数据从缓冲区读入通道。 1234//从缓冲区读入通道。int bytesWritten = inChannel.write（buf）; 2.使用其中一个get（）方法自己从缓冲区中读取数据。 123456byte[] dst = new byte[buf.limit()];buf.get(dst);System.out.println(new String(dst, 0, dst.length)); get的一些方法总结get() ：读取单个字节get(byte[] dst)：批量读取多个字节到 dst 中get(int index)：读取指定索引位置的字节(不会移动 position) 5. rewind()Buffer.rewind() 让 position 返回到0,这样你就可以重新读取缓冲区中的所有数据。在limit保持不变，因此仍然标记多少个元素（字节，字符等），可以从被读取Buffer。 6. clear（）和compact（）一旦你完成了读取数据，Buffer 准备好再次写入。你可以通过调用clear()或调用compact()。 如果调用clear（），则position将设置回0并且limit会变成capacity。, 换句话说，缓冲区被清除,但是缓冲区中的数据未被清除。, 只有markers告诉您可以将数据写入缓冲区的位置。 如果在调用clear（）时缓冲区中存在未读取的数据，那么数据将处于“forgotten”，这意味着不再有任何标记，指示已读取的数据以及尚未读取的数据。 如果Buffer中仍有未读数据，并且想稍后read，需要先写一些内容，调用compact（）而不是clear（）。 compact（）将所有未读数据复制到缓冲区的开始处。, 然后它将position设置在最后一个未读元素之后。, 极限属性仍然设置为容量，就像clear（）一样。, 现在缓冲区已准备好写入，但不会覆盖未读数据。 7. mark（）和reset（）可以通过调用Buffer.mark()方法在Buffer中标记给定的位置。然后可以通过调用该Buffer.reset() 方法将位置重新设置回标记的位置。 1234567891011121314151617181920212223242526272829303132 String str = "abcde";ByteBuffer buf = ByteBuffer.allocate(1024);buf.put(str.getBytes());buf.flip();byte[] dst = new byte[buf.limit()];buf.get(dst, 0, 2);System.out.println(new String(dst, 0, 2));System.out.println(buf.position());//mark() : 标记buf.mark();buf.get(dst, 2, 2);System.out.println(new String(dst, 2, 2));System.out.println(buf.position());//reset() : 恢复到 mark 的位置buf.reset();System.out.println(buf.position()); 8. equals（）和compareTo（）可以使用equals（）和compareTo（）来比较两个缓冲区 equals() 它们是相同的类型（byte，char，int等） 它们在缓冲区中具有相同数量的剩余字节，字符等。 所有剩余的字节，字符等是相等的。 正如你所看到的，equals只比较缓冲区的一部分，而不是它内部的每一个元素。, 实际上，它只是比较缓冲区中的其余元素。 compareTo() 该compareTo()方法比较两个缓冲区的其余元素（字节，字符等），用于例如排序例程。在下列情况下，缓冲区被认为比另一个缓冲区“小” 第一个元素等于另一个缓冲区中的对应元素，小于另一个缓冲区中的元素。 所有的元素都是相等的，但第一个缓冲区在第二个缓冲区之前耗尽元素（元素较少）。 直接与非直接缓冲区非直接缓冲区：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中。直接缓冲区：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率。 字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。 直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。 直接字节缓冲区还可以通过 FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建。该方法返回MappedByteBuffer 。 Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。 字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。非直接缓冲区：直接缓冲区： NIO通道(Channel) 概述通道（Channel）：由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。 通道和流的区别通道有点类似于流，但是还是有一些区别的： 流是单向的，或者输出流或是输入流，而通道是双向的。 通道可以被异步读取和写入。 通道始终读取或写入缓冲区。 总的来说可以把之前学习的的流想象成水流，数据通过水流去传输，或是往上流或者往下流（单向）。可以把通道想象成轨道，轨道本身不拥有数据，其中数据的传输是依靠火车（也就是缓冲区）来传输数据。并且双向都可。 Channel实现类 FileChannel：用于读取、写入、映射和操作文件的通道。 DatagramChannel：通过 UDP 读写网络中的数据通道。 SocketChannel：通过 TCP 读写网络中的数据。 ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 获取通道获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下： FileInputStream FileOutputStream RandomAccessFile DatagramSocket Socket ServerSocket 获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道。 将 Buffer 中数据写入 Channel 12//将Buffer中数据写入Channel中int bytesWritten = inChannel.write(buf); 从 Channel 读取数据到 Buffer 12//从Channel中读取数据到Bufferint bytesRead = inChannel.read(buf); 两个例子： 1.利用通道复制文件（非直接缓冲区）123456789101112131415161718192021222324252627282930313233public void test1() throws IOException &#123; FileInputStream fis = new FileInputStream ("d:/aa.mkv"); FileOutputStream fos = new FileOutputStream ("d:/11.mkv"); //1.获取通道 FileChannel fisChannel = fis.getChannel (); FileChannel fosChannel = fos.getChannel (); //2.分配指定大小缓冲区 ByteBuffer buffer = ByteBuffer.allocate (1024); //3.将同道中的数据存入缓冲区 while (fisChannel.read (buffer) != -1) &#123; buffer.flip ();//切换成读数据模式 //4.将缓冲区数据写入通道 fosChannel.write (buffer); buffer.clear ();//清空缓冲区 &#125; if (fosChannel != null) &#123; fosChannel.close (); &#125; if (fisChannel != null) &#123; fisChannel.close (); &#125; if (fos != null) &#123; fos.close (); &#125; if (fis != null) &#123; fis.close (); &#125;&#125; 2.利用直接缓冲区（只有ByteBuffer支持）完成文件的复制（内存映射文件） 123456789101112131415161718192021public void test2() throws IOException &#123; FileChannel inChannel = FileChannel.open(Paths.get("d:/aa.mkv"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get("d:/2.mkv"), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE); /* * StandardOpenOption.CREATE-----------&gt;不存在就创建，存在就覆盖 * StandardOpenOption.CREATE_NEW-----------&gt;不存在就创建，存在就报错 */ //内存映射文件 MappedByteBuffer inMappedBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMappedBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size()); //直接对缓冲区进行读写操作 byte[] dst = new byte[inMappedBuf.limit()]; inMappedBuf.get(dst); outMappedBuf.put(dst); inChannel.close(); outChannel.close(); &#125; 分散(Scatter)和聚集(Gather)分散读取（Scattering Reads）分散读取（Scattering Reads）是指从 Channel 中读取的数据“分散” 到多个 Buffer 中.具体代码参考下例： 注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满 聚集写入(Gathering Writers)聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。按照顺序写入通道中。 1234567891011121314151617181920212223public void test4() throws IOException &#123; RandomAccessFile file = new RandomAccessFile ("aa.txt", "rw"); //获取通道 FileChannel channel = file.getChannel (); //分配指定大小缓冲区 ByteBuffer buffer = ByteBuffer.allocate (100); ByteBuffer buffer1 = ByteBuffer.allocate (1024); //分散读取 ByteBuffer[] buf = &#123;buffer, buffer1&#125;; channel.read (buf); for (ByteBuffer byteBuffer : buf) &#123; byteBuffer.flip (); &#125; System.out.println (new String (buf[0].array (), 0, buf[0].limit ())); System.out.println ("--------------------------------------------------------"); System.out.println (new String (buf[1].array (), 0, buf[1].limit ())); //聚集写入 RandomAccessFile rw = new RandomAccessFile ("hy.txt", "rw"); FileChannel channel1 = rw.getChannel (); channel1.write (buf); &#125; 字符集（CharSet）编码：字符串 —-&gt;字符数组。解码：字符数组—-&gt;字符串。首先常见的字符集有UTF-8和GBK。解码有一个思想，就是用什么编码， 用什么解码，就不会乱码。出现乱码肯定是因为编码和解码的码制不一样。 首先了解都有什么码制,Charset就是java中码制的类。 1234567public void test5() &#123; SortedMap&lt;String, Charset&gt; stringCharsetSortedMap = Charset.availableCharsets (); Set&lt;Map.Entry&lt;String, Charset&gt;&gt; entries = stringCharsetSortedMap.entrySet (); for (Map.Entry&lt;String, Charset&gt; entry : entries) &#123; System.out.println (entry.getKey () + "---" + entry.getValue ()); &#125; &#125; 用NIO实现编码和解码 这个就是先用GBK进行编码和解码。没有乱码问题，但是用UTF-8进行解码。就出现了乱码。所以说，解决乱码的根本途径就是编码和解码一致。123456789101112131415161718192021222324252627282930public void test6() throws CharacterCodingException &#123; Charset gbk = Charset.forName ("GBK"); //获取编码器 CharsetEncoder ce = gbk.newEncoder (); //获取解码器 CharsetDecoder cd = gbk.newDecoder (); CharBuffer allocate = CharBuffer.allocate (1024); allocate.put ("爱生活爱java"); allocate.flip (); //编码 ByteBuffer encode = ce.encode (allocate); for (int i = 0; i &lt; 12; i++) &#123; System.out.println (encode.get ()); &#125; //解码 encode.flip (); CharBuffer decode = cd.decode (encode); System.out.println (decode.toString ()); System.out.println ("------------------------"); encode.flip (); Charset utf = Charset.forName ("UTF-8"); CharBuffer decode1 = utf.decode (encode); System.out.println (decode1.toString ()); &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql必知必会（连接，查询，排序）]]></title>
    <url>%2F2018%2F06%2F10%2FMysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%EF%BC%88%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%A3%80%E7%B4%A2%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Mysql必知必会（连接，检索，排序）分别对应Mysql必知必会3,4,5章节的内容。下面做简单的示例。 连接数据库和进入 连接数据123456mysql -u ben //以ben用户进入数据库 mysql -uroot -proot -h localhost -P 3306 //以root用户，root密码，本地ip，端口号3306进入mysql。mysql -uroot -proot //默认本地，3306登录。 登录成功页面： 选择数据库 SHOW DATABASES; //显示所有表空间1234567891011121314151617mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || demo || exam || how2java || jh || magic || mysql || performance_schema || root || ssh || test |+--------------------+11 rows in set (0.00 sec) USE jh //使用jh数据库表空间 12mysql&gt; use jh;Database changed show tables; //显示jh数据库中有哪些表123456789101112131415mysql&gt; show tables;+--------------+| Tables_in_jh |+--------------+| category || customers || knowledge || orderitems || orders || productnotes || products || user || vendors |+--------------+9 rows in set (0.00 sec) SHOW COLUMNS FROM customers//查看表结构123456789101112131415mysql&gt; SHOW COLUMNS FROM customers;+--------------+-----------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------------+-----------+------+-----+---------+----------------+| cust_id | int(11) | NO | PRI | NULL | auto_increment || cust_name | char(50) | NO | | NULL | || cust_address | char(50) | YES | | NULL | || cust_city | char(50) | YES | | NULL | || cust_state | char(5) | YES | | NULL | || cust_zip | char(10) | YES | | NULL | || cust_country | char(50) | YES | | NULL | || cust_contact | char(50) | YES | | NULL | || cust_email | char(255) | YES | | NULL | |+--------------+-----------+------+-----+---------+----------------+9 rows in set (0.01 sec) 其实还有一些数据库的show语句： SHOW STATUS; //显示服务器状态 SHOW CREATE DATABASE || SHOW CREATE TABLE; //显示特定数据库或表的语句 SHOW GRANTS; //显示授权用户的安全权限 SHOW ERROR || SHOW WARNINGS; //显示服务器错误和警告 DESC product;查看表结构1234567891011mysql&gt; DESC products;+------------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+------------+--------------+------+-----+---------+-------+| prod_id | char(10) | NO | PRI | NULL | || vend_id | int(11) | NO | MUL | NULL | || prod_name | char(255) | NO | | NULL | || prod_price | decimal(8,2) | NO | | NULL | || prod_desc | text | YES | | NULL | |+------------+--------------+------+-----+---------+-------+5 rows in set (0.01 sec) 数据库的查询select语句是用来从数据库中查询的语句，也是最重要的语句。简单的说一下sql语句的一些要求: 结束sql语句，用(;)号隔开；多条语句也是。 SQL语句不区分大小写，但是尽量在SQL关键字的时候使用大写，便于阅读和区分。 处理SQL语句的时候，其中所有的空格都被忽略，可以把所有语句写在一行，但是便于阅读，尽量分行写。检索单个列 SELECT prod_name FROM products; 这个语句就是检索products中的 prod_name 这一列。12345678910111213141516171819+----------------+| prod_name |+----------------+| .5 ton anvil || 1 ton anvil || 2 ton anvil || Detonator || Bird seed || Carrots || Fuses || JetPack 1000 || JetPack 2000 || Oil can || Safe || Sling || TNT (1 stick) || TNT (5 sticks) |+----------------+14 rows in set (0.00 sec) 检索多个列 select prod_id,prod_name,prod_price from products; 这个语句就是检索products中的 prod_name,prod_name,prod_price 三列。1234567891011121314151617181920mysql&gt; select prod_id,prod_name,prod_price from products;+---------+----------------+------------+| prod_id | prod_name | prod_price |+---------+----------------+------------+| ANV01 | .5 ton anvil | 5.99 || ANV02 | 1 ton anvil | 9.99 || ANV03 | 2 ton anvil | 14.99 || DTNTR | Detonator | 13.00 || FB | Bird seed | 10.00 || FC | Carrots | 2.50 || FU1 | Fuses | 3.42 || JP1000 | JetPack 1000 | 35.00 || JP2000 | JetPack 2000 | 55.00 || OL1 | Oil can | 8.99 || SAFE | Safe | 50.00 || SLING | Sling | 4.49 || TNT1 | TNT (1 stick) | 2.50 || TNT2 | TNT (5 sticks) | 10.00 |+---------+----------------+------------+14 rows in set (0.00 sec) 检索所有列这个使用了通配符（*），这个代表所有的意思。 select * from products; 检索products的所有信息。1234567891011121314151617181920mysql&gt; select * from products;+---------+---------+----------------+------------+----------------------------------------------------------------+| prod_id | vend_id | prod_name | prod_price | prod_desc |+---------+---------+----------------+------------+----------------------------------------------------------------+| ANV01 | 1001 | .5 ton anvil | 5.99 | .5 ton anvil, black, complete with handy hook || ANV02 | 1001 | 1 ton anvil | 9.99 | 1 ton anvil, black, complete with handy hook and carrying case || ANV03 | 1001 | 2 ton anvil | 14.99 | 2 ton anvil, black, complete with handy hook and carrying case || DTNTR | 1003 | Detonator | 13.00 | Detonator (plunger powered), fuses not included || FB | 1003 | Bird seed | 10.00 | Large bag (suitable for road runners) || FC | 1003 | Carrots | 2.50 | Carrots (rabbit hunting season only) || FU1 | 1002 | Fuses | 3.42 | 1 dozen, extra long || JP1000 | 1005 | JetPack 1000 | 35.00 | JetPack 1000, intended for single use || JP2000 | 1005 | JetPack 2000 | 55.00 | JetPack 2000, multi-use || OL1 | 1002 | Oil can | 8.99 | Oil can, red || SAFE | 1003 | Safe | 50.00 | Safe with combination lock || SLING | 1003 | Sling | 4.49 | Sling, one size fits all || TNT1 | 1003 | TNT (1 stick) | 2.50 | TNT, red, single stick || TNT2 | 1003 | TNT (5 sticks) | 10.00 | TNT, red, pack of 10 sticks |+---------+---------+----------------+------------+----------------------------------------------------------------+14 rows in set (0.00 sec) 检索不同行比如我们要查询的数据中，有多个重复的数据，我们只想要不同的数据。 select vend_id from products; 1234567891011121314151617181920mysql&gt; select vend_id from products;+---------+| vend_id |+---------+| 1001 || 1001 || 1001 || 1002 || 1002 || 1003 || 1003 || 1003 || 1003 || 1003 || 1003 || 1003 || 1005 || 1005 |+---------+14 rows in set (0.00 sec) 很明显很多数据是无用的。我们现在要来剔除这些重复。我们要使用这个关键字：distinct；要注意的是不能同时使用distinct限制多行， select distinct vend_id，prod_price from products; select distinct vend_id from products;除非两列都相同，否则都会被查出来。 12345678910mysql&gt; select distinct vend_id from products;+---------+| vend_id |+---------+| 1001 || 1002 || 1003 || 1005 |+---------+4 rows in set (0.00 sec) 限制结果(分页) select prod_name from products limit 0,5; 1234567891011mysql&gt; select prod_name from products limit 0,5;+--------------+| prod_name |+--------------+| .5 ton anvil || 1 ton anvil || 2 ton anvil || Detonator || Bird seed |+--------------+5 rows in set (0.00 sec) 其中 0是开始位置，5是显示长度。 数据排序排序数据 select prod_name from products order by prod_name; 把查询到的数据按照prod_name排序。1234567891011121314151617181920mysql&gt; select prod_name from products order by prod_name;+----------------+| prod_name |+----------------+| .5 ton anvil || 1 ton anvil || 2 ton anvil || Bird seed || Carrots || Detonator || Fuses || JetPack 1000 || JetPack 2000 || Oil can || Safe || Sling || TNT (1 stick) || TNT (5 sticks) |+----------------+14 rows in set (0.00 sec) 多个序列排序 select prod_id,prod_price,prod_name from products order by prod_price,prod_name; 这个例子其实要这样子理解，就是只有在prod_price有相同的情况下，然后取按照prod_name排序。 1234567891011121314151617181920mysql&gt; select prod_id,prod_price,prod_name from products order by prod_price,prod_name;+---------+------------+----------------+| prod_id | prod_price | prod_name |+---------+------------+----------------+| FC | 2.50 | Carrots || TNT1 | 2.50 | TNT (1 stick) || FU1 | 3.42 | Fuses || SLING | 4.49 | Sling || ANV01 | 5.99 | .5 ton anvil || OL1 | 8.99 | Oil can || ANV02 | 9.99 | 1 ton anvil || FB | 10.00 | Bird seed || TNT2 | 10.00 | TNT (5 sticks) || DTNTR | 13.00 | Detonator || ANV03 | 14.99 | 2 ton anvil || JP1000 | 35.00 | JetPack 1000 || SAFE | 50.00 | Safe || JP2000 | 55.00 | JetPack 2000 |+---------+------------+----------------+14 rows in set (0.00 sec) 正序，倒序 select prod_id,prod_price,prod_name from products order by prod_price DESC; 其中DESC是倒序的意思，升序就是ASC，但是ASC没有多大作用，因为默认就是ASC的1234567891011121314151617181920mysql&gt; select prod_id,prod_price,prod_name from products order by prod_price DESC;+---------+------------+----------------+| prod_id | prod_price | prod_name |+---------+------------+----------------+| JP2000 | 55.00 | JetPack 2000 || SAFE | 50.00 | Safe || JP1000 | 35.00 | JetPack 1000 || ANV03 | 14.99 | 2 ton anvil || DTNTR | 13.00 | Detonator || TNT2 | 10.00 | TNT (5 sticks) || FB | 10.00 | Bird seed || ANV02 | 9.99 | 1 ton anvil || OL1 | 8.99 | Oil can || ANV01 | 5.99 | .5 ton anvil || SLING | 4.49 | Sling || FU1 | 3.42 | Fuses || FC | 2.50 | Carrots || TNT1 | 2.50 | TNT (1 stick) |+---------+------------+----------------+14 rows in set (0.00 sec) 排序小结排序是不区分大小写的，对于sql语句来说，A和a的一样的。其实可以用order by 和 limit混合来使用。比如，查询最高价格。 select * from products order by prod_price DESC limit 1; 1234567mysql&gt; select * from products order by prod_price DESC limit 1;+---------+---------+--------------+------------+-------------------------+| prod_id | vend_id | prod_name | prod_price | prod_desc |+---------+---------+--------------+------------+-------------------------+| JP2000 | 1005 | JetPack 2000 | 55.00 | JetPack 2000, multi-use |+---------+---------+--------------+------------+-------------------------+1 row in set (0.00 sec)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解SQL]]></title>
    <url>%2F2018%2F06%2F10%2FMysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%EF%BC%881%2C2%E7%AB%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[了解SQL1.DBMS数据库管理系统 数据库（database） 保存有组织的数据容器。DBMS是操纵和创建数据库的软件，不能直接访问数据库，是通过DBMS去访问。 表（table） 某种特定类型数据的结构化清单。一个结构化的文件，用来存储某种特定类型的数据。 模式（schema） 关于数据库和表的布局以及特征的信息 列（column） 表中的一个字段。所有的表都是由多个或一个列组成的。可以把它想象成一个网格，网格中每个列存储着一条特定的信息。 数据类型（datatype） 所容许的数据类型，它限制列中存储的数据。 行（row） 表中的一个记录。表中的行数也为记录的总数。 主键（primary key） 一列（或一组列），其值能够唯一区分表中的每个行。 ++主键的规范++： 任意两行都不能具有相同的主键值。每个行都必须具有一个主键值（主键不允许为NULL）。 2.什么是SQL?SQL是结构化查询语言（Structured Query Language），是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。SQL的优点： SQL不是某个特定的数据库专用的语言，几乎所有的DBMS都支持SQL。 SQL简单易学，语句描述性很强。 SQL看上去很简单，但是是一个强有力的语言，可以进行很复杂的数据库操作。 3.MySQL简述 MySQL是一个小型关系型数据库管理系统，开发者为瑞典MySQL AB公司，现在已经被Sun公司收购，支持FreeBSD、Linux、MAC、Windows等多种操作系统与其他的大型数据库例如Oracle、DB2、SQL Server等相比功能稍弱一些。其特点有： 1、可以处理拥有上千万条记录的大型数据； 2、支持常见的SQL语句规范； 3、可移植行高，安装简单小巧； 4、良好的运行效率，有丰富信息的网络支持； 5、调试、管理，优化简单（相对其他大型数据库）。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap的源码解析]]></title>
    <url>%2F2018%2F06%2F08%2Fhashmap%2F</url>
    <content type="text"><![CDATA[HashMap的源码解析HashMap的概述HashMap是常用的Java集合之一，是基于哈希表的Map接口的实现。由于HashMap不是线程安全的，如果想要线程安全，可以使用ConcurrentHashMap代替。 API里面给的解释是： 基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 HashMap的继承体系我们要了解一个类，首先要了解一下他的继承结构，，才能更好的理解这个类。 123public class HashMap&lt;K,V&gt;extends AbstractMap&lt;K,V&gt;implements Map&lt;K,V&gt;,Cloneable, Serializable 我们可以看一下继承图。这里我们要注意HashMap和Hashtable的继承是不一样的，Hashtable继承的是Dictionary。 大概介绍一下HashMap和Hashtable， HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 HashMap的数据结构从结构实现来讲，HashMap 是数组+链表+红黑树给大家一个图可以更加直观的了解其结构 我们其实还要想，到底是在底层是怎样存储的？为什么这样存，或者说有什么优点？ 我们能从上图看出来，首先是一个数组的存储,查看源码可知，有一个很重要的数组，Node&lt;K,V&gt;[] table，很明显，它是一个Node数组，我们来看一下Node的结构。123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个节点 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 2.HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：1hs.put(1,&quot;magic&quot;); 系统将调用”1”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。不会都加到一个下标下面的链表去。保证每一个的分散性、均匀性。要做到雨露均沾。 如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。 那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的==Hash算法==和==扩容机制==。 在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：1234int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子 int modCount; int size; 12345678910111213141516171819202122在 HashMap 中定义了几个常量:static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64; 依次解释一下上面的变量：1. DEFAULT_INITIAL_CAPACITY: 初始容量，也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。2. MAXIMUM_CAPACITY:哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。3. DEFAULT_LOAD_FACTOR:默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。4. TREEIFY_THRESHOLD:上文说过，如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于 8 时，有可能会转化成树。5. UNTREEIFY_THRESHOLD:在哈希表扩容时，如果发现链表长度小于 6，则会由树重新退化为链表。6. MIN_TREEIFY_CAPACITY:在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。 首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，++扩容后的HashMap容量是之前容量的两倍++。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 size这个字段其实很好理解，就是HashMap中实际存在的键值对数量（数组中现有的元素）。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。 在HashMap中，++哈希桶数组table的长度length大小必须为2的n次方(一定是合数)++，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考http://blog.csdn.net/liuqiyao_01/article/details/14475159，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，==在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。==而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考http://blog.csdn.net/v_july_v/article/details/6105630。 HashMap的功能实现-方法HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。 1. 确定哈希桶数组索引位置不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):12345678910111213141516方法一：static final int hash(Object key) &#123; //jdk1.8 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;//jdk1.7static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125;方法二：static int indexFor(int h, int length) &#123; //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算&#125; 这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。 这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。下面举例说明下，n为table的长度。 2. 分析HashMap的put方法HashMap的put方法执行过程可以通过下图来理解.①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； ②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； ③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； ④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； ⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； ⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public V put(K key, V value) &#123; // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true); &#125; //从put()进入putVal(hash(key), key, value, false, true)；final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 步骤①：tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤②：计算index，并对null做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 步骤③：节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 步骤④：判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 步骤⑤：该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //链表长度大于8转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // key已经存在直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 步骤⑥：超过最大容量 就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 3. 扩容机制扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。 我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。12345678910111213void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 &#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。1234567891011121314151617void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，++所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。++看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，++由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。++有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold初始容量被放入阈值 newCap = oldThr; else &#123; // zero initial threshold signifies using defaults零初始阈值表示使用默认值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order 链表优化重hash的代码块 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 线程安全性(待深入)在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)： 1234567891011121314151617181920public class HashMapInfiniteLoop &#123; private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f); public static void main(String[] args) &#123; map.put(5， &quot;C&quot;); new Thread(&quot;Thread1&quot;) &#123; public void run() &#123; map.put(7, &quot;B&quot;); System.out.println(map); &#125;; &#125;.start(); new Thread(&quot;Thread2&quot;) &#123; public void run() &#123; map.put(3, &quot;A); System.out.println(map); &#125;; &#125;.start(); &#125; &#125; 其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。 通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。 线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。 JDK1.8与JDK1.7的性能对比HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。 Hash较均匀的情况为了便于测试，我们先写一个类Key，如下： 123456789101112131415161718192021222324252627class Key implements Comparable&lt;Key&gt; &#123; private final int value; Key(int value) &#123; this.value = value; &#125; @Override public int compareTo(Key o) &#123; return Integer.compare(this.value, o.value); &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Key key = (Key) o; return value == key.value; &#125; @Override public int hashCode() &#123; return value; &#125;&#125; 这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下： 123456789101112131415public class Keys &#123; public static final int MAX_KEY = 10_000_000; private static final Key[] KEYS_CACHE = new Key[MAX_KEY]; static &#123; for (int i = 0; i &lt; MAX_KEY; ++i) &#123; KEYS_CACHE[i] = new Key(i); &#125; &#125; public static Key of(int value) &#123; return KEYS_CACHE[value]; &#125;&#125; 现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下： 1234567891011121314151617181920static void test(int mapSize) &#123; HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize); for (int i = 0; i &lt; mapSize; ++i) &#123; map.put(Keys.of(i), i); &#125; long beginTime = System.nanoTime(); //获取纳秒 for (int i = 0; i &lt; mapSize; i++) &#123; map.get(Keys.of(i)); &#125; long endTime = System.nanoTime(); System.out.println(endTime - beginTime); &#125; public static void main(String[] args) &#123; for(int i=10;i&lt;= 1000 0000;i*= 10)&#123; test(i); &#125; &#125; 在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下： 通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。 Hash极不均匀的情况假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：123456789class Key implements Comparable&lt;Key&gt; &#123; //... @Override public int hashCode() &#123; return 1; &#125;&#125; 仍然执行main方法，得出的结果如下表所示：从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。 测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。 小结(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。 (2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。 (3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。 (4) JDK1.8引入红黑树大程度优化了HashMap的性能。 (5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于String的理解]]></title>
    <url>%2F2018%2F06%2F07%2F%E5%85%B3%E4%BA%8EString%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[关于下面的代码，为什么结果为true？在我们的想法里，String是一个引用类型，为什么对象可以相等？12345678910111213141516package cn.lq.demo;public class StringDemo &#123; /** * @author magic_jh * @version 1.1.0 */ public static void main(String[] args) &#123; String s1="helloworld"; String s2="helloworld"; String s3=new String("helloworld"); System.out.println(s1==s2);//true System.out.println(s1==s3);//false &#125;&#125; 其实可以看一下内存的分配，就一目了然了。 从图中可以看出其实s1和s2指向的不是堆内存，而是方法区的字符常量池，所以我们知道==比的是地址值，s1,s2指向的是同一个地址，肯定结果为true。我们现在来看s3，s3使用的是构造方法，它就在堆内存开辟了一个空间，其中的”helloworld”还是来自于字符常量池。所以s3指向的是堆内存中的地址，最后与s1比较的是s3指向的地址是堆内存的地址，所以为false。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的操作示例]]></title>
    <url>%2F2018%2F06%2F06%2Fjh0904%2F</url>
    <content type="text"><![CDATA[magic_jh第一次测试三级标题 列表1 列表2 a子列表 b子列表 c子列表 列表3 列表4 jh 字体是斜体 字体加粗 123public static void main(String[] args)&#123;asdas&#125; 我的内容是引用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vector的源码解析]]></title>
    <url>%2F2018%2F06%2F06%2FVector%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Vector源码解析1. Vector概述及继承体系Vector 类可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。与新 collection 实现不同，Vector 是同步的。 看一下Vector的继承体系：12public class Vector&lt;E&gt;extends AbstractList&lt;E&gt;implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable RandomAccess接口是在源码中的注释如下： Marker interface used by List implementations to indicate that theysupport fast (generally constant time) random access. 翻译下就是：这是一个标记性的接口，谁实现了这个接口就表明他具有快速随机访问的能力。 2. Vector属性capacityIncrement：自动扩容的大小，即当数组满了之后，就添加capacityIncrement个空间装载元素，如果capacityIncrement&lt;=0,则扩容时就扩容到目前Vector容量的两倍。 elementCount:记录数组中数据的个数。 elementData:数组，因为Vector底层也是数组存储的，所以用这个来存储数据。 123protected int capacityIncrement; //扩容大小protected int elementCount; //数组数据条数protected Object[] elementData; //数组 3. Vector构造方法 Vector构造方法有四个构造方法 3.1.Vector()构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。123public Vector() &#123; this(10);//这里的this调用的是Vector(int initialCapacity) 方法 &#125; 3.2.Vector(Collection &lt;\?extends E&gt; c)构造一个包含指定 collection 中的元素的向量，这些元素按其 collection 的迭代器返回元素的顺序排列。123456789 public Vector(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) //c.toArray可能（不正确）不返回Object []（参见6260652） if (elementData.getClass() != Object[].class)`````` elementData = Arrays.copyOf(elementData, elementCount, Object[].class); //用Arrays.copyOf()方法转换类型。 &#125; 3.3.Vector(int initialCapacity)使用指定的初始容量和等于零的容量增量构造一个空向量。123public Vector(int initialCapacity) &#123; this(initialCapacity, 0);//这里的this其实调用的是Vector(int initialCapacity, int capacityIncrement)方法 &#125; 3.4.Vector(int initialCapacity, int capacityIncrement) 我们从前面知道，无参构造和单参构造本质上都调用的是这个方法。我们来具体了解一下。使用指定的初始容量和容量增量构造一个空的向量。1234567891011//initialCapacity指的是初始容量。//capacityIncrement指的是扩容容量。 public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity]; //从这里可以看出Vector底层也是数组实现的。 this.capacityIncrement = capacityIncrement; &#125; 4. Vector常用方法 4.1.Vector最初的方法 a.addElement(E obj)将指定的组件添加到此向量的末尾，将其大小增加 1。如果向量的大小比容量大，则增大其容量。 12345public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; &#125; 从addElement方法中有ensureCapacityHelper(elementCount + 1);我们大致可以推测出这一步是用来扩容的。接着看这个方法：12345 private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code检测是否大于数组长度 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 123456789101112131415 private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); //注意：这是和ArrayList不同的地方，这个的自动扩容是直接增加一个oldCapacity，也就是扩大了一倍。 /*第一个判断是怕扩容的数组长度还是太小，就用minCapacity 来进行对数组的扩张。第二个判断是如果扩张1倍太大或者是我们所需的空间大小minCapacity太大，则进行Integer.MAX_VALUE来进行扩张。*/ if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125; 2.elementAt(int index)返回指定索引处的组件。 其实这个方法就是和我们之前使用的get方法很相似。源码很简单，就是说先进行一个index的有效位检验，如果正确在进入elementData(int index)方法，直接取数组的数据。1234567891011 public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; return elementData(index); &#125;//---------------------------------------------E elementData(int index) &#123; return (E) elementData[index]; &#125; 3. elements()返回此向量的组件的枚举。返回的 Enumeration 对象将生成此向量中的所有项。生成的第一项为索引 0 处的项，然后是索引 1 处的项，依此类推。其实我们仔细观察就可以发现，这个和我们之前遍历时候用的Iterator很相似。123456789101112131415161718public Enumeration&lt;E&gt; elements() &#123; return new Enumeration&lt;E&gt;() &#123; int count = 0; public boolean hasMoreElements() &#123; return count &lt; elementCount; &#125; public E nextElement() &#123; synchronized (Vector.this) &#123; if (count &lt; elementCount) &#123; return elementData(count++); &#125; &#125; throw new NoSuchElementException("Vector Enumeration"); &#125; &#125;; &#125; Enumeration是一个接口，直接在方法里面实现。从中我们可以看到hasMoreElements（）和nextElement（）方法。下来举个例子来体会一下。12345678910111213141516171819public static void main(String[] args) &#123; /* * 对Vector的一个简单使用 * */ Vector v=new Vector (); v.addElement ("hello"); //--------------&gt;add() v.addElement ("world"); v.addElement ("java"); System.out.println (v.elementAt (1));//下标从0开始 //--------------&gt;get() System.out.println ("-----------------"); Enumeration elements = v.elements (); //--------------&gt;Iterator() while (elements.hasMoreElements ())&#123; //--------------&gt;hasNext() Object o = elements.nextElement (); //--------------&gt;next() System.out.println (o); &#125; &#125; 4.2.Vector JDK1.2之后的方法 JDK1.2之后出来的方法，为什么有之前的方法还要再加入新方法？ JDK1.2升级的原因无非有三个：1.安全问题2.效率问题3.简化书写 1.add 添加元素的方法实现比较简单：直接在数组的后一个位置添加即可，不过在添加元素之前需要检查数组中是否已满，如果已满，则扩容。 123456789101112131415161718192021222324252627282930313233343536 //添加一个元素到末尾，数组长度+1public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; &#125; //添加一个元素到指定位置。public void add(int index, E element) &#123; insertElementAt(element, index); &#125;/*insertElementAt()方法，先进行有效位检验，然后在使用ensureCapacityHelper更改数组长度+1，在使用System.arraycopy()方法，这个方法的具体解析，可以去看ArrayList的源码，里面有分析。*/public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt; " + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++; &#125; // public synchronized boolean addAll(Collection&lt;? extends E&gt; c) &#123; modCount++; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); System.arraycopy(a, 0, elementData, elementCount, numNew); elementCount += numNew; return numNew != 0; &#125; 2.get 返回向量中指定位置的元素。 先进行有效位检验，直接从数组取相应下标元素。类似于elementAt（int index） 123456public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index); &#125; set4用指定的元素替换此向量中指定位置处的元素。 Vector底层使用的是数组，所以这就相当于对数组的操作。先进行有效位检验，然后把指定下标的元素改成element。 12345678public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; 4.remove remove方法其实和ArrayList里面的方法区别不大。我们主要来看两个方法就可以了。 4.4.1.remove(int index) 先进行有效位检测，然后取出index下标的元素，在计算index元素之后的长度，最后使用 System.arraycopy()直接把index位置跳过，再把elementData[]最后一位元素置为null,让垃圾回收器将其回收。1234567891011121314public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return oldValue; &#125; 4.4.2.remove(Object o) 删除指定元素。其实这个也特别简单，remove(Object o)底层调用了removeElement(o)方法。removeElement(o)的实现就是先把当前元素的位置下标取出来，然后有了下标就可以使用remove(int index)方法了。12345678910111213public boolean remove(Object o) &#123; return removeElement(o); &#125;//-------------------------------- public synchronized boolean removeElement(Object obj) &#123; modCount++; int i = indexOf(obj); if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false; &#125; 5. 总结Vector里面是基于数组来实现的需要注意的是：Vector是线程安全的，因此，在多线程并发中是不需要使用额外同步的，而ArrayList实现基本与Vector一样，但是区别是：ArrayList是线程不安全的，在多线程并发时，需要我们进行额外的同步。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
      </tags>
  </entry>
</search>
