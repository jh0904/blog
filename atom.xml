<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>magic</title>
  
  <subtitle>jh</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-04T12:32:58.992Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>magic_jh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础之IO这个硬骨头（二）</title>
    <link href="http://yoursite.com/2018/08/04/Java%E5%9F%BA%E7%A1%80%E4%B9%8BIO%E8%BF%99%E4%B8%AA%E7%A1%AC%E9%AA%A8%E5%A4%B4%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/04/Java基础之IO这个硬骨头（二）/</id>
    <published>2018-08-04T12:32:19.000Z</published>
    <updated>2018-08-04T12:32:58.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><p>上一次基本讲解了一下IO中字节流的一些知识点和操作，总的来说字符流的操作和字节流差不多，关键在于编码集的一些问题。这篇文章就主要讲解java中字符流和字符集。</p><h3 id="字符集的操作"><a href="#字符集的操作" class="headerlink" title="字符集的操作"></a>字符集的操作</h3><h4 id="字符集是什么尼？"><a href="#字符集是什么尼？" class="headerlink" title="字符集是什么尼？"></a>字符集是什么尼？</h4><p>字符集就是是各种文字和符号的总称，简单来说就是由字符和对应的数值组成的一张表。 推荐一篇文章    <a href="https://blog.csdn.net/qq_28098067/article/details/53486032" target="_blank" rel="noopener">字符集详解（一看就懂系列）</a> ，这篇文章详细的介绍了字符集的一些知识，以及字符集的演变。</p><h4 id="常见的字符集："><a href="#常见的字符集：" class="headerlink" title="常见的字符集："></a>常见的字符集：</h4><p>下面用一个图片来解释一下简单的字符集：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-4/87471290.jpg" alt=""><br>这张图介绍了常用的字符集。</p><h4 id="java中的CharSet"><a href="#java中的CharSet" class="headerlink" title="java中的CharSet"></a>java中的CharSet</h4><p>这些知识使我们从网上查到的，我们在代码中如何知道有什么字符集尼？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    SortedMap&lt;String, Charset&gt; stringCharsetSortedMap = Charset.availableCharsets ();  </span><br><span class="line">   Set&lt;Map.Entry&lt;String, Charset&gt;&gt; entries = stringCharsetSortedMap.entrySet ();  </span><br><span class="line"> <span class="keyword">for</span> (Map.Entry&lt;String, Charset&gt; entry : entries) &#123;  </span><br><span class="line">        System.out.println (entry.getKey () + <span class="string">"---"</span> \+ entry.getValue ());  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这样，我们可以查找出所有的字符集。</p><h4 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h4><p>对于大多数程序猿来说，乱码都是经常发生的事情，但是为什么会乱码？<br>其实这个问题很简单，就像上面编码表的那张图片一样，就是因为编码和解码用的码制不一样，大家可以看下面的例子，用GBK进行编码，用GBK解码，就可以解码出数据，但是使用UTF-8进行数据的解码，就出现问题，此时的数据就成了乱码，我们就无法解析了。<br>所以说，只要编码和解码的码制一样，就不会乱码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Test  </span><br><span class="line">public <span class="keyword">void</span> test6() throws CharacterCodingException &#123;  </span><br><span class="line">    Charset gbk = Charset.forName (<span class="string">"GBK"</span>);  </span><br><span class="line">   <span class="comment">//获取编码器  </span></span><br><span class="line">   CharsetEncoder ce = gbk.newEncoder ();  </span><br><span class="line">   <span class="comment">//获取解码器  </span></span><br><span class="line">   CharsetDecoder cd = gbk.newDecoder ();  </span><br><span class="line">  </span><br><span class="line">   CharBuffer allocate = CharBuffer.allocate (<span class="number">1024</span>);  </span><br><span class="line">   allocate.put (<span class="string">"爱生活爱java"</span>);  </span><br><span class="line">   allocate.flip ();  </span><br><span class="line">   <span class="comment">//编码  </span></span><br><span class="line">   ByteBuffer encode = ce.encode (allocate);  </span><br><span class="line"> <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;  </span><br><span class="line">        System.out.println (encode.get ());  </span><br><span class="line">   &#125;  </span><br><span class="line">    <span class="comment">//解码  </span></span><br><span class="line">   encode.flip ();  </span><br><span class="line">   CharBuffer decode = cd.decode (encode);  </span><br><span class="line">   System.out.println (decode.toString ());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   System.out.println (<span class="string">"------------------------"</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   encode.flip ();  </span><br><span class="line">   Charset utf = Charset.forName (<span class="string">"UTF-8"</span>);  </span><br><span class="line">   CharBuffer decode1 = utf.decode (encode);  </span><br><span class="line">   System.out.println (decode1.toString ());  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="字符流的基本操作"><a href="#字符流的基本操作" class="headerlink" title="字符流的基本操作"></a>字符流的基本操作</h3><p>上面介绍了编码的一些知识点，之所以解释这个是因为字符流其实就是编码表加上字节流，下来介绍字符流的操作吧。</p><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>转换流是什么尼？其实因为字节流处理中文不是很方便，有时候需要字符流处理文字，所以出现了转换流。转换流的作用就是把一个字节流转换成一个字符流。</p><p>转换流其实本质上就是一个字节流加上编码表</p><p>InputStreamReader代码展示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InputStreamReader(InputStream is):用默认的编码读取数据</span></span><br><span class="line"><span class="comment"> * InputStreamReader(InputStream is,String charsetName):用指定的编码读取数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="comment">// InputStreamReader isr = new InputStreamReader(new FileInputStream(</span></span><br><span class="line"><span class="comment">// "osw.txt"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InputStreamReader isr = new InputStreamReader(new FileInputStream(</span></span><br><span class="line"><span class="comment">// "osw.txt"), "GBK");</span></span><br><span class="line"></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(</span><br><span class="line"><span class="string">"osw.txt"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 一次读取一个字符</span></span><br><span class="line">int ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((ch = isr.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">System.out.print((char) ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">isr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OutputStreamWriter代码展示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OutputStreamWriter(OutputStream out):根据默认编码把字节流的数据转换为字符流</span></span><br><span class="line"><span class="comment"> * OutputStreamWriter(OutputStream out,String charsetName):根据指定编码把字节流数据转换为字符流</span></span><br><span class="line"><span class="comment"> * 把字节流转换为字符流。</span></span><br><span class="line"><span class="comment"> * 字符流 = 字节流 +编码表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamWriterDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="comment">// OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(</span></span><br><span class="line"><span class="comment">// "osw.txt")); // 默认GBK</span></span><br><span class="line"><span class="comment">// OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(</span></span><br><span class="line"><span class="comment">// "osw.txt"), "GBK"); // 指定GBK</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line"><span class="string">"osw.txt"</span>), <span class="string">"UTF-8"</span>); <span class="comment">// 指定UTF-8</span></span><br><span class="line"><span class="comment">// 写数据</span></span><br><span class="line">osw.write(<span class="string">"中国"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">osw.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>其实我们怎么创建一个字符流尼，其实上面的转换流就可以帮我们完成这个需求。但是，每次创建字符流都要先创建一个字节流，感觉很麻烦，所以就有这个流的出现—&gt;FileWriter/FileReaderd，接下来介绍一下具体的代码实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由于我们常见的操作都是使用本地默认编码，所以，不用指定编码。</span></span><br><span class="line"><span class="comment"> * 而转换流的名称有点长，所以，Java就提供了其子类供我们使用。</span></span><br><span class="line"><span class="comment"> * OutputStreamWriter = FileOutputStream + 编码表(GBK)</span></span><br><span class="line"><span class="comment"> * FileWriter = FileOutputStream + 编码表(GBK)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * InputStreamReader = FileInputStream + 编码表(GBK)</span></span><br><span class="line"><span class="comment"> * FileReader = FileInputStream + 编码表(GBK)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> /*</span></span><br><span class="line"><span class="comment"> * 需求：把当前项目目录下的a.txt内容复制到当前项目目录下的b.txt中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 数据源：</span></span><br><span class="line"><span class="comment"> * a.txt -- 读取数据 -- 字符转换流 -- InputStreamReader -- FileReader</span></span><br><span class="line"><span class="comment"> * 目的地：</span></span><br><span class="line"><span class="comment"> * b.txt -- 写出数据 -- 字符转换流 -- OutputStreamWriter -- FileWriter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyFileDemo2</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// 封装数据源</span></span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line"><span class="comment">// 封装目的地</span></span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次一个字符</span></span><br><span class="line"><span class="comment">// int ch = 0;</span></span><br><span class="line"><span class="comment">// while ((ch = fr.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">// fw.write(ch); </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次一个字符数组</span></span><br><span class="line">char[] chs = <span class="keyword">new</span> char[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fr.read(chs)) != <span class="number">-1</span>) &#123;</span><br><span class="line">fw.write(chs, <span class="number">0</span>, len);</span><br><span class="line">fw.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">fw.close();</span><br><span class="line">fr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是一个简单的字符流的使用方法，实现了一个文件复制的功能。我们在学习字节流的时候，就有缓冲流（BufferInputStream/BufferOutputStream）来实现数据的高速缓冲传送,其实在字符流中也有这个方法。比如（BufferedReader/BufferedWriter），下面就举一个小例子来 看一下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字符缓冲流的特殊方法：</span></span><br><span class="line"><span class="comment"> * BufferedWriter:</span></span><br><span class="line"><span class="comment"> * public void newLine():根据系统来决定换行符</span></span><br><span class="line"><span class="comment"> * BufferedReader:</span></span><br><span class="line"><span class="comment"> * public String readLine()：一次读取一行数据</span></span><br><span class="line"><span class="comment"> * 包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// write();</span></span><br><span class="line">read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> read() throws IOException &#123;</span><br><span class="line"><span class="comment">// 创建字符缓冲输入流对象</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"bw2.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// public String readLine()：一次读取一行数据</span></span><br><span class="line"><span class="comment">// String line = br.readLine();</span></span><br><span class="line"><span class="comment">// System.out.println(line);</span></span><br><span class="line"><span class="comment">// line = br.readLine();</span></span><br><span class="line"><span class="comment">// System.out.println(line);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终版代码</span></span><br><span class="line"><span class="built_in">String</span> line = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> write() throws IOException &#123;</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流对象</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bw2.txt"</span>));</span><br><span class="line"><span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">bw.write(<span class="string">"hello"</span> + x);</span><br><span class="line"><span class="comment">// bw.write("\r\n");</span></span><br><span class="line">bw.newLine();</span><br><span class="line">bw.flush();</span><br><span class="line">&#125;</span><br><span class="line">bw.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>缓冲流的具体实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * BufferedReader</span></span><br><span class="line"><span class="comment"> * 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 </span></span><br><span class="line"><span class="comment"> * 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * BufferedReader(Reader in)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 创建字符缓冲输入流对象</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"bw.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="comment">// int ch = 0;</span></span><br><span class="line"><span class="comment">// while ((ch = br.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">// System.out.print((char) ch);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = br.read(chs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.print(<span class="keyword">new</span> String(chs, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字符流为了高效读写，也提供了对应的字符缓冲流。</span></span><br><span class="line"><span class="comment"> * BufferedWriter:字符缓冲输出流</span></span><br><span class="line"><span class="comment"> * BufferedReader:字符缓冲输入流</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * BufferedWriter:字符缓冲输出流</span></span><br><span class="line"><span class="comment"> * 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 </span></span><br><span class="line"><span class="comment"> * 可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// BufferedWriter(Writer out)</span></span><br><span class="line"><span class="comment">// BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(</span></span><br><span class="line"><span class="comment">// new FileOutputStream("bw.txt")));</span></span><br><span class="line"></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bw.txt"</span>));</span><br><span class="line"></span><br><span class="line">bw.write(<span class="string">"hello"</span>);</span><br><span class="line">bw.write(<span class="string">"world"</span>);</span><br><span class="line">bw.write(<span class="string">"java"</span>);</span><br><span class="line">bw.flush();</span><br><span class="line"></span><br><span class="line">bw.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="IO的常用的流总结"><a href="#IO的常用的流总结" class="headerlink" title="IO的常用的流总结"></a>IO的常用的流总结</h3><p>其实IO简单的字节流和字符流并不难学，总的来说就是太复杂，其实实际操作不是很困难 。现在来总结一下，我们学过的流。</p><pre><code>IO流|--字节流    |--字节输入流        InputStream            int read():一次读取一个字节            int read(byte[] bys):一次读取一个字节数组            |--FileInputStream            |--BufferedInputStream    |--字节输出流        OutputStream            void write(int by):一次写一个字节            void write(byte[] bys,int index,int len):一次写一个字节数组的一部分            |--FileOutputStream            |--BufferedOutputStream|--字符流    |--字符输入流        Reader            int read():一次读取一个字符            int read(char[] chs):一次读取一个字符数组            |--InputStreamReader                |--FileReader            |--BufferedReader                String readLine():一次读取一个字符串    |--字符输出流        Writer            void write(int ch):一次写一个字符            void write(char[] chs,int index,int len):一次写一个字符数组的一部分            |--OutputStreamWriter                |--FileWriter            |--BufferedWriter                void newLine():写一个换行符                void write(String line):一次写一个字符串</code></pre><p>在插入一个图片有助于理解和帮助。</p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-4/49905583.jpg" alt=""></p><p>从图中我们就可以看到清晰的一个思路，各种流及其常用的实现类，在上面都有。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之IO这个硬骨头（一）</title>
    <link href="http://yoursite.com/2018/08/01/Java%E5%9F%BA%E7%A1%80%E4%B9%8BIO%E8%BF%99%E4%B8%AA%E7%A1%AC%E9%AA%A8%E5%A4%B4%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/01/Java基础之IO这个硬骨头（一）/</id>
    <published>2018-08-01T14:37:44.000Z</published>
    <updated>2018-08-01T14:41:17.116Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><h3 id="IO的概述"><a href="#IO的概述" class="headerlink" title="IO的概述"></a>IO的概述</h3><p>首先，我们要了解一下什么是IO，首先IO就是计算机中指Input/Output,也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。<br>流的概念：Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p><h3 id="IO如何学习？"><a href="#IO如何学习？" class="headerlink" title="IO如何学习？"></a>IO如何学习？</h3><h4 id="IO重点的类"><a href="#IO重点的类" class="headerlink" title="IO重点的类"></a>IO重点的类</h4><p>IO的学习我认为最主要的就是五个类和一个接口，把这些学好，基本就没什么问题：<br>File、OutputStream、InputStream、Writer、Reader和接口Serializable。</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td>File</td><td>文件类</td></tr><tr><td>OutputStream</td><td>字节输出流</td></tr><tr><td>InputStream</td><td>字节输入流</td></tr><tr><td>Writer</td><td>字符输流</td></tr><tr><td>Reader</td><td>字符输入流</td></tr></tbody></table><ol><li>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。</li><li>InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</li><li>OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。</li><li>Reader（文件格式操作）：抽象类，基于字符的输入操作。</li><li>Writer（文件格式操作）：抽象类，基于字符的输出操作。</li></ol><p>上面是对这几个类的简单概述基本就是这几个较为重点，当然还有扩展的FileInputStream等等，但是我认为最基础的还是这几个。</p><h4 id="IO的分类"><a href="#IO的分类" class="headerlink" title="IO的分类"></a>IO的分类</h4><p>从上面我们学习了流的概念；一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。<br>下图是一个描述输入流和输出流的类层次图。<br><img src="http://www.runoob.com/wp-content/uploads/2013/12/iostream2xx.png" alt="IO"></p><p>从图中我们可以看到简单的分类是字符流与字节流，接下来我在解释一下：<br>先来说一下输入、输出流：</p><ul><li>输入流：程序从输入流读取数据源。数据源包括外界(键盘、文件、网络…)，即是将数据源读入到程序的通信通道</li></ul><ul><li><p>输出流程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络…）的通信通道。</p><pre><code>采用数据流的目的就是使得输出输入独立于设备。输入流( Input  Stream )不关心数据源来自何种设备（键盘，文件，网络）。  输出流( Output Stream )不关心数据的目的是何种设备（键盘，文件，网络）。</code></pre></li></ul><p>流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：</p><p>1)  字节流：数据流中最小的数据单元是字节<br>2)  字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</p><p><strong>字符流的由来：</strong> Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。<br>所以说：<strong>字符流=字节流+编码表</strong>。这个编码表我们后来再进行讲解。</p><blockquote><p>注意：<br>a.如果没有明确说按照什么区分，默认按照数据类型进行分。<br>b.除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。</p></blockquote><h3 id="InputStream-OutputStream的代码实现"><a href="#InputStream-OutputStream的代码实现" class="headerlink" title="InputStream/OutputStream的代码实现"></a>InputStream/OutputStream的代码实现</h3><blockquote><p>通过上面的分析后我们知道要使用：OutputStream<br> 但是通过查看API，我们发现该流对象是一个抽象类，不能实例化。<br> 所以，我们要找一个具体的子类。<br> 而我们要找的子类是什么名字的呢?这个时候，很简单，我们回想一下，我们是不是要往文件中写东西。<br> 文件是哪个单词——&gt;File<br> 然后用的是字节输出流，联起来就是：FileOutputStream<br>注意：每种基类的子类都是以父类名作为后缀名。<br>          XxxOutputStream<br>          XxxInputStream<br>          XxxReader<br>          XxxWriter</p></blockquote><p>所以我们从FileInputStream和FileOutputStream来演示对字节流的操作。</p><h4 id="FileOutputStream读取数据"><a href="#FileOutputStream读取数据" class="headerlink" title="FileOutputStream读取数据"></a>FileOutputStream读取数据</h4><h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><ol><li>创建字节输入流对象</li><li>调用read()方法</li><li>释放资源<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">          <span class="comment">// 创建字节输出流对象</span></span><br><span class="line">          FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建字节输出流对象了做了几件事情：</span></span><br><span class="line"><span class="comment"> * A:调用系统功能去创建文件</span></span><br><span class="line"><span class="comment"> * B:创建fos对象</span></span><br><span class="line"><span class="comment"> * C:把fos对象指向这个文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">fos.write(<span class="string">"hello,IO"</span>.getBytes());</span><br><span class="line">fos.write(<span class="string">"java"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="comment">//关闭此文件输出流并释放与此流有关的所有系统资源。</span></span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><h5 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h5><p><strong>1. 创建字节输出流对象做了几件事情?</strong></p><pre><code>FileOutputStream(File file)File file = new File(&quot;fos.txt&quot;);FileOutputStream fos = new FileOutputStream(file);FileOutputStream(String name)</code></pre><p>其实先根据文件名称，使用File把这个文件创建出来，然后再把这个文件传入FileOutputStream(file);<br><strong>2. 为什么要关闭资源？</strong><br>释放资源的目的是要让流对象变成垃圾，这样就可以被垃圾回收器回收了，其次是通知系统去释放跟该文件相关的资源<br><strong>3. 如何实现数据换行？</strong><br>为什么现在没有换行呢?因为你值写了字节数据，并没有写入换行符号。<br>如何实现呢?写入换行符号即可呗。<br>刚才我们看到了有写文本文件打开是可以的，通过windows自带的那个不行，为什么呢?<br>因为不同的系统针对不同的换行符号识别是不一样的?</p><blockquote><p>windows:\r\n<br>linux:\n<br>Mac:\r</p></blockquote><p>而一些常见的个高级记事本，是可以识别任意换行符号的。<br>为了使得同一个java程序的换行符在所有的操作系统中都有一样的表现，使用 <strong><em>%n</em></strong>，就可以做到平台无关的换行。</p><p><strong>4. 如何实现数据的追加写入？</strong></p><p>用构造方法带第二个参数是true的情况即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个向具有指定 name 的文件中写入数据的输出文件流。如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处。</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos3.txt"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><p>这样创建就可以实现数据的追加。</p><h4 id="FileInputStream读取数据"><a href="#FileInputStream读取数据" class="headerlink" title="FileInputStream读取数据"></a>FileInputStream读取数据</h4><h5 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h5><ol><li>创建字节输入流对象</li><li>调用read()方法</li><li>释放资源</li></ol><h5 id="代码体现："><a href="#代码体现：" class="headerlink" title="代码体现："></a>代码体现：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//创建FileInputStream</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">      <span class="comment">//read（）方法读取数据</span></span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line">int by = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((by=fis.read())!=<span class="number">-1</span>) &#123;</span><br><span class="line">System.out.print((char)by);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(bys))!=<span class="number">-1</span>) &#123;</span><br><span class="line">System.out.print(<span class="keyword">new</span> <span class="built_in">String</span>(bys,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="复制文本文件"><a href="#复制文本文件" class="headerlink" title="复制文本文件"></a>复制文本文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 复制文本文件。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 数据源：从哪里来</span></span><br><span class="line"><span class="comment"> * a.txt--读取数据--FileInputStream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 目的地：到哪里去</span></span><br><span class="line"><span class="comment"> * b.txt--写数据--FileOutputStream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * java.io.FileNotFoundException: a.txt (系统找不到指定的文件。)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这一次复制中文没有出现任何问题，为什么呢?</span></span><br><span class="line"><span class="comment"> * 上一次我们出现问题的原因在于我们每次获取到一个字节数据，就把该字节数据转换为了字符数据，然后输出到控制台。</span></span><br><span class="line"><span class="comment"> * 而这一次呢?确实通过IO流读取数据，写到文本文件，你读取一个字节，我就写入一个字节，你没有做任何的转换。</span></span><br><span class="line"><span class="comment"> * 它会自己做转换。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyFileDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// 封装数据源</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line"><span class="comment">// 封装目的地</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br><span class="line"></span><br><span class="line">byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(bys)) != <span class="number">-1</span>) &#123;</span><br><span class="line">fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源(建议先关后创建的)</span></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复制图片"><a href="#复制图片" class="headerlink" title="复制图片"></a>复制图片</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：把e:\\林青霞.jpg内容复制到当前项目目录下的mn.jpg中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 数据源：</span></span><br><span class="line"><span class="comment"> * e:\\林青霞.jpg--读取数据--FileInputStream</span></span><br><span class="line"><span class="comment"> * 目的地：</span></span><br><span class="line"><span class="comment"> * mn.jpg--写出数据--FileOutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyImageDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 封装数据源</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"e:\\林青霞.jpg"</span>);</span><br><span class="line"><span class="comment">// 封装目的地</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"mn.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制数据</span></span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思考问题：计算机如何识别中文"><a href="#思考问题：计算机如何识别中文" class="headerlink" title="思考问题：计算机如何识别中文"></a>思考问题：计算机如何识别中文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算机是如何识别什么时候该把两个字节转换为一个中文呢?</span></span><br><span class="line"><span class="comment"> * 在计算机中中文的存储分两个字节：</span></span><br><span class="line"><span class="comment"> * 第一个字节肯定是负数。</span></span><br><span class="line"><span class="comment"> * 第二个字节常见的是负数，可能有正数。但是没影响。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// String s = "abcde";</span></span><br><span class="line"><span class="comment">// // [97, 98, 99, 100, 101]</span></span><br><span class="line"></span><br><span class="line">String s = <span class="string">"我爱你中国"</span>;</span><br><span class="line"><span class="comment">// [-50, -46, -80, -82, -60, -29, -42, -48, -71, -6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bys = s.getBytes();</span><br><span class="line">System.out.println(Arrays.toString(bys));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符缓冲区流"><a href="#字符缓冲区流" class="headerlink" title="字符缓冲区流"></a>字符缓冲区流</h3><p>BufferedOutputStream（字符缓冲输出流）/BufferedInputStream（字符缓冲输入流）<br>构造方法为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。创建一个内部缓冲区数组并将其存储在 buf 中,该buf的大小默认为8192。   </span></span><br><span class="line">public   BufferedInputStream(InputStream <span class="keyword">in</span>); </span><br><span class="line"><span class="comment">//创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。创建一个长度为 size 的内部缓冲区数组并将其存储在 buf 中。   </span></span><br><span class="line">public   BufferedInputStream(InputStream <span class="keyword">in</span>,int size);</span><br></pre></td></tr></table></figure></p><p>BufferedOutputStream的思想进行简单说明：<em>BufferedOutputStream通过字节数组来缓冲数据，当缓冲区满或者用户调用flush()函数时，它就会将缓冲区的数据写入到输出流中。</em><br>话不多说，上代码——–&gt;</p><h4 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：把e:\\哥有老婆.mp4复制到当前项目目录下的copy.mp4中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 字节流四种方式复制文件：</span></span><br><span class="line"><span class="comment"> * 基本字节流一次读写一个字节：共耗时：117235毫秒</span></span><br><span class="line"><span class="comment"> * 基本字节流一次读写一个字节数组： 共耗时：156毫秒</span></span><br><span class="line"><span class="comment"> * 高效字节流一次读写一个字节： 共耗时：1141毫秒</span></span><br><span class="line"><span class="comment"> * 高效字节流一次读写一个字节数组： 共耗时：47毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyMp4Demo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// method1("e:\\哥有老婆.mp4", "copy1.mp4");</span></span><br><span class="line"><span class="comment">// method2("e:\\哥有老婆.mp4", "copy2.mp4");</span></span><br><span class="line"><span class="comment">// method3("e:\\哥有老婆.mp4", "copy3.mp4");</span></span><br><span class="line">method4(<span class="string">"e:\\哥有老婆.mp4"</span>, <span class="string">"copy4.mp4"</span>);</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"共耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效字节流一次读写一个字节数组：</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> method4(<span class="built_in">String</span> srcString, <span class="built_in">String</span> destString)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">srcString));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line"><span class="keyword">new</span> FileOutputStream(destString));</span><br><span class="line"></span><br><span class="line">byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = bis.read(bys)) != <span class="number">-1</span>) &#123;</span><br><span class="line">bos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效字节流一次读写一个字节：</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> method3(<span class="built_in">String</span> srcString, <span class="built_in">String</span> destString)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">srcString));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line"><span class="keyword">new</span> FileOutputStream(destString));</span><br><span class="line"></span><br><span class="line">int by = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((by = bis.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">bos.write(by);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本字节流一次读写一个字节数组</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> method2(<span class="built_in">String</span> srcString, <span class="built_in">String</span> destString)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcString);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destString);</span><br><span class="line"></span><br><span class="line">byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(bys)) != <span class="number">-1</span>) &#123;</span><br><span class="line">fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本字节流一次读写一个字节</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> method1(<span class="built_in">String</span> srcString, <span class="built_in">String</span> destString)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcString);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destString);</span><br><span class="line"></span><br><span class="line">int by = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((by = fis.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">fos.write(by);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出，经过BufferedxxxputStream修饰的字节流，速度快了很多，其实这也是一种设计模式的体现，装饰者设计模式。<br>今天就到这里，明天再来讲解字符流和其他流的知识。谢谢！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>java基础之异常</title>
    <link href="http://yoursite.com/2018/07/31/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2018/07/31/java基础之异常/</id>
    <published>2018-07-31T13:44:51.000Z</published>
    <updated>2018-07-31T13:45:48.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><p>本来今天是准备写一点IO的东西，但是想了一下，想之前先说一下File类，但是File的时候还会出现很多错误，所以先写一篇异常的文章。就从异常开始说吧！</p><h3 id="异常的概述"><a href="#异常的概述" class="headerlink" title="异常的概述"></a>异常的概述</h3><p>异常：异常就是Java程序在运行过程中出现的错误。<br>异常由来：问题也是现实生活中一个具体事务，也可以通过java 的类的形式进行描述，并封装成对象。其实就是Java对不正常情况进行描述后的对象体现。</p><h3 id="异常的体系"><a href="#异常的体系" class="headerlink" title="异常的体系"></a>异常的体系</h3><p>下面是异常的大概分类：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-31/73011655.jpg" alt=""></p><p>我们可以看到Throwable类是 Java 语言中所有错误或异常的超类。下面具体有两个异常类：Error、Exception。</p><pre><code>Error：用于指示合理的应用程序不应该试图捕获的严重问题。（不需要我们处理）Exception：合理的应用程序想要获取的条件。        |---RuntimeException    运行期异常，我们需要修正代码        |---非RuntimeException 编译期异常，必须处理的，否则程序编译不通过 RuntimeException有以下一些例子：        NullPointerException - 空指针引用异常          ClassCastException - 类型强制转换异常。          IllegalArgumentException - 传递非法参数异常。          ArithmeticException - 算术运算异常          IndexOutOfBoundsException - 下标越界异常          NumberFormatException - 数字格式异常          UnsupportedOperationException - 不支持的操作异常</code></pre><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><ol><li>JVM默认的处理<br> 把异常的名称，原因，位置打印在控制台，但是不处理，程序停止，不在执行。</li><li>自己处理<pre><code>1.  try...catch...finally           自己编写处理代码,后面的程序可以继续执行    2.throws        把自己处理不了的，在方法上声明，告诉调用者，这里有问题。</code></pre><h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3></li><li><p>finally用于释放资源（JDBC、流操作），它的代码永远会执行。特殊情况：在执行到finally之前jvm退出。下面的打印是不会执行的，因为JVM已经退出了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;   </span><br><span class="line"><span class="comment">// do something Syst...   </span></span><br><span class="line"> System.exit(<span class="number">1</span>);  </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line"> System.out.println(<span class="string">"Hello,World!"</span>);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>异常处理的变形</p><pre><code>   try...catch...finallytry...catch...try...catch...catch...try...catch...catch...fianllytry...finally</code></pre><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可。<br>这个不是考察的重点，不做多的赘述。</p><h3 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h3></li><li>父类方法有异常抛出，子类方法的重写方法在抛出异常时必须小于等于父类的异常。</li><li>父类的方法没有异常抛出，子类的重写方法不能有异常抛出。</li><li>父类的方法抛出多个异常，子类的重写方法必须必父类少或者小。</li></ol><h3 id="异常的面试题"><a href="#异常的面试题" class="headerlink" title="异常的面试题"></a>异常的面试题</h3><h4 id="编译期异常和运行期异常的区别"><a href="#编译期异常和运行期异常的区别" class="headerlink" title="编译期异常和运行期异常的区别?"></a>编译期异常和运行期异常的区别?</h4><p>答：编译期异常，必须要处理的，否则无法通过编译，程序不能运行。<br>   运行期异常不一定会发生，不一定处理，也可以处理，比如空指针异常，这就不一定会发生。</p><h4 id="throw和throws是的区别？"><a href="#throw和throws是的区别？" class="headerlink" title="throw和throws是的区别？"></a>throw和throws是的区别？</h4><p>答：throw：</p><blockquote><p>在方法体中,后面跟的是异常对象名,并且只能是一个<br>    throw抛出的是一个异常对象，说明这里肯定有一个异常产生了.</p></blockquote><p>throws：</p><blockquote><p>在方法声明上,后面跟的是异常的类名,可以是多个<br>throws是声明方法有异常，是一种可能性，这个异常并不一定会产生.</p></blockquote><h4 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final,finally,finalize的区别?"></a>final,finally,finalize的区别?</h4><p>这个问题我之前做过深入的解析，可以查看我的博文    <a href="https://blog.jh0904.top/2018/07/09/final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">final、finally、finalize的区别</a>    </p><h4 id="如果在catch里面有return-请问finally还执行吗-如果执行-在return前还是后"><a href="#如果在catch里面有return-请问finally还执行吗-如果执行-在return前还是后" class="headerlink" title="如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后"></a>如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后</h4><p>答：会，前。<br>finally和return<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String\[\] args)</span> </span>&#123;  </span><br><span class="line">   System.out.println(getInt());  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">      System.out.println(a / <span class="number">0</span>);  </span><br><span class="line">   a = <span class="number">20</span>;  </span><br><span class="line">   &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;  </span><br><span class="line">      a = <span class="number">30</span>;  </span><br><span class="line"> <span class="keyword">return</span> a;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">      System.out.println (<span class="string">"hello"</span>);  </span><br><span class="line">   <span class="comment">//return a;  </span></span><br><span class="line">   &#125;  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行结果</p><pre><code>hello30</code></pre><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>这个是JDK1.7新加入的一个异常的新特性。<br>try-with-resources语句是一个声明一个或多个资源的try语句。一个资源作为一个对象，必须在程序结束之后关闭。try-with-resources语句确保在语句的最后每个资源都被关闭，任何实现了java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resource来实现异常处理和关闭资源。<br>具体使用见下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;  </span><br><span class="line"> <span class="keyword">return</span> br.readLine();  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>把需要关闭的对象写在括号中，其中要关闭的对象必须实现java.lang.AutoCloseable和java.io.Closeable。</p><h3 id="finally和return这些事"><a href="#finally和return这些事" class="headerlink" title="finally和return这些事"></a>finally和return这些事</h3><h4 id="在finally中return数值？"><a href="#在finally中return数值？" class="headerlink" title="在finally中return数值？"></a>在finally中return数值？</h4><p>在finally中return数值，最后的返回值是finally中的值。可以参考代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String\[\] args)</span> </span>&#123;  </span><br><span class="line">      System.out.println(getInt());  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">         System.out.println(a / <span class="number">0</span>);  </span><br><span class="line">   a = <span class="number">20</span>;  </span><br><span class="line">   &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;  </span><br><span class="line">         a = <span class="number">30</span>;  </span><br><span class="line"> <span class="keyword">return</span> a;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">         a=<span class="number">40</span>;</span><br><span class="line">         <span class="keyword">return</span> a;  </span><br><span class="line">   &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的运行结果是40,并且其中有提示说：</p><pre><code>不能在finally块中使用return，finally块中的return返回后方法结束执行，不会再执行try块中的return语句。 Negative example:    public static Long readFileLength(String fileName) {        try {            File file = new File(fileName);            RandomAccessFile randomAccessFile = new RandomAccessFile(file, &quot;r&quot;);            return randomAccessFile.length();        } catch (Exception e) {            logger.error(e.getMessage(), e);        } finally {            countDownLatch.countDown();            return 0L;        }    }</code></pre><h4 id="catch捕获异常时，finally改变返回值"><a href="#catch捕获异常时，finally改变返回值" class="headerlink" title="catch捕获异常时，finally改变返回值"></a>catch捕获异常时，finally改变返回值</h4><p>我们可以从上面看出来，当finally块中有return语句时，将会覆盖函数中其他的return语句。</p><blockquote><p>此外，由于一个方法内部定义的变量都存储子在栈中，当这个函数结束后，其对应的栈就被回收，此时方法中的变量就不存在了。因此return在返回时不是直接返回变量的值，而是复制一份，然后返回。<br>因此，对于基本数据类型的数据，在finally块中改变return的值，不会有影响，对于引用数据类型会有影响。</p></blockquote><p>可以参考下面代码理解<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package Exception;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> \* Exception * \* @author jh  </span></span><br><span class="line"><span class="comment"> \* @date 2018/7/31 20:26  </span></span><br><span class="line"><span class="comment"> \* description: */</span>public <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;  </span><br><span class="line">   public <span class="keyword">static</span> int testFinally1()&#123;  </span><br><span class="line">      int result=<span class="number">1</span>;  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">         result=<span class="number">2</span>;  </span><br><span class="line"> <span class="keyword">return</span> result;  </span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">         result=<span class="number">3</span>;  </span><br><span class="line">   System.out.println (<span class="string">"testFinally1"</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   public <span class="keyword">static</span> StringBuffer testFinally2()&#123;  </span><br><span class="line">      StringBuffer s=<span class="keyword">new</span> StringBuffer (<span class="string">"hello"</span>);  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> s;  </span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">         s.append (<span class="string">"world"</span>);  </span><br><span class="line">   System.out.println (<span class="string">"testFinally2"</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>\[\] args) &#123;  </span><br><span class="line">      int i = testFinally1 ();  </span><br><span class="line">   System.out.println (i);  </span><br><span class="line">   StringBuffer finally2 = testFinally2 ();  </span><br><span class="line">   System.out.println (finally2);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码我们可以看出程序在执行return时会首先将返回值存储在一个指定的位置，其次去执行finally块，最后再返回。在方法testFinally1中调用return前，先把return的值存储在一个指定的位置，然后再去执行finally块中的代码，此时修改result的值不会影响程序的返回结果。<br>testFinally2中，在调用return之前把s保存在一个指定的位置，但是因为s为引用类型，因此在finally块中修改s的值会发生变化。会影响程序的返回结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机（一）</title>
    <link href="http://yoursite.com/2018/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/28/深入理解java虚拟机（一）/</id>
    <published>2018-07-28T04:14:26.000Z</published>
    <updated>2018-07-28T04:21:20.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>今天主要学习了《深入理解java虚拟机》的前两章节，第一章主要讲解了java语法的一些特性，及java发展的历史，还有java虚拟机的一些知识。<br>第二章主要讲了java内存区域与内存溢出异常。主要的内容我都总结了思维导图，如果需要导图，可以从百度云下载<a href="https://pan.baidu.com/s/1esP5YDPv_5UZ_neUvGo2BQ" target="_blank" rel="noopener">java虚拟机导图</a>  ，密码是0n73</p><p>好了，废话不说，直接上图。有不正确的地方，欢迎大家指正。</p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-28/92420488.jpg" alt="java"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天主要学习了《深入理解java虚拟机》的前两章节，第一章主要讲解了java语法的一些特性，及java发展的历史，还有java虚
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>阶段性总结</title>
    <link href="http://yoursite.com/2018/07/24/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/07/24/阶段性总结/</id>
    <published>2018-07-24T15:44:43.000Z</published>
    <updated>2018-07-24T15:45:42.276Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="实训总结"><a href="#实训总结" class="headerlink" title="实训总结"></a>实训总结</h3><p>今天是实训结束，实训期间主要还是自己状态不是很好，主要学习了Mybatis和Spring MVC的一些东西。其次实训单位让做一个简单的项目。我们小组做了一个简单的易买网项目.具体项目我已经上传到服务器，大家可以去访问。链接放在这里：<a href="http://www.jh0904.top/MStorage" target="_blank" rel="noopener">易买网</a>。时间短，任务比较重，所以就大概这个样子啦，其中还有很多缺陷，还要继续完善，希望大家指正。</p><h3 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h3><p>现在在学校东门租了房子，准备利用这个时间，好好的去复习一下之前的知识，并且去加深印象。去备战9月的秋招。<br>大概学习计划如下：</p><h4 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h4><ul><li>反射的总结、集合的总结、IO的总结、NIO的总结。（博客）</li><li>对于基础部分，还有笔试题的任务，每天规定做20-30道牛客的题目。编程题1道。（习题）</li><li>每日的博客（主要是面试题）</li><li>其次，还有对高并发的学习。java8的了解，java9暂时不考虑。</li><li>还有对java虚拟机的学习。</li><li>对之前几本武林秘籍的复习。</li></ul><h4 id="框架和web开发"><a href="#框架和web开发" class="headerlink" title="框架和web开发"></a>框架和web开发</h4><ul><li>学习《web开发指南》了解web开发的基本业务逻辑。</li><li>首先前段时间学习了Mybatis和Spring MVC,但是基础不牢靠，需要总结。（博客）</li><li>学习SSM的整合项目，并且根据尚硅谷的视频搭载一个简单的项目。</li><li>复习Spring的开发，复习方法有：1.学习spring的注解开发（视频）2.阅读spring实战（书籍）<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4></li><li>复习数据库的知识，简单的操作，并且还有高级的开发（索引的一些东西）</li><li>学习NoSQL数据库（Redis），主要以视频为主，书籍为辅导资料。</li><li>练习简单的sql语句练习题（牛客网）</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>熟悉简单的排序方法，了解基本思想，每周写一遍。</li><li>练习编程题，每日一道。</li><li>学习java视频（主要是简单的算法和letcood的视频）</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>以上是我对假期的一些安排和期望，希望我能在接下来的一个月中，砥砺前行，不忘初心。加油！！！</p><p>我对我的寄语：</p><h1 id="加油，相信自己。想要改变世界，先改变自己。"><a href="#加油，相信自己。想要改变世界，先改变自己。" class="headerlink" title=" 加油，相信自己。想要改变世界，先改变自己。 "></a><font style="color:red"> 加油，相信自己。想要改变世界，先改变自己。 </font></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实训总结&quot;&gt;&lt;a href=&quot;#实训总结&quot; class=&quot;headerlink&quot; title=&quot;实训总结&quot;&gt;&lt;/a&gt;实
      
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="自我总结" scheme="http://yoursite.com/tags/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93/"/>
    
      <category term="学习计划" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>纪念一次json解析错误！！！</title>
    <link href="http://yoursite.com/2018/07/23/%E7%BA%AA%E5%BF%B5%E4%B8%80%E6%AC%A1json%E8%A7%A3%E6%9E%90%E9%94%99%E8%AF%AF%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://yoursite.com/2018/07/23/纪念一次json解析错误！！！/</id>
    <published>2018-07-23T14:38:38.000Z</published>
    <updated>2018-07-23T14:41:09.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>今天做了一个简单的ssm项目，在用spring mvc解析json数据时，网页一直返回数据显示406错误。对于这个错误，头疼了一天。首先介绍一下我的小项目。</p><h3 id="项目代码与思路"><a href="#项目代码与思路" class="headerlink" title="项目代码与思路"></a>项目代码与思路</h3><p>首先先创建一个jsp页面，json数据的传输有两种：</p><ul><li>一、请求json，输出是json </li><li>二、请求key/value，输出是json</li></ul><p>接下来首先分析一下请求json返回也是json的形式（第二种不做简述，照猫画虎，思想一致，只提供代码）<br>使用jquery的ajax提交json串，对输出的json结果进行解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        //请求json，输出是json</span><br><span class="line">        function requestJson() &#123;</span><br><span class="line">            alert(&quot;requestJson&quot;);</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type: &apos;post&apos;,</span><br><span class="line">                url: &apos;$&#123;pageContext.request.contextPath &#125;/requestJson&apos;,</span><br><span class="line">                contentType: &apos;application/json;charset=utf-8&apos;,</span><br><span class="line">                //数据格式是json串,商品信息</span><br><span class="line">                data: &apos;&#123;&quot;name&quot;:&quot;手机&quot;,&quot;price&quot;:999&#125;&apos;,</span><br><span class="line">                success: function (data) &#123;//返回json结果</span><br><span class="line">                    alert(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;input type=&quot;button&quot; onclick=&quot;requestJson()&quot; value=&quot;请求json，输出是json&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>然后在controller中写一个JsonTest类存储方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.how2java.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.ItemsCustom;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JsonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求json串(商品信息)，输出json(商品信息)</span></span><br><span class="line"><span class="comment">//@RequestBody将请求的商品信息的json串转成itemsCustom对象</span></span><br><span class="line"><span class="comment">//@ResponseBody将itemsCustom转成json输出</span></span><br><span class="line">@RequestMapping(<span class="string">"/requestJson"</span>)</span><br><span class="line">public @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom)&#123;</span><br><span class="line"><span class="comment">//@ResponseBody将itemsCustom转成json输出</span></span><br><span class="line"><span class="keyword">return</span> itemsCustom;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个代码的意思就是从jsp发送到controller中，然后其中的@RequestBody标明传输json数据，最后在返回数据到页面上。</p><h3 id="错误问题"><a href="#错误问题" class="headerlink" title="错误问题"></a>错误问题</h3><p>在写完上述代码之后，出现了网页无法解析json数据的状况，检查头文件发现后端传数据过来到前端了，但是显示406错误。总共出现了两个问题：</p><h4 id="问题一：jar问题"><a href="#问题一：jar问题" class="headerlink" title="问题一：jar问题"></a>问题一：jar问题</h4><p>导入的jar包不正确，之前一直使用的是1.9.2版本的下面三个jar包，在网上查询了之后发现，spring3.* 支持1.9.2 ,在spring4.0之后已经不支持了，所以把jar全部更新到2.4.1的jar包。我使用的是maven工程，具体的依赖可以看下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">             &lt;!--jackson--&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;jackson-core&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;jackson-annotations&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;jackson-databind&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-23/91348004.jpg" alt=""></p><h4 id="问题二：spring-MVC-xml配置文件出现问题"><a href="#问题二：spring-MVC-xml配置文件出现问题" class="headerlink" title="问题二：spring MVC.xml配置文件出现问题"></a>问题二：spring MVC.xml配置文件出现问题</h4><p>在需要解析json1的时候需要在spring MVC.xml添加如下配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 避免IE执行AJAX时,返回<span class="built_in">JSON</span>出现下载文件 --&gt;</span><br><span class="line">   &lt;bean id=<span class="string">"mappingJacksonHttpMessageConverter"</span></span><br><span class="line">         <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"supportedMediaTypes"</span>&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">               &lt;value&gt;text/html;charset=UTF<span class="number">-8</span>&lt;<span class="regexp">/value&gt;</span></span><br><span class="line"><span class="regexp">           &lt;/</span>list&gt;</span><br><span class="line">       &lt;<span class="regexp">/property&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 启动Spring MVC的注解功能，完成请求和注解POJO的映射 --&gt;</span><br><span class="line">   &lt;bean</span><br><span class="line">           <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"messageConverters"</span>&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">               &lt;ref bean=<span class="string">"mappingJacksonHttpMessageConverter"</span> /&gt;&lt;!-- json转换器 --&gt;</span><br><span class="line">           &lt;/list&gt;</span><br><span class="line">       &lt;<span class="regexp">/property&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>bean&gt;</span><br></pre></td></tr></table></figure></p><p>但是加入之后依然报错，显示无法加载<font style="color : red">org.springframework.http.converter.json.MappingJacksonHttpMessageConverter</font></p><p>网上查询之后发现，在导入jackson2.0版本以上的时候，其中的配置文件已经更换了<br>更换为</p><blockquote><p>org.springframework.http.converter.json.MappingJackson2HttpMessageConverter</p></blockquote><p>配置完成之后，重新启动项目，发现项目没有问题了，成功运行。<br>这次再配置的过程中浪费太多时间，为了避免下次还是出现此类问题，故此写了这篇文章，以便以后查阅和修改代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天做了一个简单的ssm项目，在用spring mvc解析json数据时，网页一直返回数据显示406错误。对于这个错误，头疼了一
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
      <category term="java项目" scheme="http://yoursite.com/tags/java%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>java提供了那些IO方式？NIO如何实现多路复用？</title>
    <link href="http://yoursite.com/2018/07/21/java%E6%8F%90%E4%BE%9B%E4%BA%86%E9%82%A3%E4%BA%9BIO%E6%96%B9%E5%BC%8F%EF%BC%9FNIO%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/21/java提供了那些IO方式？NIO如何实现多路复用？/</id>
    <published>2018-07-21T00:57:55.000Z</published>
    <updated>2018-07-21T00:58:30.708Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。</p><p>首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p><p>java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p><p>很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p><p>第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p><p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>上面所列出的回答是一种常见的分类方式，即所谓的BIO、NIO、AIO。</p><p>主要考察的点有：</p><ul><li>基础的API设计与功能<br>InputStream/OutputStream和Reader/Writer的区别和使用。</li><li>NIO、NIO2的基本组成。</li><li>不同场景下，分析BIO和NIO的设计和实现原理。</li><li>NIO提供高性能的原理</li><li><p>NIO还存在那些问题？改进的想法？</p><h3 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4></li><li>区分同步或异步（synchronous/asynchronous）<blockquote><p>所谓同步是指一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成，这是一个可靠的任务序列。要成功都成功，要失败都失败，两个任务的状态可以保持一致。<br>异步不需要等待依赖的任务完成。只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了，至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p></blockquote></li><li>区分阻塞与非阻塞（blocking/non-blocking）<blockquote><p>在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</p></blockquote></li></ul><p>对于IO，做一下总结：</p><ul><li>IO不仅仅是对文件的操作，在网络编程中，比如socket通信，都是典型的IO操作目标。</li><li>输入流、输出流（InputStream/OutputStream）适用于读取或者写入字节，例如图片操作文件。</li><li>Reader/Writer则是用于操作字符的，增加字符编解码的功能，适用于从文件中读取或者写入文本信息2，本质上计算机操作的都是字节，不管是从网络通信还是文件读取，Reader/Writer相当于构建了应用逻辑与原始数据之间的桥梁。</li><li>BufferedOutputStream等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。</li><li>参考下面这张类图，很多 IO工具类都实现了 Closeable接口，因为需要进行资源的释放。比如，打开 FileInputStream，它就会获取相应的文件描述符（ FileDescriptor），需要利用 try- with- resources、 try- finally等机制保证 FileInputStream被明确关闭，进而相应文件描述符也会失效，否则将导致资源无法被释放。利用专栏前面的内容提到的 Cleaner或 finalize机制作为资源释放的最后把关，也是必要的。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-21/67006062.jpg" alt=""></li></ul><h4 id="NIO的概览"><a href="#NIO的概览" class="headerlink" title="NIO的概览"></a>NIO的概览</h4><ol><li>首先了解一下NIO的基本组成部分：</li></ol><ul><li><p>Chnnel</p><blockquote><p>由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。<br>Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。<br>类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。<br>File 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过 Socket 获取 Channel，反之亦然。</p></blockquote></li><li><p>Buffer</p><blockquote><p>一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p></blockquote></li><li>Selector<blockquote><p>是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在 Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理。<br>Selector 同样是基于底层操作系统机制，不同模式、不同版本都存在区别，例如，在最新的代码库里，相关实现如下：<br>在Linux中依赖于epoll<br>在Windows中依赖于iocp模型</p></blockquote></li><li>Chartset<blockquote><p>提供 Unicode 字符串定义，NIO 也提供了相应的编解码器等，例如，通过下面的方式进行字符串到 ByteBuffer 的转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharSet.defaultCharSet().encode(<span class="string">"Hello,World"</span>)</span><br></pre></td></tr></table></figure></blockquote></li></ul><ol start="2"><li>NIO的具体作用</li></ol><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>对比HashMap、HashTable、TreeMap之间的区别</title>
    <link href="http://yoursite.com/2018/07/18/%E5%AF%B9%E6%AF%94HashMap%E3%80%81HashTable%E3%80%81TreeMap%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/07/18/对比HashMap、HashTable、TreeMap之间的区别/</id>
    <published>2018-07-18T13:41:46.000Z</published>
    <updated>2018-07-18T13:42:57.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。</p><p>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</p><p>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</p><p>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>我感觉这三个Map中最重要的肯定是HashMap，首先看一下我之前的文章了解一下：<a href="https://blog.jh0904.top/2018/06/08/hashmap/" target="_blank" rel="noopener">HashMap的源码解析</a>，我认为学习集合框架，首先要了解基本的操作用法，这个应该去读API。其次，应当去学习源码，去了解怎么实现的具体代码。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-18/32923831.jpg" alt=""></p><p>对于三者的区别，我主要从三方面来说：</p><h4 id="1-语法上面的区别："><a href="#1-语法上面的区别：" class="headerlink" title="1.语法上面的区别："></a>1.语法上面的区别：</h4><p>1）HashMap允许键值为空，Hashtable不允许。</p><p>2）HashMap包含了containsvalue和containsKey，不包含有contains。</p><h4 id="2-安全方面的区别"><a href="#2-安全方面的区别" class="headerlink" title="2.安全方面的区别"></a>2.安全方面的区别</h4><p>HashTable支持线程安全的，而HashMap不支持线程同步，是非线程安全的。因此，HashMap相对来说效率可能会高于Hashtable。</p><h4 id="3-源码级别的区别"><a href="#3-源码级别的区别" class="headerlink" title="3.源码级别的区别"></a>3.源码级别的区别</h4><p>Hashtable，hash数组默认的大小是11，增加的方式是old*2+1,而HashMap中，hash数组的默认大小是16，而且一定是2的指数。</p><p>相较于HashMap和HashTable，TreeMap是利用红黑树来实现的，实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap来进行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多线程（二）</title>
    <link href="http://yoursite.com/2018/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/17/多线程（二）/</id>
    <published>2018-07-17T14:30:53.000Z</published>
    <updated>2018-07-17T14:31:26.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>这是多线程的第二篇文章，主要介绍一写java多线程的简单锁机制和死锁、线程池等一些概念，多线程的高级部分过一段时间加上。</p><h3 id="1-JDK5以后的针对线程的锁定操作和释放操作"><a href="#1-JDK5以后的针对线程的锁定操作和释放操作" class="headerlink" title="(1)JDK5以后的针对线程的锁定操作和释放操作"></a>(1)JDK5以后的针对线程的锁定操作和释放操作</h3><p>之前的同步方法，我们学习了简单的synchronized同步代码块，还有用synchronized修饰方法，形成同步方法。还有静态同步方法。<br>现在我们要了解简单的锁机制。<br>Lock锁是JDK5之后加入的，为了更清晰的表达如何加锁和释放锁。具体的使用方法参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义锁对象</span></span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的Main方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，</span></span><br><span class="line"><span class="comment"> * 为了更清晰的表达如何加锁和释放锁,JDK5以后提供了一个新的锁对象Lock。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Lock：</span></span><br><span class="line"><span class="comment"> * void lock()： 获取锁。</span></span><br><span class="line"><span class="comment"> * void unlock():释放锁。  </span></span><br><span class="line"><span class="comment"> * ReentrantLock是Lock的实现类.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个窗口</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>Lock的主要方法还是<br>Lock<br>    &nbsp;&nbsp;&nbsp;&nbsp;  void lock()<br>    &nbsp;&nbsp;&nbsp;&nbsp;  void unlock()<br>   &nbsp;&nbsp;&nbsp;&nbsp; <font style="color:red"> ReentrantLock</font></p></blockquote><h3 id="死锁问题的描述和代码体现"><a href="#死锁问题的描述和代码体现" class="headerlink" title="死锁问题的描述和代码体现"></a>死锁问题的描述和代码体现</h3><p>死锁问题是java中一个比较重要的问题。一般面试经常会问，这个需要牢记。</p><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><blockquote><p>我们先看看这样一个生活中的例子：在一条河上有一座桥，桥面较窄，只能容纳一辆汽车通过，无法让两辆汽车并行。如果有两辆汽车A和B分别由桥的两端驶上该桥，则对于A车来说，它走过桥面左面的一段路（即占有了桥的一部分资源），要想过桥还须等待B车让出右边的桥面，此时A车不能前进；对于B车来说，它走过桥面右边的一段路（即占有了桥的一部分资源），要想过桥还须等待A车让出左边的桥面，此时B车也不能前进。两边的车都不倒车，结果造成互相等待对方让出桥面，但是谁也不让路，就会无休止地等下去。这种现象就是死锁。如果把汽车比做进程，桥面作为资源，那麽上述问题就描述为：进程A占有资源R1，等待进程B占有的资源Rr；进程B占有资源Rr，等待进程A占有的资源R1。而且资源R1和Rr只允许一个进程占用，即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。  </p></blockquote><h4 id="死锁的原因"><a href="#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h4><p>主要有以下四个必要条件。总的来说死锁的原因还是资源的相互占有，无法释放。</p><blockquote><ol><li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li><li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，⋯⋯，Pn正在等待已被P0占用的资源。即肯定存在相互等待的死循环。</li></ol></blockquote><h4 id="死锁的代码"><a href="#死锁的代码" class="headerlink" title="死锁的代码"></a>死锁的代码</h4><p>DieLock的实现（zhonmgdi）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_02;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DieLock</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">private boolean flag;</span><br><span class="line"></span><br><span class="line">public DieLock(boolean flag) &#123;</span><br><span class="line"><span class="keyword">this</span>.flag = flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">synchronized (MyLock.objA) &#123;</span><br><span class="line">System.out.println(<span class="string">"if objA"</span>);</span><br><span class="line">synchronized (MyLock.objB) &#123;</span><br><span class="line">System.out.println(<span class="string">"if objB"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">synchronized (MyLock.objB) &#123;</span><br><span class="line">System.out.println(<span class="string">"else objB"</span>);</span><br><span class="line">synchronized (MyLock.objA) &#123;</span><br><span class="line">System.out.println(<span class="string">"else objA"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MyLock—-&gt;创建锁对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_02;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建两把锁对象</span></span><br><span class="line">public <span class="keyword">static</span> final <span class="built_in">Object</span> objA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">public <span class="keyword">static</span> final <span class="built_in">Object</span> objB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Demo类，开启线程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 同步的弊端：</span></span><br><span class="line"><span class="comment"> * A:效率低</span></span><br><span class="line"><span class="comment"> * B:容易产生死锁</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 死锁：</span></span><br><span class="line"><span class="comment"> * 两个或两个以上的线程在争夺资源的过程中，发生的一种相互等待的现象。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 举例：</span></span><br><span class="line"><span class="comment"> * 中国人，美国人吃饭案例。</span></span><br><span class="line"><span class="comment"> * 正常情况：</span></span><br><span class="line"><span class="comment"> * 中国人:筷子两支</span></span><br><span class="line"><span class="comment"> * 美国人:刀和叉</span></span><br><span class="line"><span class="comment"> * 现在：</span></span><br><span class="line"><span class="comment"> * 中国人：筷子1支，刀一把</span></span><br><span class="line"><span class="comment"> * 美国人：筷子1支，叉一把</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DieLockDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">DieLock dl1 = <span class="keyword">new</span> DieLock(<span class="literal">true</span>);</span><br><span class="line">DieLock dl2 = <span class="keyword">new</span> DieLock(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">dl1.start();</span><br><span class="line">dl2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="生产者和消费者多线程体现-线程间通信问题"><a href="#生产者和消费者多线程体现-线程间通信问题" class="headerlink" title="生产者和消费者多线程体现(线程间通信问题)"></a>生产者和消费者多线程体现(线程间通信问题)</h3><p>具体的生产者消费者的模式如下图：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-17/63313147.jpg" alt=""><br>以学生作为资源来实现的</p><pre><code>资源类：Student设置数据类：SetThread(生产者)获取数据类：GetThread(消费者)测试类：StudentDemo</code></pre><p><img src="https://images2015.cnblogs.com/blog/868641/201703/868641-20170303152707641-1755807475.png" alt=""><br>上图就是对生产者消费者的解释。<br>具体的代码实现：<br>Student<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="built_in">String</span> name;</span><br><span class="line">int age;</span><br><span class="line">boolean flag; <span class="comment">// 默认情况是没有数据，如果是true，说明有数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SetThread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SetThread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">private Student s;</span><br><span class="line">private int x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">public SetThread(Student s) &#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">synchronized (s) &#123;</span><br><span class="line"><span class="comment">//判断有没有</span></span><br><span class="line"><span class="keyword">if</span>(s.flag)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.wait(); <span class="comment">//t1等着，释放锁</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">s.name = <span class="string">"林青霞"</span>;</span><br><span class="line">s.age = <span class="number">27</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s.name = <span class="string">"刘意"</span>;</span><br><span class="line">s.age = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line">x++; <span class="comment">//x=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改标记</span></span><br><span class="line">s.flag = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//唤醒线程</span></span><br><span class="line">s.notify(); <span class="comment">//唤醒t2,唤醒并不表示你立马可以执行，必须还得抢CPU的执行权。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//t1有，或者t2有</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetThread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">private Student s;</span><br><span class="line"></span><br><span class="line">public GetThread(Student s) &#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">synchronized (s) &#123;</span><br><span class="line"><span class="keyword">if</span>(!s.flag)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.wait(); <span class="comment">//t2就等待了。立即释放锁。将来醒过来的时候，是从这里醒过来的时候</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(s.name + <span class="string">"---"</span> + s.age);</span><br><span class="line"><span class="comment">//林青霞---27</span></span><br><span class="line"><span class="comment">//刘意---30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改标记</span></span><br><span class="line">s.flag = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//唤醒线程</span></span><br><span class="line">s.notify(); <span class="comment">//唤醒t1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StudentDemo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> * 资源类：Student</span></span><br><span class="line"><span class="comment"> * 设置学生数据:SetThread(生产者)</span></span><br><span class="line"><span class="comment"> * 获取学生数据：GetThread(消费者)</span></span><br><span class="line"><span class="comment"> * 测试类:StudentDemo</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题1：按照思路写代码，发现数据每次都是:null---0</span></span><br><span class="line"><span class="comment"> * 原因：我们在每个线程中都创建了新的资源,而我们要求的时候设置和获取线程的资源应该是同一个</span></span><br><span class="line"><span class="comment"> * 如何实现呢?</span></span><br><span class="line"><span class="comment"> * 在外界把这个数据创建出来，通过构造方法传递给其他的类。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题2：为了数据的效果好一些，我加入了循环和判断，给出不同的值,这个时候产生了新的问题</span></span><br><span class="line"><span class="comment"> * A:同一个数据出现多次</span></span><br><span class="line"><span class="comment"> * B:姓名和年龄不匹配</span></span><br><span class="line"><span class="comment"> * 原因：</span></span><br><span class="line"><span class="comment"> * A:同一个数据出现多次</span></span><br><span class="line"><span class="comment"> * CPU的一点点时间片的执行权，就足够你执行很多次。</span></span><br><span class="line"><span class="comment"> * B:姓名和年龄不匹配</span></span><br><span class="line"><span class="comment"> * 线程运行的随机性</span></span><br><span class="line"><span class="comment"> * 线程安全问题：</span></span><br><span class="line"><span class="comment"> * A:是否是多线程环境是</span></span><br><span class="line"><span class="comment"> * B:是否有共享数据是</span></span><br><span class="line"><span class="comment"> * C:是否有多条语句操作共享数据是</span></span><br><span class="line"><span class="comment"> * 解决方案：</span></span><br><span class="line"><span class="comment"> * 加锁。</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * A:不同种类的线程都要加锁。</span></span><br><span class="line"><span class="comment"> * B:不同种类的线程加的锁必须是同一把。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题3:虽然数据安全了，但是呢，一次一大片不好看，我就想依次的一次一个输出。</span></span><br><span class="line"><span class="comment"> * 如何实现呢?</span></span><br><span class="line"><span class="comment"> * 通过Java提供的等待唤醒机制解决。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 等待唤醒：</span></span><br><span class="line"><span class="comment"> * Object类中提供了三个方法：</span></span><br><span class="line"><span class="comment"> * wait():等待</span></span><br><span class="line"><span class="comment"> * notify():唤醒单个线程</span></span><br><span class="line"><span class="comment"> * notifyAll():唤醒所有线程</span></span><br><span class="line"><span class="comment"> * 为什么这些方法不定义在Thread类中呢?</span></span><br><span class="line"><span class="comment"> * 这些方法的调用必须通过锁对象调用，而我们刚才使用的锁对象是任意锁对象。</span></span><br><span class="line"><span class="comment"> * 所以，这些方法必须定义在Object类中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">//创建资源</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取的类</span></span><br><span class="line">SetThread st = <span class="keyword">new</span> SetThread(s);</span><br><span class="line">GetThread gt = <span class="keyword">new</span> GetThread(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程类</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(gt);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是具体的实现方法和操作，其中的注释可以参考着观看，有助于理解程序代码。</p><h3 id="线程的转化状态"><a href="#线程的转化状态" class="headerlink" title="线程的转化状态"></a>线程的转化状态</h3><p>主要参考下图<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-17/99854255.jpg" alt=""></p><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>线程组（ThreadGroup）就是由线程组成的管理线程的类，这个类是java.lang.ThreadGroup类。</p><blockquote><p>在Java中每一个线程都归属于某个线程组管理的一员，例如在主函数main()主工作流程中产生一个线程，则产生的线程属于main这个线程组管理的一员。<br>定义一个线程组，通过以下代码可以实现。<br>ThreadGroup group=new ThreadGroup(“group”);<br>Thread thread=new Thread(group,”the first thread of group”);<br>具体的java例子代码可以见下：</p></blockquote><p>MyRunnable—–&gt;实现线程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_06;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadGroupDemo—–&gt;首先先构建一个线程组，然后在线程构造的时候指定线程组，设置好线程可以通过tg.getThreadGroup().getName()获取当前的线程组名称。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_06;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程组： 把多个线程组合到一起。</span></span><br><span class="line"><span class="comment"> * 它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// method1();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们如何修改线程所在的组呢?</span></span><br><span class="line"><span class="comment">// 创建一个线程组</span></span><br><span class="line"><span class="comment">// 创建其他线程的时候，把其他线程的组指定为我们自己新建线程组</span></span><br><span class="line">method2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// t1.start();</span></span><br><span class="line"><span class="comment">// t2.start();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> method2() &#123;</span><br><span class="line"><span class="comment">// ThreadGroup(String name)</span></span><br><span class="line">ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">"这是一个新的组"</span>);</span><br><span class="line"></span><br><span class="line">MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"><span class="comment">// Thread(ThreadGroup group, Runnable target, String name)</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(tg, my, <span class="string">"林青霞"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(tg, my, <span class="string">"刘意"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(t1.getThreadGroup().getName());</span><br><span class="line">System.out.println(t2.getThreadGroup().getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过组名称设置后台线程，表示该组的线程都是后台线程</span></span><br><span class="line">tg.setDaemon(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> method1() &#123;</span><br><span class="line">MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(my, <span class="string">"林青霞"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(my, <span class="string">"刘意"</span>);</span><br><span class="line"><span class="comment">// 我不知道他们属于那个线程组,我想知道，怎么办</span></span><br><span class="line"><span class="comment">// 线程类里面的方法：public final ThreadGroup getThreadGroup()</span></span><br><span class="line">ThreadGroup tg1 = t1.getThreadGroup();</span><br><span class="line">ThreadGroup tg2 = t2.getThreadGroup();</span><br><span class="line"><span class="comment">// 线程组里面的方法：public final String getName()</span></span><br><span class="line"><span class="built_in">String</span> name1 = tg1.getName();</span><br><span class="line"><span class="built_in">String</span> name2 = tg2.getName();</span><br><span class="line">System.out.println(name1);</span><br><span class="line">System.out.println(name2);</span><br><span class="line"><span class="comment">// 通过结果我们知道了：线程默认情况下属于main线程组</span></span><br><span class="line"><span class="comment">// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组</span></span><br><span class="line">System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。</p><h4 id="线程池的实现方法"><a href="#线程池的实现方法" class="headerlink" title="线程池的实现方法"></a>线程池的实现方法</h4><blockquote><p>线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。<br>在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池</p></blockquote><h5 id="线程池具体方法"><a href="#线程池具体方法" class="headerlink" title="线程池具体方法"></a>线程池具体方法</h5><p>JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法</p><pre><code>public static ExecutorService newCachedThreadPool()创建一个具有缓存功能的线程池缓存：百度浏览过的信息再次访问public static ExecutorService newFixedThreadPool(int nThreads)创建一个可重用的，具有固定线程数的线程池public static ExecutorService newSingleThreadExecutor()创建一个只有单线程的线程池，相当于上个方法的参数是1    </code></pre><p>这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法</p><pre><code>Future&lt;?&gt; submit(Runnable task)&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></pre><h5 id="线程池的代码实现"><a href="#线程池的代码实现" class="headerlink" title="线程池的代码实现"></a>线程池的代码实现</h5><p>MyRunnable接口实现线程。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ExecutorsDemo<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程池的好处：线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如何实现线程的代码呢?</span></span><br><span class="line"><span class="comment"> * A:创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line"><span class="comment"> * public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment"> * B:这种线程池的线程可以执行：</span></span><br><span class="line"><span class="comment"> * 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line"><span class="comment"> * 做一个类实现Runnable接口。</span></span><br><span class="line"><span class="comment"> * C:调用如下方法即可</span></span><br><span class="line"><span class="comment"> * Future&lt;?&gt; submit(Runnable task)</span></span><br><span class="line"><span class="comment"> *&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</span></span><br><span class="line"><span class="comment"> *D:我就要结束，可以吗?</span></span><br><span class="line"><span class="comment"> *可以。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// 创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line"><span class="comment">// public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多线程的面试题"><a href="#多线程的面试题" class="headerlink" title="多线程的面试题"></a>多线程的面试题</h3><p>具体的面试题可以参考我的往期文章：<a href="https://blog.jh0904.top/2018/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" rel="noopener">多线程面试题</a></p><p>在看面试题的时候，要注意，自己是否是自己真的理解了透彻了。先去思考问题，再去想自己的语言如何回答，自己如果面试遇到这种问题了应该如何处理。之后再去看答案和解析，这样更有收获，一起加油ヾ(◍°∇°◍)ﾉﾞ。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是多线程的第二篇文章，主要介绍一写java多线程的简单锁机制和死锁、线程池等一些概念，多线程的高级部分过一段时间加上。&lt;/p&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程（一）</title>
    <link href="http://yoursite.com/2018/07/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/16/多线程（一）/</id>
    <published>2018-07-16T15:55:35.000Z</published>
    <updated>2018-07-16T15:57:02.647Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h2 id="多线程-一"><a href="#多线程-一" class="headerlink" title="多线程(一)"></a>多线程(一)</h2><h3 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h3><p>多线程：一个应用程序有多条执行路径<br>        进程：正在执行的应用程序<br>        线程：进程的执行单元，执行路径<br>        单线程：一个应用程序只有一条执行路径<br>        多线程：一个应用程序有多条执行路径</p><blockquote><p>并发和并行的区别：简单的说，并行是指同一时刻同时做多件事情，而并发是指同一时间间隔内做多件事情。</p><font style="color:red;font-size:12px">  并发是两个任务可以在重叠的时间段内启动，运行和完成。并行是任务在同一时间运行，例如，在多核处理器上。<br>并发是独立执行过程的组合，而并行是同时执行（可能相关的）计算。<br>并发是一次处理很多事情，并行是同时做很多事情。<br>应用程序可以是并发的，但不是并行的，这意味着它可以同时处理多个任务，但是没有两个任务在同一时刻执行。<br>应用程序可以是并行的，但不是并发的，这意味着它同时处理多核CPU中的任务的多个子任务。<br>一个应用程序可以即不是并行的，也不是并发的，这意味着它一次一个地处理所有任务。<br>应用程序可以即是并行的也是并发的，这意味着它同时在多核CPU中同时处理多个任务。</font></blockquote><h4 id="多进程的意义"><a href="#多进程的意义" class="headerlink" title="多进程的意义?"></a>多进程的意义?</h4><p>单进程的计算机只能做一件事情,而我们现在的计算机都可以做多件事情。<br>    举例:一边玩游戏(游戏进程),一边听音乐(音乐进程)。<br>    也就是说现在的计算机都是支持多进程的,可以在一个时间段内执行多个任务。<br>    并且呢,可以提高CPU的使用率。</p><h4 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义?"></a>多线程的意义?</h4><p>多线程的存在,不是提高程序的执行速度。其实是为了提高应用程序的使用率。<br>    程序的执行其实都是在抢CUP的资源,CPU的执行权。<br>    多个进程是在抢这个资源,而其中的某一个进程如果执行路径比较多,就会有更高的几率抢到CPU的执行权。<br>    我们是不敢保证哪一个线程在哪个时刻抢到,所以线程的执行有随机性。<br>    举例:一个美女抛绣球(CPU执行权),A,B,C…等,ABC(进程)三个人抢绣球(CPU执行权),但是由于B(进程)使用分身术(多条执行路径),而他抢到绣球的机率将会很高,但是不一定能抢到</p><h3 id="Java程序的运行原理及JVM的启动是多线程的吗"><a href="#Java程序的运行原理及JVM的启动是多线程的吗" class="headerlink" title="Java程序的运行原理及JVM的启动是多线程的吗?"></a>Java程序的运行原理及JVM的启动是多线程的吗?</h3><ol><li>Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。</li><li>JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。<h3 id="多线程的实现方案"><a href="#多线程的实现方案" class="headerlink" title="多线程的实现方案"></a>多线程的实现方案</h3></li><li><p>继承Thread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cn.thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/2 18:18</span></span><br><span class="line"><span class="comment"> * description:实现Thread方法，继承Thread类，然后再去重写run（）方法。</span></span><br><span class="line"><span class="comment"> * 不是所有类需要被多线程执行，run（）方法里面是被线程执行的代码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            System.out.println (getName ()+<span class="string">"------&gt;"</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep (<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace ();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* getName ()源码</span></span><br><span class="line"><span class="comment">public Thread() &#123;</span></span><br><span class="line"><span class="comment">         init(null, null, "Thread-" + nextThreadNum(), 0);</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest1 t = <span class="keyword">new</span> ThreadTest1 ();</span><br><span class="line">        ThreadTest1 t1 = <span class="keyword">new</span> ThreadTest1 ();</span><br><span class="line"></span><br><span class="line">        t.setName (<span class="string">"magic"</span>);</span><br><span class="line">        t1.setName (<span class="string">"jh"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        启动线程</span></span><br><span class="line"><span class="comment">        t.run ();</span></span><br><span class="line"><span class="comment">        t.run ();*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// java.lang.IllegalThreadStateException(非法的状态异常，相当于main线程启动了两次)</span></span><br><span class="line">       <span class="comment">/* t.start ();</span></span><br><span class="line"><span class="comment">        t.start ();*/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//如何获取线程的名称  public String getName()</span></span><br><span class="line">        t.start ();</span><br><span class="line">        t1.start ();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * run方法调用就相当于普通方法的调用，单线程的执行</span></span><br><span class="line"><span class="comment">         * 面试题：start和run的区别：</span></span><br><span class="line"><span class="comment">         * run：仅仅是封装被线程执行的代码，直接是调用是普通方法。</span></span><br><span class="line"><span class="comment">         * start：首先启动线程，然后再由JVM虚拟机调用该线程的run（）方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口<br>首先先实现一个线程，其次重写run()方法；下面这是一个卖票的多线程程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cn.thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/3 8:22</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj=<span class="keyword">new</span> Object ();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println (Thread.currentThread ().getName ()+<span class="string">"正在售票---&gt;"</span>+(count--));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>接下来是Main的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread1 my = <span class="keyword">new</span> MyThread1 ();</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread (my, <span class="string">"一号窗口"</span>);</span><br><span class="line">        Thread tt = <span class="keyword">new</span> Thread (my, <span class="string">"二号窗口"</span>);</span><br><span class="line">        Thread ttt = <span class="keyword">new</span> Thread (my, <span class="string">"三号窗口"</span>);</span><br><span class="line"></span><br><span class="line">        t.start ();</span><br><span class="line">        tt.start ();</span><br><span class="line">        ttt.start ();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>实现Callable接口<br>实现Callable接口，重写call（）方法；<br>具体代码见下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程求和案例(实现Callable接口，重写了call()方法)</span></span><br><span class="line"><span class="comment"> * Callable:是带泛型的接口。</span></span><br><span class="line"><span class="comment"> * 这里指定的泛型其实是call()方法的返回值类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= number; x++) &#123;</span><br><span class="line">sum += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多线程实现的方式3：</span></span><br><span class="line"><span class="comment"> *  A:创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line"><span class="comment"> * public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment"> * B:这种线程池的线程可以执行：</span></span><br><span class="line"><span class="comment"> * 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line"><span class="comment"> * 做一个类实现Runnable接口。</span></span><br><span class="line"><span class="comment"> * C:调用如下方法即可</span></span><br><span class="line"><span class="comment"> * Future&lt;?&gt; submit(Runnable task)</span></span><br><span class="line"><span class="comment"> *&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</span></span><br><span class="line"><span class="comment"> *D:我就要结束，可以吗?</span></span><br><span class="line"><span class="comment"> *可以。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"><span class="comment">// 创建线程池对象</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">Future&lt;Integer&gt; f1 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">100</span>));</span><br><span class="line">Future&lt;Integer&gt; f2 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// V get()</span></span><br><span class="line">Integer i1 = f1.get();</span><br><span class="line">Integer i2 = f2.get();</span><br><span class="line"></span><br><span class="line">System.out.println(i1);</span><br><span class="line">System.out.println(i2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line">pool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结：总的来说，虽然实现多线程有两种方式，但是还是推荐使用实现Runable接口的方式，让程序具有可扩展性。</p><h3 id="线程的调度和优先级问题"><a href="#线程的调度和优先级问题" class="headerlink" title="线程的调度和优先级问题"></a>线程的调度和优先级问题</h3><ol><li>线程的调度</li></ol><ul><li>分时调度，所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</li><li>抢占式调度 (Java采用的是该调度方式)，优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 </li></ul><ol start="2"><li>获取和设置线程优先级</li></ol><ul><li>默认是5</li><li>范围是1-10<br>在Java中，线程的优先级用setPriority()方法就行，线程的优先级分为1-10这10个等级，如果小于1或大于10，则抛出异常throw new IllegalArgumentException()，默认是5。<br>主要的方法是：<blockquote><p>public final int getPriority()      获取线程优先级<br>public final void setPriority(int newPriority)设置线程优先级（1-10）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriority</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>Main方法示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们的线程没有设置优先级,肯定有默认优先级。</span></span><br><span class="line"><span class="comment"> * 那么，默认优先级是多少呢?</span></span><br><span class="line"><span class="comment"> * 如何获取线程对象的优先级?</span></span><br><span class="line"><span class="comment"> * public final int getPriority():返回线程对象的优先级</span></span><br><span class="line"><span class="comment"> * 如何设置线程对象的优先级呢?</span></span><br><span class="line"><span class="comment"> * public final void setPriority(int newPriority)：更改线程的优先级。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 线程默认优先级是5。</span></span><br><span class="line"><span class="comment"> * 线程优先级的范围是：1-10。</span></span><br><span class="line"><span class="comment"> * 线程优先级高仅仅表示线程获取的 CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到比较好的效果。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * IllegalArgumentException:非法参数异常。</span></span><br><span class="line"><span class="comment"> * 抛出的异常表明向方法传递了一个不合法或不正确的参数。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriorityDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadPriority tp1 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line">ThreadPriority tp2 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line">ThreadPriority tp3 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line"></span><br><span class="line">tp1.setName(<span class="string">"东方不败"</span>);</span><br><span class="line">tp2.setName(<span class="string">"岳不群"</span>);</span><br><span class="line">tp3.setName(<span class="string">"林平之"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取默认优先级</span></span><br><span class="line"><span class="comment">// System.out.println(tp1.getPriority());</span></span><br><span class="line"><span class="comment">// System.out.println(tp2.getPriority());</span></span><br><span class="line"><span class="comment">// System.out.println(tp3.getPriority());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程优先级</span></span><br><span class="line"><span class="comment">// tp1.setPriority(100000);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置正确的线程优先级</span></span><br><span class="line">tp1.setPriority(<span class="number">10</span>);</span><br><span class="line">tp2.setPriority(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">tp1.start();</span><br><span class="line">tp2.start();</span><br><span class="line">tp3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="线程的控制-常见方法"><a href="#线程的控制-常见方法" class="headerlink" title="线程的控制(常见方法)"></a>线程的控制(常见方法)</h4><p>A:休眠线程  (public static void sleep(long millis))<br>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x + <span class="string">",日期："</span> + <span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">// 睡眠</span></span><br><span class="line"><span class="comment">// 困了，我稍微休息1秒钟</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程休眠</span></span><br><span class="line"><span class="comment"> *public static void sleep(long millis)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleepDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadSleep ts1 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">ThreadSleep ts2 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">ThreadSleep ts3 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line"></span><br><span class="line">ts1.setName(<span class="string">"林青霞"</span>);</span><br><span class="line">ts2.setName(<span class="string">"林志玲"</span>);</span><br><span class="line">ts3.setName(<span class="string">"林志颖"</span>);</span><br><span class="line"></span><br><span class="line">ts1.start();</span><br><span class="line">ts2.start();</span><br><span class="line">ts3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>B:加入线程  (public final void join())<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public final void join():等待该线程终止。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadJoin tj1 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">ThreadJoin tj2 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">ThreadJoin tj3 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line"></span><br><span class="line">tj1.setName(<span class="string">"李渊"</span>);</span><br><span class="line">tj2.setName(<span class="string">"李世民"</span>);</span><br><span class="line">tj3.setName(<span class="string">"李元霸"</span>);</span><br><span class="line"></span><br><span class="line">tj1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">tj1.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tj2.start();</span><br><span class="line">tj3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C:礼让线程  (public static void yield())<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYield</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">Thread.yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public static void yield():暂停当前正在执行的线程对象，并执行其他线程。 </span></span><br><span class="line"><span class="comment"> * 让多个线程的执行更和谐，但是不能靠它保证一人一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYieldDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadYield ty1 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line">ThreadYield ty2 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line"></span><br><span class="line">ty1.setName(<span class="string">"林青霞"</span>);</span><br><span class="line">ty2.setName(<span class="string">"刘意"</span>);</span><br><span class="line"></span><br><span class="line">ty1.start();</span><br><span class="line">ty2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>D:后台线程  (public final void setDaemon(boolean on))<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemon</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public final void setDaemon(boolean on):将该线程标记为守护线程或用户线程。</span></span><br><span class="line"><span class="comment"> * 当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 游戏：坦克大战。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemonDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadDaemon td1 = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line">ThreadDaemon td2 = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line"></span><br><span class="line">td1.setName(<span class="string">"关羽"</span>);</span><br><span class="line">td2.setName(<span class="string">"张飞"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置收获线程</span></span><br><span class="line">td1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">td2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">td1.start();</span><br><span class="line">td2.start();</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setName(<span class="string">"刘备"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>E:终止线程  (public final void stop()/public void interrupt())<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStop</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始执行："</span> + <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我要休息10秒钟，亲，不要打扰我哦</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// e.printStackTrace();</span></span><br><span class="line">System.out.println(<span class="string">"线程被终止了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"结束执行："</span> + <span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public final void stop():让线程停止，过时了，但是还可以使用。</span></span><br><span class="line"><span class="comment"> * public void interrupt():中断线程。 把线程的状态终止，并抛出一个InterruptedException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadStop ts = <span class="keyword">new</span> ThreadStop();</span><br><span class="line">ts.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你超过三秒不醒过来，我就干死你</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// ts.stop();</span></span><br><span class="line">ts.interrupt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程的生命周期-参照-线程生命周期图解-bmp"><a href="#线程的生命周期-参照-线程生命周期图解-bmp" class="headerlink" title="线程的生命周期(参照    线程生命周期图解.bmp)"></a>线程的生命周期(参照    线程生命周期图解.bmp)</h3><p>A:新建<br>B:就绪<br>C:运行<br>D:阻塞<br>E:死亡<br><strong>如图所示：</strong><br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-16/99895317.jpg" alt=""></p><h3 id="电影院卖票程序的实现"><a href="#电影院卖票程序的实现" class="headerlink" title="电影院卖票程序的实现"></a>电影院卖票程序的实现</h3><p>A:继承Thread类<br>B:实现Runnable接口</p><h3 id="电影院卖票程序出问题"><a href="#电影院卖票程序出问题" class="headerlink" title="电影院卖票程序出问题"></a>电影院卖票程序出问题</h3><ol><li>为了更符合真实的场景，加入了休眠100毫秒。</li><li>卖票问题</li></ol><ul><li>同票多次</li><li>负数票<h3 id="多线程安全问题的原因"><a href="#多线程安全问题的原因" class="headerlink" title="多线程安全问题的原因"></a>多线程安全问题的原因</h3></li><li>是否有多线程环境</li><li>是否有共享数据</li><li>是否有多条语句操作共享数据<h3 id="同步解决线程安全问题"><a href="#同步解决线程安全问题" class="headerlink" title="同步解决线程安全问题"></a>同步解决线程安全问题</h3></li></ul><ol><li><p>同步代码块</p><pre><code>synchronized(对象) {    需要被同步的代码;}</code></pre><p> 这里的锁对象可以是任意对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//创建锁对象</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//while (true) &#123;</span></span><br><span class="line"><span class="comment">//synchronized(new Object())&#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100); </span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName() + "正在出售第"</span></span><br><span class="line"><span class="comment">//+ (tickets--) + "张票");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_09;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何解决线程安全问题呢?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 要想解决问题，就要知道哪些原因会导致出问题:(而且这些原因也是以后我们判断一个程序是否会有线程安全问题的标准)</span></span><br><span class="line"><span class="comment"> * A:是否是多线程环境</span></span><br><span class="line"><span class="comment"> * B:是否有共享数据</span></span><br><span class="line"><span class="comment"> * C:是否有多条语句操作共享数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 我们来回想一下我们的程序有没有上面的问题呢?</span></span><br><span class="line"><span class="comment"> * A:是否是多线程环境是</span></span><br><span class="line"><span class="comment"> * B:是否有共享数据是</span></span><br><span class="line"><span class="comment"> * C:是否有多条语句操作共享数据是</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 由此可见我们的程序出现问题是正常的，因为它满足出问题的条件。</span></span><br><span class="line"><span class="comment"> * 接下来才是我们要想想如何解决问题呢?</span></span><br><span class="line"><span class="comment"> * A和B的问题我们改变不了，我们只能想办法去把C改变一下。</span></span><br><span class="line"><span class="comment"> * 思想：</span></span><br><span class="line"><span class="comment"> * 把多条语句操作共享数据的代码给包成一个整体，让某个线程在执行的时候，别人不能来执行。</span></span><br><span class="line"><span class="comment"> * 问题是我们不知道怎么包啊?其实我也不知道，但是Java给我们提供了：同步机制。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步代码块：</span></span><br><span class="line"><span class="comment"> * synchronized(对象)&#123;</span></span><br><span class="line"><span class="comment"> * 需要同步的代码;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * A:对象是什么呢?</span></span><br><span class="line"><span class="comment"> * 我们可以随便创建一个对象试试。</span></span><br><span class="line"><span class="comment"> * B:需要同步的代码是哪些呢?</span></span><br><span class="line"><span class="comment"> * 把多条语句操作共享数据的代码的部分给包起来</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。</span></span><br><span class="line"><span class="comment"> * 多个线程必须是同一把锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个线程对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>同步方法</p><pre><code>把同步加在方法上。</code></pre><p> 这里的锁对象是this</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义同一把锁</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// t1,t2,t3都能走到这里</span></span><br><span class="line"><span class="comment">// 假设t1抢到CPU的执行权，t1就要进来</span></span><br><span class="line"><span class="comment">// 假设t2抢到CPU的执行权，t2就要进来,发现门是关着的，进不去。所以就等着。</span></span><br><span class="line"><span class="comment">// 门(开,关)</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123; <span class="comment">// 发现这里的代码将来是会被锁上的，所以t1进来后，就锁了。(关)</span></span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>); <span class="comment">// t1就睡眠了</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line"><span class="comment">//窗口1正在出售第100张票</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//t1就出来可，然后就开门。(开)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_10;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 举例：</span></span><br><span class="line"><span class="comment"> * 火车上厕所。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步的特点：</span></span><br><span class="line"><span class="comment"> * 前提：</span></span><br><span class="line"><span class="comment"> * 多个线程</span></span><br><span class="line"><span class="comment"> *解决问题的时候要注意：</span></span><br><span class="line"><span class="comment"> *多个线程使用的是同一个锁对象</span></span><br><span class="line"><span class="comment"> * 同步的好处 </span></span><br><span class="line"><span class="comment"> *同步的出现解决了多线程的安全问题。</span></span><br><span class="line"><span class="comment"> * 同步的弊端</span></span><br><span class="line"><span class="comment"> *当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个线程对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>静态同步方法</p><pre><code>把同步加在方法上。</code></pre><p> 这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义同一把锁</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步代码块用obj做锁</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//while (true) &#123;</span></span><br><span class="line"><span class="comment">//synchronized (obj) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同步代码块用任意对象做锁</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//while (true) &#123;</span></span><br><span class="line"><span class="comment">//synchronized (d) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SellTicket.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//synchronized (d) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">sellTicket();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private void sellTicket() &#123;</span></span><br><span class="line"><span class="comment">//synchronized (d) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果一个方法一进去就看到了代码被同步了，那么我就再想能不能把这个同步加在方法上呢?</span></span><br><span class="line"><span class="comment">// private synchronized void sellTicket() &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_11;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A:同步代码块的锁对象是谁呢?</span></span><br><span class="line"><span class="comment"> * 任意对象。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * B:同步方法的格式及锁对象问题?</span></span><br><span class="line"><span class="comment"> * 把同步关键字加在方法上。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步方法是谁呢?</span></span><br><span class="line"><span class="comment"> * this</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * C:静态方法及锁对象问题?</span></span><br><span class="line"><span class="comment"> * 静态方法的锁对象是谁呢?</span></span><br><span class="line"><span class="comment"> * 类的字节码文件对象。(反射会讲)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个线程对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="回顾以前的线程安全的类"><a href="#回顾以前的线程安全的类" class="headerlink" title="回顾以前的线程安全的类"></a>回顾以前的线程安全的类</h3><blockquote><p> StringBuffer<br>Vector<br>Hashtable</p></blockquote><p>如何把一个线程不安全的集合类变成一个线程安全的集合类<br>有两种方法，首先寻找原本就线程安全的类：CopyOnWriteArrayList、ConcurrentHashMap等方法来实现。<br>用Collections工具类的方法即可。比如synchronizedSet(Set<t> s)的静态方法，具体见下图。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-16/80203006.jpg" alt=""></t></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;多线程-一&quot;&gt;&lt;a href=&quot;#多线程-一&quot; class=&quot;headerlink&quot; title=&quot;多线程(一)&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Vector、ArrayList、LinkedList之间的区别？</title>
    <link href="http://yoursite.com/2018/07/14/Vector%E3%80%81ArrayList%E3%80%81LinkedList/"/>
    <id>http://yoursite.com/2018/07/14/Vector、ArrayList、LinkedList/</id>
    <published>2018-07-14T15:11:26.000Z</published>
    <updated>2018-07-14T15:12:11.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><p><strong>Vector</strong> 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</p><p><strong>ArrayList</strong> 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。</p><p><strong>LinkedList</strong> 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>一般来说，不同容器适合不同的场景。</p><ul><li>Vector和ArrayList都是动态数组，其内部元素以数组的顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会比较差，比如我们在元素中间插入一个元素，需要移动后续所有元素。</li><li>而LinkedList进行节点插入、删除效率很高，但是随机访问性能则要比动态数组慢很多。<br>对于Vector的分析可以看我之前的文章<a href="https://blog.jh0904.top/2018/06/06/Vector%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Vector的源码解析</a>，还有我在CSDN上面写的关于ArrayList的文章：<a href="https://blog.csdn.net/qq_34123742/article/details/80137160" target="_blank" rel="noopener">ArrayList源码分析</a><br>有什么不对请大家指正，感谢❤<br><strong>集合框架的整体设计</strong><br>可以如下图所示（并没有Map。虽然通常概念上它作为集合 框架的一部分，但是本本身并不是真正的集合）：</li></ul><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-14/77561179.jpg" alt="集合框架"></p><p>我们可以看到java的集合框架，Collection接口是所有的根，然后主要扩展了三大类集合：</p><ol><li><p>List,也就是我们前面介绍最多的有序集合，它提供了方便的访问、插入、删除等操作。</p></li><li><p>SetSet 是不允许重复元素的，这是和 List 最明显的区别，也就是不存在两个对象 equals 返回 true。我们在日常开发中有很多需要保证元素唯一性的场合。</p></li></ol><ol start="3"><li>Queue则是 Java 提供的标准队列结构的实现，除了集合的基本功能，它还支持类似先入先出（FIFO， First-in-First-Out）或者后入先出（LIFO，Last-In-First-Out）等特定行为。这里不包括 BlockingQueue，因为通常是并发编程场合，所以被放置在并发包里。</li></ol><p>其实总的来说，集合框架的学习还是重在源码的学习，里面有很多优秀的设计思路，也封装了很多数据结构，并且在并发编程的时候，还要注意使用不同的集合或是使用Collections的同步方法。<br>下面我放一些我对源码解析的文章（未完待续…大家一起学习，一起进步）</p><ul><li><a href="https://blog.csdn.net/qq_34123742/article/details/80077732" target="_blank" rel="noopener">Collection概述</a></li><li><a href="https://blog.csdn.net/qq_34123742/article/details/80137160" target="_blank" rel="noopener">ArrayList源码分析</a></li><li><a href="https://blog.csdn.net/qq_34123742/article/details/80261319" target="_blank" rel="noopener">Vector源码解析</a></li><li><a href="https://blog.jh0904.top/2018/06/08/hashmap/" target="_blank" rel="noopener">HashMap的源码解析</a></li><li>未完待续</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;基本概述&quot;&gt;&lt;a href=&quot;#基本概述&quot; class=&quot;headerlink&quot; title=&quot;基本概述&quot;&gt;&lt;/a&gt;基
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>int和Integer的区别？Integer的值缓存范围？</title>
    <link href="http://yoursite.com/2018/07/13/int%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FInteger%E7%9A%84%E5%80%BC%E7%BC%93%E5%AD%98%E8%8C%83%E5%9B%B4%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/13/int和Integer的区别？Integer的值缓存范围？/</id>
    <published>2018-07-13T12:45:33.000Z</published>
    <updated>2018-07-13T12:46:38.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>int 是我们常说的整形数字，是 Java 的 8 个原始数据类型（Primitive Types），boolean、byte 、short、char、int、float、double、long之一。Java 语言虽然号称一切都是对象，但原始数据类型是例外。</p><p>Integer 是 int 对应的包装类，它有一个 int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间转换等。在 Java 5 中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。</p><p>关于 Integer 的值缓存，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，这个值默认缓存是 -128 到 127 之间。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><h4 id="理解自动拆箱，自动装箱。"><a href="#理解自动拆箱，自动装箱。" class="headerlink" title="理解自动拆箱，自动装箱。"></a>理解自动拆箱，自动装箱。</h4><p>自动装箱实际是一种语法糖，语法糖是指java平台为我们自动进行了一些转换，保证不同写法在运行时等价，它们发生在编译阶段，而且生成的字节码是一致的。<br>就像之前说的int整数，javac会替我们自动装箱为Integer.valueOf()，把拆箱自动转换成Integer.valueOf()。我们可以看一下java的class文件反编译后的结果。<br>大致的包装类有：</p><blockquote><p>int——Integer<br>float——Float<br>double——Double<br>byte——Byte<br>long——Long<br>char——Character<br>boolean——Boolean<br>short——Short</p></blockquote><p>这是一个简单的自动拆/装箱的程序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Integer i=<span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> totalprim = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反编译输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Integer i = Integer.valueOf(<span class="number">99</span>);</span><br><span class="line">i.intValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仔细观察，其实就是通过Integer.valueOf(99)实现自动装箱。i.intValue()实现自动拆箱。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1=<span class="number">100</span>;</span><br><span class="line">      Integer i2=<span class="number">100</span>;</span><br><span class="line">      Integer i3=<span class="number">300</span>;</span><br><span class="line">      Integer i4=<span class="number">300</span>;</span><br><span class="line">      System.out.println(i1==i2);<span class="comment">//true</span></span><br><span class="line">      System.out.println(i3==i4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>在源码中，Integer.valueOf(int i)的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)  </span><br><span class="line">          <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];  </span><br><span class="line">      <span class="keyword">else</span>  </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到当i&gt;=-128且i&lt;=IntegerCache.high时，直接返回IntegerCache.cache[i + 128]。其中，IntegerCache为Integer的内部静态类。我们可以清楚地看到，IntegerCache有静态成员变量cache，为一个拥有256个元素的数组。在IntegerCache中也对cache进行了初始化，即第i个元素是值为i-128的Integer对象。而-128至127是最常用的Integer对象，这样的做法也在很大程度上提高了性能。也正因为如此，“Integeri1=100;Integer i2=100;”，i1与i2得到是相同的对象。</p><p><font style="color:red"><b>也就是说在-128—127的范围内为自动拆装箱。超过范围则不会自动转换，应该注意！！！<br></b><br></font><br>其实在阿里巴巴Java开发手册中，已经有介绍：</p><blockquote><p>所有的包装类对象之间值的比较，全部使用equals方法比较。<br>说明：对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 235;</span><br><span class="line">    Integer b = 235;</span><br><span class="line">    if (a.equals(b)) &#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>整体看一下Integer的职责，主要包括各种基础的常量，比如最大值、最小值、位数等。<br>首先，java默认大小是-128-127之间，其实这个值是可以修改的，可以通过JVM参数修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-xx:AutoBoxCacheMax=N</span><br></pre></td></tr></table></figure></p><p>这些实现都体现在java.lang.Integer中，并且实现在IntegerCache的静态初始化块中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =                VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>第二，我们在分析字符串的设计实现时，提到过字符串是不可变的，保证了基本的信息安全和并发编程中的线程安全。如果你去看包装类里存储数值的成员变量“ value”，你会发现，不管是 Integer还 Boolean等，都被声明为“ private final”，所以，它们同样是不可变类型！<br>这种设计是可以理解的，或者说是必须的选择。想象一下这个应用场景，比如 Integer提供了 getInteger()方法，用于方便地读取系统属性，我们可以用属性来设置服务器某个服务的端口，如果我可以轻易地把获取到的 Integer对象改变为其他数值，这会带来产品可靠性方面的严重问题。<br>第三， Integer等包装类，定义了类似 SIZE或者 BYTES这样的常量，这反映了什么样的设计考虑呢？如果你使用过其他语言，比如 C、 C++，类似整数的位数，其实是不确定的，可能在不同的平台，比如32位或者64位平台，存在非常大的不同。那么，在32位 JDK或者64。<br>其实，这种移植对于 Java来说相对要简单些，因为原始数据类型是不存在差异的，这些明确定义在 Java语言规范里面，不管是32位还是64位环境，开发者无需担心数据的位数差异。</p><h4 id="原始类线程安全"><a href="#原始类线程安全" class="headerlink" title="原始类线程安全"></a>原始类线程安全</h4><p>原始数据类型是不是线程安全？</p><ul><li>原始数据类型的变量，显然要通过使用并发相关手段，才能保证线程安全。如果需要线程安全这样的需求，可以直接考虑使用线程安全的类，比如：AtomicInteger/AtomicLong.</li><li>特别是一些比较宽的数据类型，比如float、do，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半的数据位。</li></ul><h4 id="java原始数据类型和应用类型的局限性"><a href="#java原始数据类型和应用类型的局限性" class="headerlink" title="java原始数据类型和应用类型的局限性"></a>java原始数据类型和应用类型的局限性</h4><p>原始数据类型的一些局限性：</p><ul><li><p><strong>原始数据类型不能和java泛型配合使用。</strong><br>这是因为 Java 的泛型某种程度上可以算作伪泛型，它完全是一种编译期的技巧，Java 编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为 Object。</p></li><li><p><strong>无法高效地表达数据，也不能表达复杂的数据结构，不如vector和tuple。</strong><br>我们知道 Java 的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。<br>Java 为对象内建了各种多态、线程安全等方面的支持，但这不是所有场合的需求，尤其是数据处理重要性日益提高，更加高密度的值类型是非常现实的需求。<br>目前，针对这些方面的增强，OpenJDK也在开发中，估计之后会有更好的发展。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>动态代理基于什么原理？</title>
    <link href="http://yoursite.com/2018/07/12/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/12/动态代理基于什么原理？/</id>
    <published>2018-07-12T03:08:48.000Z</published>
    <updated>2018-07-12T03:12:02.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p><p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>这道题会让人下意识的感觉是在考反射，但是实现动态代理的方式有很多，不止是反射一种。功能才是目的，实现的方法有很多。<br>主要的考察点：</p><ul><li>考察对反射的了解程度。</li><li>动态代理解决了什么问题，应用场景是什么？</li><li>JDK的动态代理的设计和实现和cgilb的方式有什么不同，如何选择两者？</li></ul><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.<br>通过反射可以动态获取Constructors、Method、Class、Field。这些只能获取公共的方法，要想获取私有的方法，需要加上getDeclared+…，。<br>其中还有反射提供的AccessibleObject.setAccessible(boolean flag),<br>这里的Accessible可以理解为修改成修饰成员public、protected、private。可以修改为false，取消java语法检查。这意味着可以在运行时修改成员变量的访问限制。<br>setAccessible 的应用场景非常普遍，遍布我们的日常开发、测试、依赖注入等各种框架中。比如，在 O/R Mapping 框架中，我们为一个 Java 实体对象，运行时自动生成 setter、getter 的逻辑，这是加载或者持久化数据非常必要的，框架通常可以利用反射做这个事情，而不需要开发者手动写类似的重复代码。</p><blockquote><p> <font style="color:red">需要注意的是在java9以后，这个方法有一些改变，因为新增的模块化系统，处于对系统封装性的考虑，对反射进行了一些限制,Jigsaw引入了所谓的open的概念，只有当被反射对象操作的模块和指定的包对反射调用者模块open，才能使用setAccessible，否则被认为不合法（illegal）。<br> </font><br>具体的操作可以参考我写的Demo：<a href="https://https://github.com/jh0904/GitTest/tree/master/GitTest1/src/cn/reflect" target="_blank" rel="noopener">reflect</a></p></blockquote><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>代理可以看做对调用目标的一个包装，这样我们可以对目标代码的调用不是直接发生的，而是通过代理完成的。<br>动态代理的作用可以用来做AOP。可以去做一些重复的工作（比如权限呢检验，日志记录），用动态代理去抽取出来。增强代码的易用性。</p><p>具体介绍一下java里面内置的Proxy类的一些简单操作：<br>在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib。</p><p>Proxy类中的方法创建动态代理类对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure></p><p>最终会调用InvocationHandler的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler Object invoke(Object proxy,Method method,Object[] args)</span><br></pre></td></tr></table></figure></p><p>动态代理的具体实现可以参考我的GitHub：<a href="https://github.com/jh0904/GitTest/tree/master/GitTest1/src/cn/reflect/proxy" target="_blank" rel="noopener">Proxy</a>。</p><p>cgilb实现动态代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待续...</span><br></pre></td></tr></table></figure></p><p>动态代理的使用场景：<br>AOP 通过（动态）代理机制可以让开发者从这些繁琐事项中抽身出来，大幅度提高了代码的抽象程度和复用度。从逻辑上来说，我们在软件设计和实现中的类似代理，如 Facade、Observer 等很多设计目的，都可以通过动态代理优雅地实现。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-12/37239512.jpg" alt=""></p><h4 id="JDK的动态代理的设计和实现和cgilb的方式有什么不同"><a href="#JDK的动态代理的设计和实现和cgilb的方式有什么不同" class="headerlink" title="JDK的动态代理的设计和实现和cgilb的方式有什么不同?"></a>JDK的动态代理的设计和实现和cgilb的方式有什么不同?</h4><p>我大概简单介绍一下：<br><strong>对于JDK Proxy的优势：</strong></p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li><li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li><li>代码实现简单。</li></ul><p><strong>cglib框架的优势：</strong></p><ul><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder的区别？</title>
    <link href="http://yoursite.com/2018/07/11/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/11/String、StringBuffer、StringBuilder的区别？/</id>
    <published>2018-07-11T06:18:26.000Z</published>
    <updated>2018-07-11T06:19:08.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p><h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><table><thead><tr><th></th><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>对象类型</td><td>字符串常量</td><td>字符串变量</td><td>字符串变量</td></tr><tr><td>线程安全</td><td>不安全</td><td>不安全</td><td>安全</td></tr><tr><td>执行效率</td><td>低</td><td>高</td><td>中</td></tr><tr><td>使用场景</td><td>操作少，数据少</td><td>单线程，操作多，数据多</td><td>多线程，操作多，数据多</td></tr></tbody></table><h3 id="String为什么设计成final？"><a href="#String为什么设计成final？" class="headerlink" title="String为什么设计成final？"></a>String为什么设计成final？</h3><p>原因无非就是下面几点：</p><ul><li>为了实现字符串池</li><li>为了线程安全</li><li>为了实现String可以创建HashCode不可变性</li></ul><p>首先要了解final关键字的含义，在之前的文章已经介绍过什么是fina具体可以查看之前的文章：<a href="https://blog.jh0904.top/2018/07/09/final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">final、finally、finalize的区别</a><br>我大概简述一下：final可以修饰类，方法和变量，并且被修饰的类或方法，被final修饰的类不能被继承，即它不能拥有自己的子类，被final修饰的方法不能被重写， final修饰的变量，无论是类属性、对象属性、形参还是局部变量，都需要进行初始化操作。<br>字符串在内存存储的样子如下图：<br><img src="http://i.imgur.com/3zlNPQJ.png" alt=""></p><p><strong>实现字符串池</strong><br>所以只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。<br><strong>线程安全</strong><br>如果字符串是可变的，那么会引起很严重的安全问题。因为字符串是不可变的，所以它的值是不可改变的，否则改变字符串指向的对象的值，造成安全漏洞。<br>因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。<br>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。<br><strong>HashCode不可变性</strong><br>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>强引用、软引用、弱引用、幻象引用有什么区别？</title>
    <link href="http://yoursite.com/2018/07/10/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/10/强引用、软引用、弱引用、幻象引用有什么区别？/</id>
    <published>2018-07-10T03:29:45.000Z</published>
    <updated>2018-07-10T03:31:56.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h3><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o=<span class="keyword">new</span> Object();   <span class="comment">//  强引用</span></span><br></pre></td></tr></table></figure></p><p>通过关键字new创建对象，所关联的引用就是强引用。当JVM内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。<br>如果不使用时，要通过如下方式来弱化引用，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o=<span class="keyword">null</span>;     <span class="comment">// 帮助垃圾收集器回收此对象</span></span><br></pre></td></tr></table></figure></p><p>显式的将o设置为null；或者超出对象的生命周期范围，则gc认为该对象不存在引用。这样就可以被垃圾收集了，具体回收时机还是要看垃圾回收机制。<br><strong>例子：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Object o=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于上述代码，可以看出方法的内部有一个强引用，这个引用保存在栈中，真正的引用内容（Object）保存在堆中。当这个方法运行完成之后就会退出方法栈，则引用内容的引用就不存在了，这个Object会被回收。<br>但是当这个o是全局变量时，就需要在不使用这个对象时要赋值为null，因为强引用不会被垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment">   * be empty after this call returns.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">          elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个就是在java源码中的体现。就是在需要清除的时候，需要把elementData里面全部置为空，因为elementData是全局变量。</p><h3 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h3><p>是一种相对强引用的弱化一些的引用，可以让豁免一些垃圾收集，只有当JVM尝试内存不足时。才会尝试回收软引用指定的对象。JVM会确保在抛出OutOfMemoryError之前，会先清理软引用指定的对象。软引用通常用于内存敏感的高速缓存，如果还有空内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"abc"</span>);                     </span><br><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;String&gt; softRef=<span class="keyword">new</span> SoftReference&lt;String&gt;(str);</span><br><span class="line"><span class="comment">// 软引用</span></span><br></pre></td></tr></table></figure></p><p>当内存不足时，等价于：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">If(JVM.内存不足()) &#123;</span><br><span class="line">   str = <span class="keyword">null</span>;  <span class="comment">// 转换为软引用</span></span><br><span class="line">   System.gc(); <span class="comment">// 垃圾回收器进行回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h3 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h3><p>弱引用并不能对对象实现豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系。比如，维护一种非强制性的映射关系，如果试图获取时对象还存在，就使用它，否则重现实例化。它同样是对缓存实现的选择。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"abc"</span>);    </span><br><span class="line">WeakReference&lt;String&gt; abcWeakRef = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br><span class="line">str=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>当垃圾回收器进行扫描时,等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = null;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure></p><p><strong>弱引用和软引用之间的去区别</strong>：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 </p><h3 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h3><p> “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  Java4种引用的级别由高到低依次为：<br> <font style="color:red"></font></p><blockquote><p>强引用  &gt;  软引用  &gt;  弱引用  &gt;  虚引用<br></p></blockquote><p>可以看一下在垃圾回收时候的图解：</p><center><br><br><img src="https://images2015.cnblogs.com/blog/647994/201702/647994-20170215235400691-2090269215.png" alt=""><br></center><p>当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章：</p><p>通过表格来说明一下，如下：</p><table><thead><tr><th>引用类型</th><th>被垃圾回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVN停止运行时终止</td></tr><tr><td>软引用</td><td>在内存不足时</td><td>对象缓存</td><td>内存不足时终止</td></tr><tr><td>弱引用</td><td>在垃圾回收时</td><td>对象缓存</td><td>GC运行后终止</td></tr><tr><td>虚引用</td><td>Unknow</td><td>Unknow</td><td>Unknow</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;强引用（StrongReference）&quot;&gt;&lt;a href=&quot;#强引用（StrongReference）&quot; class
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>final、finally、finalize的区别</title>
    <link href="http://yoursite.com/2018/07/09/final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/07/09/final、finally、finalize的区别/</id>
    <published>2018-07-09T13:03:35.000Z</published>
    <updated>2018-07-09T13:10:37.512Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，要我说，这个面试题，其中是三个其实没有什么联系，只不过是因为长的比较像，就拉出来考…但是从另一个方面看的话，这三个关键字还是很重要的。接下来简单介绍一下。</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final可以用来修饰类、方法、变量，分别有不同的意义，final修饰的类不可以继承的扩展。final修饰的方法不可以被重写（overrride），final修饰的变量则为常量（即不可修改的量）。</p><h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3><p>finally则是java保证重点代码一定要被执行的一种机制，我们可以使用try-catch-fianlly或者try-finally来进行关闭JDBC连接、或者用于关闭一些流对象（现在也有新方法，就是try-with-catch可以不使用fianlly）。</p><h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h3><p>finalize是基础类java.lang.Object的一个方法。它的设计目的是保证对象在垃圾收集前完成特定资源的回收。JDK9中已不推荐使用。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><h3 id="深入理解final关键字"><a href="#深入理解final关键字" class="headerlink" title="深入理解final关键字"></a>深入理解final关键字</h3><p>在java类库中的定义和源码中，在java.lang包下，相当一部分被声明成final class ？因为这可以有效避免API使用者更改基础功能，某种程度上，这是保证平台安全性的必要手段。</p><ul><li>使用fianl修饰变量或者参数，也可以清楚地避免意外赋值导致的编程错误。甚至有人明确推荐将所有的方法参数、本地变量、成员变量都声明成final。</li><li>final变量产生了某种程度上的不可变（immutable）的效果,所以，可以用来保护只读数据，尤其在并发编程中，因为明确地不能再赋值fianl变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。</li></ul><p>final还有性能上的好处<br>下面这段话摘自<i>《Java编程思想》</i>第四版第143页：</p><blockquote><p>“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。</p></blockquote><font style="color:red">注：类的private方法会隐式地被指定为final方法。</font><h3 id="深入理解finally关键字"><a href="#深入理解finally关键字" class="headerlink" title="深入理解finally关键字"></a>深入理解finally关键字</h3><p>对于finally来说，最常见的还是在try-catch-finally中。在Java语言的异常处理中，finally块的作用就是为了保证无论出现什么情况，finally块里的代码一定会被执行。但是其中有一些特殊情况。比如说出现java虚拟机退出的时候。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"><span class="comment">// do something Syst... </span></span><br><span class="line">System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello,World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就像出现上面的代码的时候，finally中并不会有任何反应。<br>对于finally还有其他的问题，比如，finally中return值到底会返回谁？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(getInt());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(a / <span class="number">0</span>);</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">a = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * return a在程序执行到这一步的时候，这里不是return a而是return 30;这个返回路径就形成了。</span></span><br><span class="line"><span class="comment"> * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span></span><br><span class="line"><span class="comment"> * 再次回到以前的返回路径，继续走return 30;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">a = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//如果这样结果就是40了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// return a;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大家仔细观察，其实最后的返回值是30，并没有返回其中的40，这就是说明返回值时，还是返回的是当时的值，和finally中的值并没有关系。这个是比较重要的一点。</p><p>其中在JDK1.7中有一个新特性：try-with-resources<br>try-with-resources语句是一个声明一个或多个资源的try语句。一个资源作为一个对象，必须在程序结束之后关闭。try-with-resources语句确保在语句的最后每个资源都被关闭，任何实现了java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resource来实现异常处理和关闭资源。<br>具体使用见下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line"><span class="keyword">return</span> br.readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把需要关闭的对象写在括号中，其中要关闭的对象必须实现java.lang.AutoCloseable和java.io.Closeable。</p><h3 id="深入理解finalize方法"><a href="#深入理解finalize方法" class="headerlink" title="深入理解finalize方法"></a>深入理解finalize方法</h3><p>finalize方法是比较难理解的一个方法，其中涉及了java垃圾回收机制的一些知识。<br>java提供finalize()方法，垃圾回收器准备释放内存的时候，会先调用finalize()。</p><ul><li>对象不一定会被回收。</li><li>垃圾回收不是析构函数。</li><li>垃圾回收只与内存有关。</li><li>垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。<br>上面的解释来自《java编程思想》，本人对其了解也不是很多。有待提升。</li></ul><blockquote><p>这就是今天的内容，来自于杨晓峰老师的讲解和一些自己的理解和认识。有能力的同学可以支持一下，共同进步，共同努力。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-8/91450487.jpg" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Exception与Error的区别</title>
    <link href="http://yoursite.com/2018/07/08/Exception%E4%B8%8EError%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/07/08/Exception与Error的区别/</id>
    <published>2018-07-08T06:10:27.000Z</published>
    <updated>2018-07-09T13:11:39.076Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h2 id="标准回答"><a href="#标准回答" class="headerlink" title="标准回答"></a>标准回答</h2><p>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p><p>Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a><strong>Error</strong></h3><p>是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a><strong>Exception</strong></h3><p>又分为可检查（checked）异常和不检查（unchecked）异常</p><p>可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。</p><p>不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>我们还需要注意两个方面的问题。</p><h3 id="一、理解Throwable、Exception、Error的设计和分类"><a href="#一、理解Throwable、Exception、Error的设计和分类" class="headerlink" title="一、理解Throwable、Exception、Error的设计和分类"></a>一、理解Throwable、Exception、Error的设计和分类</h3><p>下面是一个类的结构图，有助于我们去理解和掌握下面的子类</p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-8/36114315.jpg" alt="理解Throwable"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Throwable</span><br><span class="line">|--Error严重问题，我们不处理。</span><br><span class="line">|--Exception</span><br><span class="line">|--RuntimeException运行期异常，我们需要修正代码</span><br><span class="line">|--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过</span><br></pre></td></tr></table></figure></p><p>其中需要重点理解的是NoClassDefFoundError和NoClassFoundException的区别。</p><blockquote><p><strong>NoClassDefFoundError</strong>出现的时机是当你真正使用这个类的信息的时候，当class-path上没有这个类的时候会出现.<br>如果jvm或者一个ClassLoader的实例尝试去载入一个class的定义内容（普通方法的调用或者用new去创建这个class的实例）但是没有找到这个class的信息。这个是无法捕获的。<br><strong>ClassNotFoundException</strong>出现的时机就是一些反射操作，通过名称在Runtime去动态加载这个类的信息。这个可以抛出异常。</p></blockquote><h3 id="二、掌握java语言中操作Throwable的元素和实践。"><a href="#二、掌握java语言中操作Throwable的元素和实践。" class="headerlink" title="二、掌握java语言中操作Throwable的元素和实践。"></a>二、掌握java语言中操作Throwable的元素和实践。</h3><p>比如try-catch-finally块。throw、throws关键字等。</p><p>抛出异常的一些注意事项：</p><blockquote><p>A:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)<br>B:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常<br>C:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws</p></blockquote><p><strong>编译期异常和运行期异常的区别?</strong><br>            编译期异常 必须要处理的，否则编译不通过<br>            运行期异常 可以不处理，也可以处理</p><p><strong>throw、throws的区别？</strong><br><strong>throw:</strong><br>在方法体中,后面跟的是异常对象名,并且只能抛出一个异常对象名。表示抛出异常，由方法体内的语句进行处理。<br>throw抛出的是一个异常对象，说明这里肯定有一个异常产生了<br><strong>throws:</strong><br>在方法声明后面,后面跟的是异常的类名,可以抛出多个异常，用”，”隔开。表示抛出异常，由方法调用者进行处理。<br>throws是声明方法有异常，是一种可能性，这个异常并不一定会产生</p><hr><p>简单说一下try-catch-finally的一些注意事项和面试题：</p><ol><li><p>finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了，比如System.exit(0)。</p></li><li><p>如果catch里面有return语句，请问finally里面的代码还会执行吗<br>如果会，请问是在return前，还是return后。<br>会。前。<br>准确的说，应该是在中间。<br>具体可以仔细体会下面的代码，思考一下a的值最后是多少？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(getInt());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(a / <span class="number">0</span>);</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">a = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * return a在程序执行到这一步的时候，这里不是return a而是return 30;这个返回路径就形成了。</span></span><br><span class="line"><span class="comment"> * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span></span><br><span class="line"><span class="comment"> * 再次回到以前的返回路径，继续走return 30;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">a = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//如果这样结果就是40了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// return a;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中在JDK1.7中有一个新特性：<strong>try-with-resources</strong><br>try-with-resources语句是一个声明一个或多个资源的try语句。一个资源作为一个对象，必须在程序结束之后关闭。try-with-resources语句确保在语句的最后每个资源都被关闭，任何实现了java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resource来实现异常处理和关闭资源。<br>具体使用见下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line"><span class="keyword">return</span> br.readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把需要关闭的对象写在括号中，其中要关闭的对象必须实现java.lang.AutoCloseable和java.io.Closeable。</p><hr><blockquote><p>最后，衷心感谢杨晓峰老师的讲解。很清晰和透彻，也希望大家可以支持一下。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-8/91450487.jpg" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;标准回答&quot;&gt;&lt;a href=&quot;#标准回答&quot; class=&quot;headerlink&quot; title=&quot;标准回答&quot;&gt;&lt;/a&gt;标
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://yoursite.com/2018/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/07/04/多线程/</id>
    <published>2018-07-04T02:42:32.000Z</published>
    <updated>2018-07-04T02:43:21.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-多线程-理解"><a href="#1-多线程-理解" class="headerlink" title="1:多线程(理解)"></a>1:多线程(理解)</h3><ol><li>多线程：一个应用程序有多条执行路径<pre><code>进程：正在执行的应用程序线程：进程的执行单元，执行路径单线程：一个应用程序只有一条执行路径多线程：一个应用程序有多条执行路径**多进程的意义?**    提高CPU的使用率**多线程的意义?**    提高应用程序的使用率</code></pre></li><li><p><strong>Java程序的运行原理及JVM的启动是多线程的吗</strong>?</p><p>A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。</p><p>B:JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。</p></li><li><p><strong>多线程的实现方案(自己补齐步骤及代码    掌握)</strong></p><pre><code>A:继承Thread类B:实现Runnable接口</code></pre></li><li><strong>线程的调度和优先级问题</strong><pre><code>A:线程的调度    a:分时调度    b:抢占式调度 (Java采用的是该调度方式)B:获取和设置线程优先级    a:默认是5    b:范围是1-10</code></pre></li><li><strong>线程的控制(常见方法)</strong><pre><code>A:休眠线程B:加入线程C:礼让线程D:后台线程E:终止线程(掌握)</code></pre></li><li><strong>线程的生命周期(参照    线程生命周期图解.bmp)</strong><pre><code>A:新建B:就绪C:运行D:阻塞E:死亡</code></pre></li><li><strong>电影院卖票程序的实现</strong><pre><code>A:继承Thread类B:实现Runnable接口</code></pre></li><li><strong>电影院卖票程序出问题</strong><pre><code>A:为了更符合真实的场景，加入了休眠100毫秒。B:卖票问题    a:同票多次    b:负数票</code></pre></li><li><strong>多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)</strong><pre><code>A:是否有多线程环境B:是否有共享数据C:是否有多条语句操作共享数据</code></pre></li><li><p><strong>同步解决线程安全问题</strong></p><p>A:同步代码块</p><pre><code>synchronized(对象) {    需要被同步的代码;}这里的锁对象可以是任意对象。</code></pre><p>B:同步方法</p><pre><code>把同步加在方法上。这里的锁对象是this</code></pre><p>C:静态同步方法</p><pre><code>把同步加在方法上。这里的锁对象是当前类的字节码文件对象</code></pre></li><li><strong>回顾以前的线程安全的类</strong><pre><code>A:StringBufferB:VectorC:HashtableD:如何把一个线程不安全的集合类变成一个线程安全的集合类    用Collections工具类的方法即可。</code></pre></li><li><strong>JDK5以后的针对线程的锁定操作和释放操作</strong><pre><code>Lock锁</code></pre></li><li><p><strong>死锁问题的描述和代码体现</strong></p></li><li><p><strong>生产者和消费者多线程体现(线程间通信问题)</strong></p><pre><code>以学生作为资源来实现的</code></pre><p>资源类：Student</p><pre><code>设置数据类：SetThread(生产者)获取数据类：GetThread(消费者)测试类：StudentDemo</code></pre><p>代码：</p><pre><code>A:最基本的版本，只有一个数据。B:改进版本，给出了不同的数据，并加入了同步机制C:等待唤醒机制改进该程序，让数据能够实现依次的出现    wait()    notify()    notifyAll() (多生产多消费)D:等待唤醒机制的代码优化。把数据及操作都写在了资源类中</code></pre></li><li><strong>线程组</strong></li><li><strong>线程池</strong></li><li><strong>多线程实现的第三种方案</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h2&gt;&lt;h3 id=&quot;1-多线程-理解&quot;&gt;&lt;a href=&quot;#1-多线程-理解&quot; class=&quot;headerlink&quot; title=&quot;1:多线程
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程面试题</title>
    <link href="http://yoursite.com/2018/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/07/04/多线程面试题/</id>
    <published>2018-07-03T16:03:12.000Z</published>
    <updated>2018-07-03T16:04:07.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程面试题"><a href="#多线程面试题" class="headerlink" title="多线程面试题"></a>多线程面试题</h2><h4 id="1、多线程有什么用？"><a href="#1、多线程有什么用？" class="headerlink" title="1、多线程有什么用？"></a>1、多线程有什么用？</h4><p>一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p><p>（1）发挥多核CPU的优势</p><p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p><p>（2）防止阻塞</p><p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p><p>（3）便于建模</p><p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p><h4 id="2、创建线程的方式"><a href="#2、创建线程的方式" class="headerlink" title="2、创建线程的方式"></a>2、创建线程的方式</h4><p>比较常见的一个问题了，一般就是两种：</p><p>（1）继承Thread类</p><p>（2）实现Runnable接口</p><p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。</p><h4 id="3、start-方法和run-方法的区别"><a href="#3、start-方法和run-方法的区别" class="headerlink" title="3、start()方法和run()方法的区别"></a>3、start()方法和run()方法的区别</h4><p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p><h4 id="4、Runnable接口和Callable接口的区别"><a href="#4、Runnable接口和Callable接口的区别" class="headerlink" title="4、Runnable接口和Callable接口的区别"></a>4、Runnable接口和Callable接口的区别</h4><p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p><h4 id="5、CyclicBarrier和CountDownLatch的区别"><a href="#5、CyclicBarrier和CountDownLatch的区别" class="headerlink" title="5、CyclicBarrier和CountDownLatch的区别"></a>5、CyclicBarrier和CountDownLatch的区别</h4><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p><h4 id="6、Volatile关键字的作用"><a href="#6、Volatile关键字的作用" class="headerlink" title="6、Volatile关键字的作用"></a>6、Volatile关键字的作用</h4><p>一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：</p><p>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p><p>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</p><p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p><h4 id="7、什么是线程安全"><a href="#7、什么是线程安全" class="headerlink" title="7、什么是线程安全"></a>7、什么是线程安全</h4><p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</p><p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><p>（1）不可变</p><p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p><p>（2）绝对线程安全</p><p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p><p>（3）相对线程安全</p><p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</p><p>（4）线程非安全</p><p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><h4 id="8、Java中如何获取到线程dump文件"><a href="#8、Java中如何获取到线程dump文件" class="headerlink" title="8、Java中如何获取到线程dump文件"></a>8、Java中如何获取到线程dump文件</h4><p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p><p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p><p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，</p><h4 id="9、一个线程如果出现了运行时异常会怎么样"><a href="#9、一个线程如果出现了运行时异常会怎么样" class="headerlink" title="9、一个线程如果出现了运行时异常会怎么样"></a>9、一个线程如果出现了运行时异常会怎么样</h4><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p><h4 id="10、如何在两个线程之间共享数据"><a href="#10、如何在两个线程之间共享数据" class="headerlink" title="10、如何在两个线程之间共享数据"></a>10、如何在两个线程之间共享数据</h4><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><h4 id="11、sleep方法和wait方法有什么区别"><a href="#11、sleep方法和wait方法有什么区别" class="headerlink" title="11、sleep方法和wait方法有什么区别"></a>11、sleep方法和wait方法有什么区别</h4><p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><h4 id="12、生产者消费者模型的作用是什么"><a href="#12、生产者消费者模型的作用是什么" class="headerlink" title="12、生产者消费者模型的作用是什么"></a>12、生产者消费者模型的作用是什么</h4><p>这个问题很理论，但是很重要：</p><p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</p><p>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p><p>13、ThreadLocal有什么用<br>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p><h4 id="14、为什么wait-方法和notify-notifyAll-方法要在同步块中被调用"><a href="#14、为什么wait-方法和notify-notifyAll-方法要在同步块中被调用" class="headerlink" title="14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用"></a>14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</h4><p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p><h4 id="15、wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别"><a href="#15、wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别" class="headerlink" title="15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别"></a>15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</h4><p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p><h4 id="16、为什么要使用线程池"><a href="#16、为什么要使用线程池" class="headerlink" title="16、为什么要使用线程池"></a>16、为什么要使用线程池</h4><p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p><h4 id="17、怎么检测一个线程是否持有对象监视器"><a href="#17、怎么检测一个线程是否持有对象监视器" class="headerlink" title="17、怎么检测一个线程是否持有对象监视器"></a>17、怎么检测一个线程是否持有对象监视器</h4><p>我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程。</p><h4 id="18、synchronized和ReentrantLock的区别"><a href="#18、synchronized和ReentrantLock的区别" class="headerlink" title="18、synchronized和ReentrantLock的区别"></a>18、synchronized和ReentrantLock的区别</h4><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p><p>（2）ReentrantLock可以获取各种锁的信息</p><p>（3）ReentrantLock可以灵活地实现多路通知</p><p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><h4 id="19、ConcurrentHashMap的并发度是什么"><a href="#19、ConcurrentHashMap的并发度是什么" class="headerlink" title="19、ConcurrentHashMap的并发度是什么"></a>19、ConcurrentHashMap的并发度是什么</h4><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><h4 id="20、ReadWriteLock是什么"><a href="#20、ReadWriteLock是什么" class="headerlink" title="20、ReadWriteLock是什么"></a>20、ReadWriteLock是什么</h4><p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><h4 id="21、FutureTask是什么"><a href="#21、FutureTask是什么" class="headerlink" title="21、FutureTask是什么"></a>21、FutureTask是什么</h4><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><h4 id="22、Linux环境下如何查找哪个线程使用CPU最长"><a href="#22、Linux环境下如何查找哪个线程使用CPU最长" class="headerlink" title="22、Linux环境下如何查找哪个线程使用CPU最长"></a>22、Linux环境下如何查找哪个线程使用CPU最长</h4><p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p><p>（2）top -H -p pid，顺序不能改变</p><p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><h4 id="23、Java编程写一个会导致死锁的程序"><a href="#23、Java编程写一个会导致死锁的程序" class="headerlink" title="23、Java编程写一个会导致死锁的程序"></a>23、Java编程写一个会导致死锁的程序</h4><p>第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p><p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p><p>（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p><p>（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p><p>（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p><p>这样，线程1″睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。</p><h4 id="24、怎么唤醒一个阻塞的线程"><a href="#24、怎么唤醒一个阻塞的线程" class="headerlink" title="24、怎么唤醒一个阻塞的线程"></a>24、怎么唤醒一个阻塞的线程</h4><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><h4 id="25、不可变对象对多线程有什么帮助"><a href="#25、不可变对象对多线程有什么帮助" class="headerlink" title="25、不可变对象对多线程有什么帮助"></a>25、不可变对象对多线程有什么帮助</h4><p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><h4 id="26、什么是多线程的上下文切换"><a href="#26、什么是多线程的上下文切换" class="headerlink" title="26、什么是多线程的上下文切换"></a>26、什么是多线程的上下文切换</h4><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><h4 id="27、如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#27、如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="27、如果你提交任务时，线程池队列已满，这时会发生什么"></a>27、如果你提交任务时，线程池队列已满，这时会发生什么</h4><p>如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</p><h4 id="28、Java中用到的线程调度算法是什么"><a href="#28、Java中用到的线程调度算法是什么" class="headerlink" title="28、Java中用到的线程调度算法是什么"></a>28、Java中用到的线程调度算法是什么</h4><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><h4 id="29、Thread-sleep-0-的作用是什么"><a href="#29、Thread-sleep-0-的作用是什么" class="headerlink" title="29、Thread.sleep(0)的作用是什么"></a>29、Thread.sleep(0)的作用是什么</h4><p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><h4 id="30、什么是自旋"><a href="#30、什么是自旋" class="headerlink" title="30、什么是自旋"></a>30、什么是自旋</h4><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行地非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><h4 id="31、什么是Java内存模型"><a href="#31、什么是Java内存模型" class="headerlink" title="31、什么是Java内存模型"></a>31、什么是Java内存模型</h4><p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p><p>（1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p><p>（2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p><p>（3）定义了volatile变量的使用规则</p><p>（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p><h4 id="32、什么是CAS"><a href="#32、什么是CAS" class="headerlink" title="32、什么是CAS"></a>32、什么是CAS</h4><p>CAS，全称为Compare and Set，即比较-设置。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p><h4 id="33、什么是乐观锁和悲观锁"><a href="#33、什么是乐观锁和悲观锁" class="headerlink" title="33、什么是乐观锁和悲观锁"></a>33、什么是乐观锁和悲观锁</h4><p>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><h4 id="34、什么是AQS"><a href="#34、什么是AQS" class="headerlink" title="34、什么是AQS"></a>34、什么是AQS</h4><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p><p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p><p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p><h4 id="35、单例模式的线程安全性"><a href="#35、单例模式的线程安全性" class="headerlink" title="35、单例模式的线程安全性"></a>35、单例模式的线程安全性</h4><p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p><p>（1）饿汉式单例模式的写法：线程安全</p><p>（2）懒汉式单例模式的写法：非线程安全</p><p>（3）双检锁单例模式的写法：线程安全</p><h4 id="36、Semaphore有什么作用"><a href="#36、Semaphore有什么作用" class="headerlink" title="36、Semaphore有什么作用"></a>36、Semaphore有什么作用</h4><p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p><h4 id="37、Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步？"><a href="#37、Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步？" class="headerlink" title="37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？"></a>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</h4><p>这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p><p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p><p>（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p><p>（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。</p><h4 id="38、线程类的构造方法、静态块是被哪个线程调用的"><a href="#38、线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="38、线程类的构造方法、静态块是被哪个线程调用的"></a>38、线程类的构造方法、静态块是被哪个线程调用的</h4><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><p>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p><p>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p><h4 id="39、同步方法和同步块，哪个是更好的选择"><a href="#39、同步方法和同步块，哪个是更好的选择" class="headerlink" title="39、同步方法和同步块，哪个是更好的选择"></a>39、同步方法和同步块，哪个是更好的选择</h4><p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越少越好。</p><p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><h4 id="40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"><a href="#40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？" class="headerlink" title="40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"></a>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</h4><p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p><p>（2）并发不高、任务执行时间长的业务要区分开看：</p><p>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p><p>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p><p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多线程面试题&quot;&gt;&lt;a href=&quot;#多线程面试题&quot; class=&quot;headerlink&quot; title=&quot;多线程面试题&quot;&gt;&lt;/a&gt;多线程面试题&lt;/h2&gt;&lt;h4 id=&quot;1、多线程有什么用？&quot;&gt;&lt;a href=&quot;#1、多线程有什么用？&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>初识NIO一</title>
    <link href="http://yoursite.com/2018/06/22/NIO/"/>
    <id>http://yoursite.com/2018/06/22/NIO/</id>
    <published>2018-06-22T12:05:03.000Z</published>
    <updated>2018-07-07T10:08:34.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NIO概述"><a href="#NIO概述" class="headerlink" title="NIO概述"></a>NIO概述</h2><blockquote><p>[name=magic]</p></blockquote><p>Java NIO（New IO） 是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同， NIO支持面向缓冲区的、基于通道的IO操作。 NIO将以更加高效的方式进行文件的读写操作。</p><p>JDK之后的NIO：也叫做NIO2（BIO）</p><p>  Path：路径（与平台无关）</p><p>  Paths：有一个静态方法返回路径（返回Path的静态方法）</p><pre><code>public static Path get(URI uri);</code></pre><p>  Files：提供静态方法（操作文件的工具类）</p><pre><code>public static long copy(Path source, OutputStream out)将文件中的所有字节复制到输出流。public static Path write(Path path, Iterable lines, Charset cs, OpenOption... options)将文本行写入文件。</code></pre><h2 id="NIO与IO区别"><a href="#NIO与IO区别" class="headerlink" title="NIO与IO区别"></a>NIO与IO区别</h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(Blocking IO)</td><td>非阻塞IO(Non Blocking IO)</td></tr><tr><td>(无)</td><td>选择器(Selectors)</td></tr></tbody></table><h2 id="通道和缓冲区"><a href="#通道和缓冲区" class="headerlink" title="通道和缓冲区"></a>通道和缓冲区</h2><hr><p>Java NIO系统的核心在于：通道(Channel)和(Buffer)。通道表示打开到 IO 设备(例如：套接字)的连接。若需要使用 NIO 系统，需用于连接 IO 设备的通道以及用于容纳数据区。然后操作缓冲区，对数据进行处理</p><p><strong>简而言之， Channel 负责传输， Buffer 负责存储</strong></p><h3 id="NIO缓冲区（Buffer）"><a href="#NIO缓冲区（Buffer）" class="headerlink" title="NIO缓冲区（Buffer）"></a>NIO缓冲区（Buffer）</h3><hr><h4 id="缓冲区概述"><a href="#缓冲区概述" class="headerlink" title="缓冲区概述"></a>缓冲区概述</h4><ul><li><p>缓冲区（Buffer） ：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类</p></li><li><p>Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p></li></ul><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类：</p><ul><li><p>ByteBuffer</p></li><li><p>CharBuffer</p></li><li><p>ShortBuffer</p></li><li><p>IntBuffer</p></li><li><p>LongBuffer</p></li><li><p>FloatBuffer</p></li><li><p>DoubleBuffer</p></li></ul><p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。</p><p>都是通过如下方法获取一个 Buffer对象：</p><p>static XxxBuffer allocate(int capacity) : 创建一个容量为 capacity 的 XxxBuffer 对象</p><p>Buffer 中的重要概念：</p><blockquote><p>容量 (capacity) ： 表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。</p></blockquote><blockquote><p>限制 (limit)： 第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。</p></blockquote><blockquote><p>位置 (position)： 下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制</p></blockquote><blockquote><p>标记 (mark)与重置 (reset)： 标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position</p></blockquote><blockquote><p>并且  0 &lt; mark &lt;= position &lt;=limit &lt;= capacity</p></blockquote><h4 id="1-分配一个缓冲区"><a href="#1-分配一个缓冲区" class="headerlink" title="1. 分配一个缓冲区"></a>1. 分配一个缓冲区</h4><p>要获得一个Buffer对象，你必须首先分配它，通过allocate()分配了一个10字节大小的缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-6-30/44561032.jpg" alt="allocate"></p><h4 id="2-将数据写入缓冲区"><a href="#2-将数据写入缓冲区" class="headerlink" title="2. 将数据写入缓冲区"></a>2. 将数据写入缓冲区</h4><p>将数据写入缓冲区有两种方式：</p><p>  1.利用 put() 存入数据到缓冲区中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String str = <span class="string">"abcde"</span>;</span><br><span class="line"></span><br><span class="line">buf.put(str.getBytes());</span><br></pre></td></tr></table></figure><blockquote><p>put的方法总结<br>put(byte b)：将给定单个字节写入缓冲区的当前位置<br>put(byte[] src)：将 src 中的字节写入缓冲区的当前位置<br>put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position)</p></blockquote><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-6-30/31746203.jpg" alt="allocate"></p><p>  2.将数据从 Channel写入Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read（buf）;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入缓冲区。</span></span><br></pre></td></tr></table></figure><h4 id="3-filp"><a href="#3-filp" class="headerlink" title="3. filp()"></a>3. filp()</h4><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-6-30/52177585.jpg" alt="filp()"></p><p>该flip()方法将Buffer从写入模式切换到读取模式。调用flip()将position设置为0，并将其设置为limit 刚才的位置。</p><p>换句话说，position现在标记了读取位置，并limit标记了多少字节，字符等被写入缓冲区,可以读取的字节数，字节数等限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">buf.flip();</span><br></pre></td></tr></table></figure><h4 id="4-从缓冲区读取数据"><a href="#4-从缓冲区读取数据" class="headerlink" title="4. 从缓冲区读取数据"></a>4. 从缓冲区读取数据</h4><p>有两种方法可以从Buffer中读取数据。</p><p>1.将数据从缓冲区读入通道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//从缓冲区读入通道。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write（buf）;</span><br></pre></td></tr></table></figure><p>2.使用其中一个get（）方法自己从缓冲区中读取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line"></span><br><span class="line">buf.get(dst);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, dst.length));</span><br></pre></td></tr></table></figure><blockquote><p>get的一些方法总结<br>get() ：读取单个字节<br>get(byte[] dst)：批量读取多个字节到 dst 中<br>get(int index)：读取指定索引位置的字节(不会移动 position)</p></blockquote><h4 id="5-rewind"><a href="#5-rewind" class="headerlink" title="5. rewind()"></a>5. rewind()</h4><p>Buffer.rewind() 让 position 返回到0,这样你就可以重新读取缓冲区中的所有数据。在limit保持不变，因此仍然标记多少个元素（字节，字符等），可以从被读取Buffer。</p><h4 id="6-clear（）和compact（）"><a href="#6-clear（）和compact（）" class="headerlink" title="6. clear（）和compact（）"></a>6. clear（）和compact（）</h4><p>一旦你完成了读取数据，Buffer 准备好再次写入。你可以通过调用clear()或调用compact()。</p><p>如果调用clear（），则position将设置回0并且limit会变成capacity。, 换句话说，缓冲区被清除,但是缓冲区中的数据未被清除。, 只有markers告诉您可以将数据写入缓冲区的位置。</p><p>如果在调用clear（）时缓冲区中存在未读取的数据，那么数据将处于“forgotten”，这意味着不再有任何标记，指示已读取的数据以及尚未读取的数据。</p><p>如果Buffer中仍有未读数据，并且想稍后read，需要先写一些内容，调用compact（）而不是clear（）。</p><p>compact（）将所有未读数据复制到缓冲区的开始处。, 然后它将position设置在最后一个未读元素之后。, 极限属性仍然设置为容量，就像clear（）一样。, 现在缓冲区已准备好写入，但不会覆盖未读数据。</p><h4 id="7-mark（）和reset（）"><a href="#7-mark（）和reset（）" class="headerlink" title="7. mark（）和reset（）"></a>7. mark（）和reset（）</h4><p>可以通过调用Buffer.mark()方法在Buffer中标记给定的位置。然后可以通过调用该Buffer.reset() 方法将位置重新设置回标记的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        String str = <span class="string">"abcde"</span>;</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">buf.put(str.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line"></span><br><span class="line">buf.get(dst, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(buf.position());</span><br><span class="line"></span><br><span class="line"><span class="comment">//mark() : 标记</span></span><br><span class="line"></span><br><span class="line">buf.mark();</span><br><span class="line"></span><br><span class="line">buf.get(dst, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst, <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(buf.position());</span><br><span class="line"></span><br><span class="line"><span class="comment">//reset() : 恢复到 mark 的位置</span></span><br><span class="line"></span><br><span class="line">buf.reset();</span><br><span class="line"></span><br><span class="line">System.out.println(buf.position());</span><br></pre></td></tr></table></figure><h4 id="8-equals（）和compareTo（）"><a href="#8-equals（）和compareTo（）" class="headerlink" title="8. equals（）和compareTo（）"></a>8. equals（）和compareTo（）</h4><p>可以使用equals（）和compareTo（）来比较两个缓冲区</p><p>equals()</p><p>它们是相同的类型（byte，char，int等）</p><p>它们在缓冲区中具有相同数量的剩余字节，字符等。</p><p>所有剩余的字节，字符等是相等的。</p><p>正如你所看到的，equals只比较缓冲区的一部分，而不是它内部的每一个元素。, 实际上，它只是比较缓冲区中的其余元素。</p><p>compareTo()</p><p>该compareTo()方法比较两个缓冲区的其余元素（字节，字符等），用于例如排序例程。在下列情况下，缓冲区被认为比另一个缓冲区“小”</p><p>第一个元素等于另一个缓冲区中的对应元素，小于另一个缓冲区中的元素。</p><p>所有的元素都是相等的，但第一个缓冲区在第二个缓冲区之前耗尽元素（元素较少）。</p><h4 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h4><p><strong>非直接缓冲区</strong>：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中。<br><strong>直接缓冲区</strong>：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率。</p><ol><li>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在<br>此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），<br>虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。</li><li>直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消<br>分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对<br>应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的<br>本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好<br>处时分配它们。</li><li><p>直接字节缓冲区还可以通过 FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建。该方法返回<br>MappedByteBuffer 。 Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区<br>中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在<br>访问期间或稍后的某个时间导致抛出不确定的异常。</p></li><li><p>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在<br>性能关键型代码中执行显式缓冲区管理。<br><strong>非直接缓冲区</strong>：<br><img src="https://images2015.cnblogs.com/blog/554581/201706/554581-20170626235823993-1417525264.png" alt="非直接缓冲区"><br><strong>直接缓冲区</strong>：<br><img src="https://images2015.cnblogs.com/blog/554581/201706/554581-20170626235939664-204697244.png" alt="直接缓冲区"></p></li></ol><h3 id="NIO通道-Channel"><a href="#NIO通道-Channel" class="headerlink" title="NIO通道(Channel)"></a>NIO通道(Channel)</h3><hr><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>通道（Channel）</strong>：由 java.nio.channels 包定义<br>的。 Channel 表示 IO 源与目标打开的连接。<br>Channel 类似于传统的“流”。只不过 Channel<br>本身不能直接访问数据， Channel 只能与<br>Buffer 进行交互。</p><h4 id="通道和流的区别"><a href="#通道和流的区别" class="headerlink" title="通道和流的区别"></a>通道和流的区别</h4><p>通道有点类似于流，但是还是有一些区别的：</p><ul><li>流是单向的，或者输出流或是输入流，而通道是双向的。</li><li>通道可以被异步读取和写入。</li><li>通道始终读取或写入缓冲区。</li></ul><p>总的来说可以把之前学习的的流想象成水流，数据通过水流去传输，或是往上流或者往下流（单向）。<br>可以把通道想象成轨道，轨道本身不拥有数据，其中数据的传输是依靠火车（也就是缓冲区）来传输数据。并且双向都可。</p><h4 id="Channel实现类"><a href="#Channel实现类" class="headerlink" title="Channel实现类"></a>Channel实现类</h4><blockquote><p>FileChannel：用于读取、写入、映射和操作文件的通道。</p></blockquote><blockquote><p>DatagramChannel：通过 UDP 读写网络中的数据通道。</p></blockquote><blockquote><p>SocketChannel：通过 TCP 读写网络中的数据。</p></blockquote><blockquote><p>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</p></blockquote><h4 id="获取通道"><a href="#获取通道" class="headerlink" title="获取通道"></a>获取通道</h4><p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><p>获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获<br>取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道。</p><ul><li><p>将 Buffer 中数据写入 Channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Buffer中数据写入Channel中</span></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure></li><li><p>从 Channel 读取数据到 Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从Channel中读取数据到Buffer</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure></li></ul><p>两个例子：</p><hr><p><strong>1.利用通道复制文件（非直接缓冲区）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream (<span class="string">"d:/aa.mkv"</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream (<span class="string">"d:/11.mkv"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取通道</span></span><br><span class="line">    FileChannel fisChannel = fis.getChannel ();</span><br><span class="line">    FileChannel fosChannel = fos.getChannel ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.分配指定大小缓冲区</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate (<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将同道中的数据存入缓冲区</span></span><br><span class="line">    <span class="keyword">while</span> (fisChannel.read (buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buffer.flip ();<span class="comment">//切换成读数据模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.将缓冲区数据写入通道</span></span><br><span class="line">        fosChannel.write (buffer);</span><br><span class="line">        buffer.clear ();<span class="comment">//清空缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fosChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fosChannel.close ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fisChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fisChannel.close ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fos.close ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fis.close ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2.利用直接缓冲区（只有ByteBuffer支持）完成文件的复制（内存映射文件）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"d:/aa.mkv"</span>), StandardOpenOption.READ);</span><br><span class="line">       FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"d:/2.mkv"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * StandardOpenOption.CREATE-----------&gt;不存在就创建，存在就覆盖</span></span><br><span class="line"><span class="comment">        * StandardOpenOption.CREATE_NEW-----------&gt;不存在就创建，存在就报错</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//内存映射文件</span></span><br><span class="line">       MappedByteBuffer inMappedBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</span><br><span class="line">       MappedByteBuffer outMappedBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, inChannel.size());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//直接对缓冲区进行读写操作</span></span><br><span class="line">       <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[inMappedBuf.limit()];</span><br><span class="line">       inMappedBuf.get(dst);</span><br><span class="line">       outMappedBuf.put(dst);</span><br><span class="line"></span><br><span class="line">       inChannel.close();</span><br><span class="line">       outChannel.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="分散-Scatter-和聚集-Gather"><a href="#分散-Scatter-和聚集-Gather" class="headerlink" title="分散(Scatter)和聚集(Gather)"></a>分散(Scatter)和聚集(Gather)</h4><h5 id="分散读取（Scattering-Reads）"><a href="#分散读取（Scattering-Reads）" class="headerlink" title="分散读取（Scattering Reads）"></a>分散读取（Scattering Reads）</h5><p>分散读取（Scattering Reads）是指从 Channel 中读取的数据“分散” 到多个 Buffer 中.<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-7/60456679.jpg" alt=""><br>具体代码参考下例：</p><blockquote><p>注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满</p></blockquote><h5 id="聚集写入-Gathering-Writers"><a href="#聚集写入-Gathering-Writers" class="headerlink" title="聚集写入(Gathering Writers)"></a>聚集写入(Gathering Writers)</h5><p>聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。按照顺序写入通道中。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-7/75977247.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile (<span class="string">"aa.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="comment">//获取通道</span></span><br><span class="line">        FileChannel channel = file.getChannel ();</span><br><span class="line">        <span class="comment">//分配指定大小缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate (<span class="number">100</span>);</span><br><span class="line">        ByteBuffer buffer1 = ByteBuffer.allocate (<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//分散读取</span></span><br><span class="line">        ByteBuffer[] buf = &#123;buffer, buffer1&#125;;</span><br><span class="line">        channel.read (buf);</span><br><span class="line">        <span class="keyword">for</span> (ByteBuffer byteBuffer : buf) &#123;</span><br><span class="line">            byteBuffer.flip ();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println (<span class="keyword">new</span> String (buf[<span class="number">0</span>].array (), <span class="number">0</span>, buf[<span class="number">0</span>].limit ()));</span><br><span class="line">        System.out.println (<span class="string">"--------------------------------------------------------"</span>);</span><br><span class="line">        System.out.println (<span class="keyword">new</span> String (buf[<span class="number">1</span>].array (), <span class="number">0</span>, buf[<span class="number">1</span>].limit ()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//聚集写入</span></span><br><span class="line">        RandomAccessFile rw = <span class="keyword">new</span> RandomAccessFile (<span class="string">"hy.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel channel1 = rw.getChannel ();</span><br><span class="line">        channel1.write (buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="字符集（CharSet）"><a href="#字符集（CharSet）" class="headerlink" title="字符集（CharSet）"></a>字符集（CharSet）</h4><p>编码：字符串  —-&gt;字符数组。<br>解码：字符数组—-&gt;字符串。<br>首先常见的字符集有UTF-8和GBK。解码有一个思想，就是用什么编码， 用什么解码，就不会乱码。出现乱码肯定是因为编码和解码的码制不一样。</p><ol><li><p>首先了解都有什么码制,Charset就是java中码制的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       SortedMap&lt;String, Charset&gt; stringCharsetSortedMap = Charset.availableCharsets ();</span><br><span class="line">       Set&lt;Map.Entry&lt;String, Charset&gt;&gt; entries = stringCharsetSortedMap.entrySet ();</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, Charset&gt; entry : entries) &#123;</span><br><span class="line">           System.out.println (entry.getKey () + <span class="string">"---"</span> + entry.getValue ());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>用NIO实现编码和解码</p></li></ol><p>这个就是先用GBK进行编码和解码。没有乱码问题，但是用UTF-8进行解码。就出现了乱码。<br>所以说，解决乱码的根本途径就是编码和解码一致。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> CharacterCodingException </span>&#123;</span><br><span class="line">      Charset gbk = Charset.forName (<span class="string">"GBK"</span>);</span><br><span class="line">      <span class="comment">//获取编码器</span></span><br><span class="line">      CharsetEncoder ce = gbk.newEncoder ();</span><br><span class="line">      <span class="comment">//获取解码器</span></span><br><span class="line">      CharsetDecoder cd = gbk.newDecoder ();</span><br><span class="line"></span><br><span class="line">      CharBuffer allocate = CharBuffer.allocate (<span class="number">1024</span>);</span><br><span class="line">      allocate.put (<span class="string">"爱生活爱java"</span>);</span><br><span class="line">      allocate.flip ();</span><br><span class="line">      <span class="comment">//编码</span></span><br><span class="line">      ByteBuffer encode = ce.encode (allocate);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">          System.out.println (encode.get ());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//解码</span></span><br><span class="line">      encode.flip ();</span><br><span class="line">      CharBuffer decode = cd.decode (encode);</span><br><span class="line">      System.out.println (decode.toString ());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      System.out.println (<span class="string">"------------------------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      encode.flip ();</span><br><span class="line">      Charset utf = Charset.forName (<span class="string">"UTF-8"</span>);</span><br><span class="line">      CharBuffer decode1 = utf.decode (encode);</span><br><span class="line">      System.out.println (decode1.toString ());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NIO概述&quot;&gt;&lt;a href=&quot;#NIO概述&quot; class=&quot;headerlink&quot; title=&quot;NIO概述&quot;&gt;&lt;/a&gt;NIO概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;[name=magic]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java NIO（Ne
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
</feed>
