<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>magic</title>
  
  <subtitle>jh</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-30T02:17:04.959Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>magic_jh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识NIO一</title>
    <link href="http://yoursite.com/2018/06/22/NIO/"/>
    <id>http://yoursite.com/2018/06/22/NIO/</id>
    <published>2018-06-22T12:05:03.000Z</published>
    <updated>2018-06-30T02:17:04.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NIO概述"><a href="#NIO概述" class="headerlink" title="NIO概述"></a>NIO概述</h2><p>Java NIO（New IO） 是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同， NIO支持面向缓冲区的、基于通道的IO操作。 NIO将以更加高效的方式进行文件的读写操作。</p><p>JDK之后的NIO：也叫做NIO2（BIO）</p><p>  Path：路径（与平台无关）</p><p>  Paths：有一个静态方法返回路径（返回Path的静态方法）</p><pre><code>public static Path get(URI uri);</code></pre><p>  Files：提供静态方法（操作文件的工具类）</p><pre><code>public static long copy(Path source, OutputStream out)将文件中的所有字节复制到输出流。public static Path write(Path path, Iterable lines, Charset cs, OpenOption... options)将文本行写入文件。</code></pre><h2 id="NIO与IO区别"><a href="#NIO与IO区别" class="headerlink" title="NIO与IO区别"></a>NIO与IO区别</h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(Blocking IO)</td><td>非阻塞IO(Non Blocking IO)</td></tr><tr><td>(无)</td><td>选择器(Selectors)</td></tr></tbody></table><h2 id="通道和缓冲区"><a href="#通道和缓冲区" class="headerlink" title="通道和缓冲区"></a>通道和缓冲区</h2><hr><p>Java NIO系统的核心在于：通道(Channel)和(Buffer)。通道表示打开到 IO 设备(例如：套接字)的连接。若需要使用 NIO 系统，需用于连接 IO 设备的通道以及用于容纳数据区。然后操作缓冲区，对数据进行处理</p><p><strong>简而言之， Channel 负责传输， Buffer 负责存储</strong></p><h3 id="NIO缓冲区（Buffer）"><a href="#NIO缓冲区（Buffer）" class="headerlink" title="NIO缓冲区（Buffer）"></a>NIO缓冲区（Buffer）</h3><hr><h4 id="缓冲区概述"><a href="#缓冲区概述" class="headerlink" title="缓冲区概述"></a>缓冲区概述</h4><ul><li><p>缓冲区（Buffer） ：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类</p></li><li><p>Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p></li></ul><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类：</p><ul><li><p>ByteBuffer</p></li><li><p>CharBuffer</p></li><li><p>ShortBuffer</p></li><li><p>IntBuffer</p></li><li><p>LongBuffer</p></li><li><p>FloatBuffer</p></li><li><p>DoubleBuffer</p></li></ul><p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。</p><p>都是通过如下方法获取一个 Buffer对象：</p><p>static XxxBuffer allocate(int capacity) : 创建一个容量为 capacity 的 XxxBuffer 对象</p><p>Buffer 中的重要概念：</p><blockquote><p>容量 (capacity) ： 表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。</p></blockquote><blockquote><p>限制 (limit)： 第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。</p></blockquote><blockquote><p>位置 (position)： 下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制</p></blockquote><blockquote><p>标记 (mark)与重置 (reset)： 标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position</p></blockquote><blockquote><p>并且  0 &lt; mark &lt;= position &lt;=limit &lt;= capacity</p></blockquote><h4 id="1-分配一个缓冲区"><a href="#1-分配一个缓冲区" class="headerlink" title="1. 分配一个缓冲区"></a>1. 分配一个缓冲区</h4><p>要获得一个Buffer对象，你必须首先分配它，通过allocate()分配了一个10字节大小的缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-6-30/44561032.jpg" alt="allocate"></p><h4 id="2-将数据写入缓冲区"><a href="#2-将数据写入缓冲区" class="headerlink" title="2. 将数据写入缓冲区"></a>2. 将数据写入缓冲区</h4><p>将数据写入缓冲区有两种方式：</p><p>  1.利用 put() 存入数据到缓冲区中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String str = <span class="string">"abcde"</span>;</span><br><span class="line"></span><br><span class="line">buf.put(str.getBytes());</span><br></pre></td></tr></table></figure><blockquote><p>put的方法总结<br>put(byte b)：将给定单个字节写入缓冲区的当前位置<br>put(byte[] src)：将 src 中的字节写入缓冲区的当前位置<br>put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position)</p></blockquote><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-6-30/31746203.jpg" alt="allocate"></p><p>  2.将数据从 Channel写入Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read（buf）;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入缓冲区。</span></span><br></pre></td></tr></table></figure><h4 id="3-filp"><a href="#3-filp" class="headerlink" title="3. filp()"></a>3. filp()</h4><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-6-30/52177585.jpg" alt="filp()"></p><p>该flip()方法将Buffer从写入模式切换到读取模式。调用flip()将position设置为0，并将其设置为limit 刚才的位置。</p><p>换句话说，position现在标记了读取位置，并limit标记了多少字节，字符等被写入缓冲区,可以读取的字节数，字节数等限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">buf.flip();</span><br></pre></td></tr></table></figure><h4 id="4-从缓冲区读取数据"><a href="#4-从缓冲区读取数据" class="headerlink" title="4. 从缓冲区读取数据"></a>4. 从缓冲区读取数据</h4><p>有两种方法可以从Buffer中读取数据。</p><p>1.将数据从缓冲区读入通道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//从缓冲区读入通道。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write（buf）;</span><br></pre></td></tr></table></figure><p>2.使用其中一个get（）方法自己从缓冲区中读取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line"></span><br><span class="line">buf.get(dst);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, dst.length));</span><br></pre></td></tr></table></figure><blockquote><p>get的一些方法总结<br>get() ：读取单个字节<br>get(byte[] dst)：批量读取多个字节到 dst 中<br>get(int index)：读取指定索引位置的字节(不会移动 position)</p></blockquote><h4 id="5-rewind"><a href="#5-rewind" class="headerlink" title="5. rewind()"></a>5. rewind()</h4><p>Buffer.rewind() 让 position 返回到0,这样你就可以重新读取缓冲区中的所有数据。在limit保持不变，因此仍然标记多少个元素（字节，字符等），可以从被读取Buffer。</p><h4 id="6-clear（）和compact（）"><a href="#6-clear（）和compact（）" class="headerlink" title="6. clear（）和compact（）"></a>6. clear（）和compact（）</h4><p>一旦你完成了读取数据，Buffer 准备好再次写入。你可以通过调用clear()或调用compact()。</p><p>如果调用clear（），则position将设置回0并且limit会变成capacity。, 换句话说，缓冲区被清除,但是缓冲区中的数据未被清除。, 只有markers告诉您可以将数据写入缓冲区的位置。</p><p>如果在调用clear（）时缓冲区中存在未读取的数据，那么数据将处于“forgotten”，这意味着不再有任何标记，指示已读取的数据以及尚未读取的数据。</p><p>如果Buffer中仍有未读数据，并且想稍后read，需要先写一些内容，调用compact（）而不是clear（）。</p><p>compact（）将所有未读数据复制到缓冲区的开始处。, 然后它将position设置在最后一个未读元素之后。, 极限属性仍然设置为容量，就像clear（）一样。, 现在缓冲区已准备好写入，但不会覆盖未读数据。</p><h4 id="7-mark（）和reset（）"><a href="#7-mark（）和reset（）" class="headerlink" title="7. mark（）和reset（）"></a>7. mark（）和reset（）</h4><p>可以通过调用Buffer.mark()方法在Buffer中标记给定的位置。然后可以通过调用该Buffer.reset() 方法将位置重新设置回标记的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        String str = <span class="string">"abcde"</span>;</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">buf.put(str.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line"></span><br><span class="line">buf.get(dst, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(buf.position());</span><br><span class="line"></span><br><span class="line"><span class="comment">//mark() : 标记</span></span><br><span class="line"></span><br><span class="line">buf.mark();</span><br><span class="line"></span><br><span class="line">buf.get(dst, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst, <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(buf.position());</span><br><span class="line"></span><br><span class="line"><span class="comment">//reset() : 恢复到 mark 的位置</span></span><br><span class="line"></span><br><span class="line">buf.reset();</span><br><span class="line"></span><br><span class="line">System.out.println(buf.position());</span><br></pre></td></tr></table></figure><h4 id="8-equals（）和compareTo（）"><a href="#8-equals（）和compareTo（）" class="headerlink" title="8. equals（）和compareTo（）"></a>8. equals（）和compareTo（）</h4><p>可以使用equals（）和compareTo（）来比较两个缓冲区</p><p>equals()</p><p>它们是相同的类型（byte，char，int等）</p><p>它们在缓冲区中具有相同数量的剩余字节，字符等。</p><p>所有剩余的字节，字符等是相等的。</p><p>正如你所看到的，equals只比较缓冲区的一部分，而不是它内部的每一个元素。, 实际上，它只是比较缓冲区中的其余元素。</p><p>compareTo()</p><p>该compareTo()方法比较两个缓冲区的其余元素（字节，字符等），用于例如排序例程。在下列情况下，缓冲区被认为比另一个缓冲区“小”</p><p>第一个元素等于另一个缓冲区中的对应元素，小于另一个缓冲区中的元素。</p><p>所有的元素都是相等的，但第一个缓冲区在第二个缓冲区之前耗尽元素（元素较少）。</p><h4 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h4><p><strong>非直接缓冲区</strong>：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中。<br><strong>直接缓冲区</strong>：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率。</p><ol><li>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在<br>此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），<br>虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。</li><li>直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消<br>分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对<br>应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的<br>本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好<br>处时分配它们。</li><li><p>直接字节缓冲区还可以通过 FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建。该方法返回<br>MappedByteBuffer 。 Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区<br>中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在<br>访问期间或稍后的某个时间导致抛出不确定的异常。</p></li><li><p>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在<br>性能关键型代码中执行显式缓冲区管理。<br><strong>非直接缓冲区</strong>：<br><img src="https://images2015.cnblogs.com/blog/554581/201706/554581-20170626235823993-1417525264.png" alt="非直接缓冲区"><br><strong>直接缓冲区</strong>：<br><img src="https://images2015.cnblogs.com/blog/554581/201706/554581-20170626235939664-204697244.png" alt="直接缓冲区"></p></li></ol><h3 id="NIO通道-Channel"><a href="#NIO通道-Channel" class="headerlink" title="NIO通道(Channel)"></a>NIO通道(Channel)</h3><hr><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>通道（Channel）</strong>：由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel<br>本身不能直接访问数据， Channel 只能与Buffer 进行交互。</p><h4 id="通道和流的区别"><a href="#通道和流的区别" class="headerlink" title="通道和流的区别"></a>通道和流的区别</h4><p>通道有点类似于流，但是还是有一些区别的：</p><ul><li>流是单向的，或者输出流或是输入流，而通道是双向的。</li><li>通道可以被异步读取和写入。</li><li>通道始终读取或写入缓冲区。</li></ul><p>总的来说可以把之前学习的的流想象成水流，数据通过水流去传输，或是往上流或者往下流（单向）。<br>可以把通道想象成轨道，轨道本身不拥有数据，其中数据的传输是依靠火车（也就是缓冲区）来传输数据。并且双向都可。</p><h4 id="Channel实现类"><a href="#Channel实现类" class="headerlink" title="Channel实现类"></a>Channel实现类</h4><blockquote><p>FileChannel：用于读取、写入、映射和操作文件的通道。</p></blockquote><blockquote><p>DatagramChannel：通过 UDP 读写网络中的数据通道。</p></blockquote><blockquote><p>SocketChannel：通过 TCP 读写网络中的数据。</p></blockquote><blockquote><p>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</p></blockquote><h4 id="获取通道"><a href="#获取通道" class="headerlink" title="获取通道"></a>获取通道</h4><p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><p>获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道。</p><ul><li><p>将 Buffer 中数据写入 Channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Buffer中数据写入Channel中</span></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure></li><li><p>从 Channel 读取数据到 Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从Channel中读取数据到Buffer</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure></li></ul><p>两个例子：</p><hr><p><strong>1.利用通道复制文件（非直接缓冲区）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream (<span class="string">"d:/aa.mkv"</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream (<span class="string">"d:/11.mkv"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取通道</span></span><br><span class="line">    FileChannel fisChannel = fis.getChannel ();</span><br><span class="line">    FileChannel fosChannel = fos.getChannel ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.分配指定大小缓冲区</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate (<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将同道中的数据存入缓冲区</span></span><br><span class="line">    <span class="keyword">while</span> (fisChannel.read (buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buffer.flip ();<span class="comment">//切换成读数据模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.将缓冲区数据写入通道</span></span><br><span class="line">        fosChannel.write (buffer);</span><br><span class="line">        buffer.clear ();<span class="comment">//清空缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fosChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fosChannel.close ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fisChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fisChannel.close ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fos.close ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fis.close ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2.利用直接缓冲区（只有ByteBuffer支持）完成文件的复制（内存映射文件）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"d:/aa.mkv"</span>), StandardOpenOption.READ);</span><br><span class="line">       FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"d:/2.mkv"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * StandardOpenOption.CREATE-----------&gt;不存在就创建，存在就覆盖</span></span><br><span class="line"><span class="comment">        * StandardOpenOption.CREATE_NEW-----------&gt;不存在就创建，存在就报错</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//内存映射文件</span></span><br><span class="line">       MappedByteBuffer inMappedBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</span><br><span class="line">       MappedByteBuffer outMappedBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, inChannel.size());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//直接对缓冲区进行读写操作</span></span><br><span class="line">       <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[inMappedBuf.limit()];</span><br><span class="line">       inMappedBuf.get(dst);</span><br><span class="line">       outMappedBuf.put(dst);</span><br><span class="line"></span><br><span class="line">       inChannel.close();</span><br><span class="line">       outChannel.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NIO概述&quot;&gt;&lt;a href=&quot;#NIO概述&quot; class=&quot;headerlink&quot; title=&quot;NIO概述&quot;&gt;&lt;/a&gt;NIO概述&lt;/h2&gt;&lt;p&gt;Java NIO（New IO） 是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java I
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Mysql必知必会（连接，查询，排序）</title>
    <link href="http://yoursite.com/2018/06/10/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%EF%BC%88%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%A3%80%E7%B4%A2%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/10/Mysql必知必会（连接，检索，排序）/</id>
    <published>2018-06-10T02:00:00.000Z</published>
    <updated>2018-06-10T04:24:26.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql必知必会（连接，检索，排序）"><a href="#Mysql必知必会（连接，检索，排序）" class="headerlink" title="Mysql必知必会（连接，检索，排序）"></a>Mysql必知必会（连接，检索，排序）</h1><p>分别对应Mysql必知必会3,4,5章节的内容。下面做简单的示例。</p><h2 id="连接数据库和进入"><a href="#连接数据库和进入" class="headerlink" title="连接数据库和进入"></a>连接数据库和进入</h2><ul><li>连接数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql -u ben   </span><br><span class="line">//以ben用户进入数据库  </span><br><span class="line">mysql -uroot -proot -h localhost -P 3306    </span><br><span class="line">//以root用户，root密码，本地ip，端口号3306进入mysql。</span><br><span class="line">mysql -uroot -proot   </span><br><span class="line">//默认本地，3306登录。</span><br></pre></td></tr></table></figure></li></ul><p>登录成功页面：</p><p><img src="http://i2.bvimg.com/648776/9a80d0733de45792.png" alt="Markdown"></p><p>选择数据库</p><blockquote><p>SHOW DATABASES;</p></blockquote><p>  //显示所有表空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| demo               |</span><br><span class="line">| exam               |</span><br><span class="line">| how2java           |</span><br><span class="line">| jh                 |</span><br><span class="line">| magic              |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| root               |</span><br><span class="line">| ssh                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><blockquote><p>USE jh</p></blockquote><p>  //使用jh数据库表空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use jh;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><blockquote><p>show tables;</p></blockquote><p>  //显示jh数据库中有哪些表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+--------------+</span><br><span class="line">| Tables_in_jh |</span><br><span class="line">+--------------+</span><br><span class="line">| category     |</span><br><span class="line">| customers    |</span><br><span class="line">| knowledge    |</span><br><span class="line">| orderitems   |</span><br><span class="line">| orders       |</span><br><span class="line">| productnotes |</span><br><span class="line">| products     |</span><br><span class="line">| user         |</span><br><span class="line">| vendors      |</span><br><span class="line">+--------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><blockquote><p>SHOW COLUMNS FROM customers<br>//查看表结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW COLUMNS FROM customers;</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">| Field        | Type      | Null | Key | Default | Extra          |</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">| cust_id      | int(11)   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| cust_name    | char(50)  | NO   |     | NULL    |                |</span><br><span class="line">| cust_address | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_city    | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_state   | char(5)   | YES  |     | NULL    |                |</span><br><span class="line">| cust_zip     | char(10)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_country | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_contact | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_email   | char(255) | YES  |     | NULL    |                |</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">9 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></p></blockquote><p>其实还有一些数据库的show语句：</p><blockquote><p>SHOW STATUS;   //显示服务器状态</p></blockquote><blockquote><p>SHOW CREATE DATABASE  ||  SHOW CREATE TABLE;  //显示特定数据库或表的语句</p></blockquote><blockquote><p>SHOW GRANTS;  //显示授权用户的安全权限</p></blockquote><blockquote><p>SHOW ERROR || SHOW WARNINGS;    //显示服务器错误和警告</p></blockquote><blockquote><p>DESC product;<br>查看表结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC products;</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra |</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">| prod_id    | char(10)     | NO   | PRI | NULL    |       |</span><br><span class="line">| vend_id    | int(11)      | NO   | MUL | NULL    |       |</span><br><span class="line">| prod_name  | char(255)    | NO   |     | NULL    |       |</span><br><span class="line">| prod_price | decimal(8,2) | NO   |     | NULL    |       |</span><br><span class="line">| prod_desc  | text         | YES  |     | NULL    |       |</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="数据库的查询"><a href="#数据库的查询" class="headerlink" title="数据库的查询"></a>数据库的查询</h2><p>select语句是用来从数据库中查询的语句，也是最重要的语句。<br>简单的说一下sql语句的一些要求:</p><ul><li>结束sql语句，用(;)号隔开；多条语句也是。</li><li>SQL语句不区分大小写，但是尽量在SQL关键字的时候使用大写，便于阅读和区分。</li><li>处理SQL语句的时候，其中所有的空格都被忽略，可以把所有语句写在一行，但是便于阅读，尽量分行写。<h3 id="检索单个列"><a href="#检索单个列" class="headerlink" title="检索单个列"></a>检索单个列</h3><blockquote><p>SELECT prod_name FROM products;</p></blockquote></li></ul><p>这个语句就是检索products中的  prod_name  这一列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">| prod_name      |</span><br><span class="line">+----------------+</span><br><span class="line">| .5 ton anvil   |</span><br><span class="line">| 1 ton anvil    |</span><br><span class="line">| 2 ton anvil    |</span><br><span class="line">| Detonator      |</span><br><span class="line">| Bird seed      |</span><br><span class="line">| Carrots        |</span><br><span class="line">| Fuses          |</span><br><span class="line">| JetPack 1000   |</span><br><span class="line">| JetPack 2000   |</span><br><span class="line">| Oil can        |</span><br><span class="line">| Safe           |</span><br><span class="line">| Sling          |</span><br><span class="line">| TNT (1 stick)  |</span><br><span class="line">| TNT (5 sticks) |</span><br><span class="line">+----------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h3><blockquote><p>select prod_id,prod_name,prod_price from products;</p></blockquote><p>这个语句就是检索products中的  prod_name,prod_name,prod_price  三列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id,prod_name,prod_price from products;</span><br><span class="line">+---------+----------------+------------+</span><br><span class="line">| prod_id | prod_name      | prod_price |</span><br><span class="line">+---------+----------------+------------+</span><br><span class="line">| ANV01   | .5 ton anvil   |       5.99 |</span><br><span class="line">| ANV02   | 1 ton anvil    |       9.99 |</span><br><span class="line">| ANV03   | 2 ton anvil    |      14.99 |</span><br><span class="line">| DTNTR   | Detonator      |      13.00 |</span><br><span class="line">| FB      | Bird seed      |      10.00 |</span><br><span class="line">| FC      | Carrots        |       2.50 |</span><br><span class="line">| FU1     | Fuses          |       3.42 |</span><br><span class="line">| JP1000  | JetPack 1000   |      35.00 |</span><br><span class="line">| JP2000  | JetPack 2000   |      55.00 |</span><br><span class="line">| OL1     | Oil can        |       8.99 |</span><br><span class="line">| SAFE    | Safe           |      50.00 |</span><br><span class="line">| SLING   | Sling          |       4.49 |</span><br><span class="line">| TNT1    | TNT (1 stick)  |       2.50 |</span><br><span class="line">| TNT2    | TNT (5 sticks) |      10.00 |</span><br><span class="line">+---------+----------------+------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h3><p>这个使用了通配符（*），这个代表所有的意思。</p><blockquote><p>select * from products;</p></blockquote><p>检索products的所有信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from products;</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">| prod_id | vend_id | prod_name      | prod_price | prod_desc                                                      |</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">| ANV01   |    1001 | .5 ton anvil   |       5.99 | .5 ton anvil, black, complete with handy hook                  |</span><br><span class="line">| ANV02   |    1001 | 1 ton anvil    |       9.99 | 1 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| ANV03   |    1001 | 2 ton anvil    |      14.99 | 2 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| DTNTR   |    1003 | Detonator      |      13.00 | Detonator (plunger powered), fuses not included                |</span><br><span class="line">| FB      |    1003 | Bird seed      |      10.00 | Large bag (suitable for road runners)                          |</span><br><span class="line">| FC      |    1003 | Carrots        |       2.50 | Carrots (rabbit hunting season only)                           |</span><br><span class="line">| FU1     |    1002 | Fuses          |       3.42 | 1 dozen, extra long                                            |</span><br><span class="line">| JP1000  |    1005 | JetPack 1000   |      35.00 | JetPack 1000, intended for single use                          |</span><br><span class="line">| JP2000  |    1005 | JetPack 2000   |      55.00 | JetPack 2000, multi-use                                        |</span><br><span class="line">| OL1     |    1002 | Oil can        |       8.99 | Oil can, red                                                   |</span><br><span class="line">| SAFE    |    1003 | Safe           |      50.00 | Safe with combination lock                                     |</span><br><span class="line">| SLING   |    1003 | Sling          |       4.49 | Sling, one size fits all                                       |</span><br><span class="line">| TNT1    |    1003 | TNT (1 stick)  |       2.50 | TNT, red, single stick                                         |</span><br><span class="line">| TNT2    |    1003 | TNT (5 sticks) |      10.00 | TNT, red, pack of 10 sticks                                    |</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="检索不同行"><a href="#检索不同行" class="headerlink" title="检索不同行"></a>检索不同行</h3><p>比如我们要查询的数据中，有多个重复的数据，我们只想要不同的数据。</p><blockquote><p>select vend_id from products;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_id from products;</span><br><span class="line">+---------+</span><br><span class="line">| vend_id |</span><br><span class="line">+---------+</span><br><span class="line">|    1001 |</span><br><span class="line">|    1001 |</span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">|    1005 |</span><br><span class="line">+---------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>很明显很多数据是无用的。我们现在要来剔除这些重复。我们要使用这个关键字：distinct；要注意的是不能同时使用distinct限制多行， select distinct vend_id，prod_price from products;</p><blockquote><p>select distinct vend_id from products;除非两列都相同，否则都会被查出来。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select distinct vend_id from products;</span><br><span class="line">+---------+</span><br><span class="line">| vend_id |</span><br><span class="line">+---------+</span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">+---------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="限制结果-分页"><a href="#限制结果-分页" class="headerlink" title="限制结果(分页)"></a>限制结果(分页)</h3><blockquote><p>select prod_name from products limit 0,5;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name from products limit 0,5;</span><br><span class="line">+--------------+</span><br><span class="line">| prod_name    |</span><br><span class="line">+--------------+</span><br><span class="line">| .5 ton anvil |</span><br><span class="line">| 1 ton anvil  |</span><br><span class="line">| 2 ton anvil  |</span><br><span class="line">| Detonator    |</span><br><span class="line">| Bird seed    |</span><br><span class="line">+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>其中 0是开始位置，5是显示长度。</p><h2 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h2><h3 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h3><blockquote><p>select prod_name from products order by prod_name;</p></blockquote><p>把查询到的数据按照prod_name排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name from products order by prod_name;</span><br><span class="line">+----------------+</span><br><span class="line">| prod_name      |</span><br><span class="line">+----------------+</span><br><span class="line">| .5 ton anvil   |</span><br><span class="line">| 1 ton anvil    |</span><br><span class="line">| 2 ton anvil    |</span><br><span class="line">| Bird seed      |</span><br><span class="line">| Carrots        |</span><br><span class="line">| Detonator      |</span><br><span class="line">| Fuses          |</span><br><span class="line">| JetPack 1000   |</span><br><span class="line">| JetPack 2000   |</span><br><span class="line">| Oil can        |</span><br><span class="line">| Safe           |</span><br><span class="line">| Sling          |</span><br><span class="line">| TNT (1 stick)  |</span><br><span class="line">| TNT (5 sticks) |</span><br><span class="line">+----------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="多个序列排序"><a href="#多个序列排序" class="headerlink" title="多个序列排序"></a>多个序列排序</h3><blockquote><p>select prod_id,prod_price,prod_name from products order by prod_price,prod_name;</p></blockquote><p>这个例子其实要这样子理解，就是只有在prod_price有相同的情况下，然后取按照prod_name排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id,prod_price,prod_name from products order by prod_price,prod_name;</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">| FU1     |       3.42 | Fuses          |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| ANV01   |       5.99 | .5 ton anvil   |</span><br><span class="line">| OL1     |       8.99 | Oil can        |</span><br><span class="line">| ANV02   |       9.99 | 1 ton anvil    |</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">| DTNTR   |      13.00 | Detonator      |</span><br><span class="line">| ANV03   |      14.99 | 2 ton anvil    |</span><br><span class="line">| JP1000  |      35.00 | JetPack 1000   |</span><br><span class="line">| SAFE    |      50.00 | Safe           |</span><br><span class="line">| JP2000  |      55.00 | JetPack 2000   |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="正序，倒序"><a href="#正序，倒序" class="headerlink" title="正序，倒序"></a>正序，倒序</h3><blockquote><p>select prod_id,prod_price,prod_name from products order by prod_price DESC;</p></blockquote><p>其中DESC是倒序的意思，升序就是ASC，但是ASC没有多大作用，因为默认就是ASC的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id,prod_price,prod_name from products order by prod_price DESC;</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| JP2000  |      55.00 | JetPack 2000   |</span><br><span class="line">| SAFE    |      50.00 | Safe           |</span><br><span class="line">| JP1000  |      35.00 | JetPack 1000   |</span><br><span class="line">| ANV03   |      14.99 | 2 ton anvil    |</span><br><span class="line">| DTNTR   |      13.00 | Detonator      |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| ANV02   |       9.99 | 1 ton anvil    |</span><br><span class="line">| OL1     |       8.99 | Oil can        |</span><br><span class="line">| ANV01   |       5.99 | .5 ton anvil   |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| FU1     |       3.42 | Fuses          |</span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="排序小结"><a href="#排序小结" class="headerlink" title="排序小结"></a>排序小结</h3><p>排序是不区分大小写的，对于sql语句来说，A和a的一样的。其实可以用order by 和 limit混合来使用。<br>比如，查询最高价格。</p><blockquote><p>select * from products order by prod_price DESC limit 1;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from products order by prod_price DESC limit 1;</span><br><span class="line">+---------+---------+--------------+------------+-------------------------+</span><br><span class="line">| prod_id | vend_id | prod_name    | prod_price | prod_desc               |</span><br><span class="line">+---------+---------+--------------+------------+-------------------------+</span><br><span class="line">| JP2000  |    1005 | JetPack 2000 |      55.00 | JetPack 2000, multi-use |</span><br><span class="line">+---------+---------+--------------+------------+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mysql必知必会（连接，检索，排序）&quot;&gt;&lt;a href=&quot;#Mysql必知必会（连接，检索，排序）&quot; class=&quot;headerlink&quot; title=&quot;Mysql必知必会（连接，检索，排序）&quot;&gt;&lt;/a&gt;Mysql必知必会（连接，检索，排序）&lt;/h1&gt;&lt;p&gt;分别
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>了解SQL</title>
    <link href="http://yoursite.com/2018/06/10/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%EF%BC%881,2%E7%AB%A0%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/10/Mysql必知必会（1,2章）/</id>
    <published>2018-06-10T01:48:00.000Z</published>
    <updated>2018-06-10T01:48:59.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解SQL"><a href="#了解SQL" class="headerlink" title="了解SQL"></a>了解SQL</h1><h2 id="1-DBMS数据库管理系统"><a href="#1-DBMS数据库管理系统" class="headerlink" title="1.DBMS数据库管理系统"></a>1.DBMS数据库管理系统</h2><ul><li><strong>数据库（database）</strong></li></ul><p>保存有组织的数据容器。DBMS是操纵和创建数据库的软件，不能直接访问数据库，是通过DBMS去访问。</p><ul><li><strong>表（table）</strong></li></ul><p>某种特定类型数据的结构化清单。一个结构化的文件，用来存储某种特定类型的数据。</p><ul><li><strong>模式（schema）</strong></li></ul><p>关于数据库和表的布局以及特征的信息</p><ul><li><strong>列（column）</strong></li></ul><p>表中的一个字段。所有的表都是由多个或一个列组成的。可以把它想象成一个网格，网格中每个列存储着一条特定的信息。</p><ul><li><strong>数据类型（datatype）</strong></li></ul><p>所容许的数据类型，它限制列中存储的数据。</p><ul><li><strong>行（row）</strong></li></ul><p>表中的一个记录。表中的行数也为记录的总数。</p><ul><li><strong>主键（primary key）</strong></li></ul><p>一列（或一组列），其值能够唯一区分表中的每个行。</p><p>++主键的规范++：</p><blockquote><p>任意两行都不能具有相同的主键值。<br>每个行都必须具有一个主键值（主键不允许为NULL）。</p></blockquote><h2 id="2-什么是SQL"><a href="#2-什么是SQL" class="headerlink" title="2.什么是SQL?"></a>2.什么是SQL?</h2><p>SQL是结构化查询语言（Structured Query Language），是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。<br>SQL的优点：</p><ul><li>SQL不是某个特定的数据库专用的语言，几乎所有的DBMS都支持SQL。</li><li>SQL简单易学，语句描述性很强。</li><li>SQL看上去很简单，但是是一个强有力的语言，可以进行很复杂的数据库操作。</li></ul><h2 id="3-MySQL简述"><a href="#3-MySQL简述" class="headerlink" title="3.MySQL简述"></a>3.MySQL简述</h2><p> MySQL是一个小型关系型数据库管理系统，开发者为瑞典MySQL AB公司，现在已经被Sun公司收购，支持FreeBSD、Linux、MAC、Windows等多种操作系统与其他的大型数据库例如Oracle、DB2、SQL Server等相比功能稍弱一些。其特点有：</p><p>1、可以处理拥有上千万条记录的大型数据；</p><p>2、支持常见的SQL语句规范；</p><p>3、可移植行高，安装简单小巧；</p><p>4、良好的运行效率，有丰富信息的网络支持；</p><p>5、调试、管理，优化简单（相对其他大型数据库）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;了解SQL&quot;&gt;&lt;a href=&quot;#了解SQL&quot; class=&quot;headerlink&quot; title=&quot;了解SQL&quot;&gt;&lt;/a&gt;了解SQL&lt;/h1&gt;&lt;h2 id=&quot;1-DBMS数据库管理系统&quot;&gt;&lt;a href=&quot;#1-DBMS数据库管理系统&quot; class=&quot;header
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的源码解析</title>
    <link href="http://yoursite.com/2018/06/08/hashmap/"/>
    <id>http://yoursite.com/2018/06/08/hashmap/</id>
    <published>2018-06-08T05:32:00.000Z</published>
    <updated>2018-06-30T02:12:15.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap的源码解析"><a href="#HashMap的源码解析" class="headerlink" title="HashMap的源码解析"></a>HashMap的源码解析</h1><h2 id="HashMap的概述"><a href="#HashMap的概述" class="headerlink" title="HashMap的概述"></a>HashMap的概述</h2><p>HashMap是常用的Java集合之一，是基于哈希表的Map接口的实现。<br>由于HashMap不是线程安全的，如果想要线程安全，可以使用ConcurrentHashMap代替。</p><p>API里面给的解释是：</p><blockquote><p>基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p></blockquote><h2 id="HashMap的继承体系"><a href="#HashMap的继承体系" class="headerlink" title="HashMap的继承体系"></a>HashMap的继承体系</h2><p>我们要了解一个类，首先要了解一下他的继承结构，，才能更好的理解这个类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt;</span><br><span class="line">extends AbstractMap&lt;K,V&gt;</span><br><span class="line">implements Map&lt;K,V&gt;,Cloneable, Serializable</span><br></pre></td></tr></table></figure><p>我们可以看一下继承图。这里我们要注意HashMap和Hashtable的继承是不一样的，Hashtable继承的是Dictionary。</p><p><img src="https://tech.meituan.com/img/java-hashmap/java.util.map%E7%B1%BB%E5%9B%BE.png" alt="Markdown"></p><p>大概介绍一下HashMap和Hashtable，</p><ul><li>HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li><li>Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</li></ul><h2 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h2><p>从结构实现来讲，HashMap 是数组+链表+红黑树<br>给大家一个图可以更加直观的了解其结构<br><img src="https://tech.meituan.com/img/java-hashmap/hashMap%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image"></p><p>我们其实还要想，到底是在底层是怎样存储的？为什么这样存，或者说有什么优点？</p><ol><li>我们能从上图看出来，首先是一个数组的存储,查看源码可知，有一个很重要的数组，Node&lt;K,V&gt;[] table，很明显，它是一个Node数组，我们来看一下Node的结构。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;  <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;  <span class="comment">//链表的下一个节点</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p><p>2.HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hs.put(1,&quot;magic&quot;);</span><br></pre></td></tr></table></figure></p><p>系统将调用”1”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。不会都加到一个下标下面的链表去。保证每一个的分散性、均匀性。要做到雨露均沾。</p><p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。</p><p>那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的==Hash算法==和==扩容机制==。</p><p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int threshold;             // 所能容纳的key-value对极限 </span><br><span class="line">  final float loadFactor;    // 负载因子</span><br><span class="line">  int modCount;  </span><br><span class="line">  int size;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">在 HashMap 中定义了几个常量:</span><br><span class="line"></span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line">  </span><br><span class="line">依次解释一下上面的变量：</span><br><span class="line">1. DEFAULT_INITIAL_CAPACITY: </span><br><span class="line">初始容量，也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。</span><br><span class="line">2. MAXIMUM_CAPACITY:</span><br><span class="line">哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。</span><br><span class="line">3. DEFAULT_LOAD_FACTOR:</span><br><span class="line">默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。</span><br><span class="line">4. TREEIFY_THRESHOLD:</span><br><span class="line">上文说过，如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于 8 时，有可能会转化成树。</span><br><span class="line">5. UNTREEIFY_THRESHOLD:</span><br><span class="line">在哈希表扩容时，如果发现链表长度小于 6，则会由树重新退化为链表。</span><br><span class="line">6. MIN_TREEIFY_CAPACITY:</span><br><span class="line">在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span><br></pre></td></tr></table></figure><p>首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p><p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，++扩容后的HashMap容量是之前容量的两倍++。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p><p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量（数组中现有的元素）。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p><p>在HashMap中，++哈希桶数组table的长度length大小必须为2的n次方(一定是合数)++，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="noopener">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a>，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，<br>==在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。==<br>而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="noopener">http://blog.csdn.net/v_july_v/article/details/6105630。</a></p><h2 id="HashMap的功能实现-方法"><a href="#HashMap的功能实现-方法" class="headerlink" title="HashMap的功能实现-方法"></a>HashMap的功能实现-方法</h2><p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p><h3 id="1-确定哈希桶数组索引位置"><a href="#1-确定哈希桶数组索引位置" class="headerlink" title="1. 确定哈希桶数组索引位置"></a>1. 确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">static final int hash(Object key) &#123;   //jdk1.8 </span><br><span class="line">     int h;</span><br><span class="line">     // h = key.hashCode() 为第一步 取hashCode值</span><br><span class="line">     // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span><br><span class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line">//jdk1.7</span><br><span class="line">static int hash(int h) &#123;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br><span class="line">方法二：</span><br><span class="line">static int indexFor(int h, int length) &#123;  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span><br><span class="line">     return h &amp; (length-1);  //第三步 取模运算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p><p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p><p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。<br>下面举例说明下，n为table的长度。<br><img src="https://tech.meituan.com/img/java-hashmap/hashMap%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE.png" alt="image"></p><h3 id="2-分析HashMap的put方法"><a href="#2-分析HashMap的put方法" class="headerlink" title="2. 分析HashMap的put方法"></a>2. 分析HashMap的put方法</h3><p>HashMap的put方法执行过程可以通过下图来理解.<br><img src="https://tech.meituan.com/img/java-hashmap/hashMap%20put%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image"><br>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">         // 对key的hashCode()做hash</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">//从put()进入putVal(hash(key), key, value, false, true)；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        // 步骤①：tab为空则创建</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        // 步骤②：计算index，并对null做处理 </span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">             // 步骤③：节点key存在，直接覆盖value</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            // 步骤④：判断该链为红黑树</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">             // 步骤⑤：该链为链表</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                          //链表长度大于8转换为红黑树进行处理</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                     // key已经存在直接覆盖value</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">         // 步骤⑥：超过最大容量 就扩容</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. 扩容机制</h3><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;   //传入新的容量</span><br><span class="line">      Entry[] oldTable = table;    //引用扩容前的Entry数组</span><br><span class="line">      int oldCapacity = oldTable.length;         </span><br><span class="line">      if (oldCapacity == MAXIMUM_CAPACITY) &#123;  //扩容前的数组大小如果已经达到最大(2^30)了</span><br><span class="line">          threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组</span><br><span class="line">     transfer(newTable);                         //！！将数据转移到新的Entry数组里</span><br><span class="line">     table = newTable;                           //HashMap的table属性引用新的Entry数组</span><br><span class="line">     threshold = (int)(newCapacity * loadFactor);//修改阈值</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line">     Entry[] src = table;                   //src引用了旧的Entry数组</span><br><span class="line">     int newCapacity = newTable.length;</span><br><span class="line">     for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组</span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             //取得旧Entry数组的每个元素</span><br><span class="line">         if (e != null) &#123;</span><br><span class="line">             src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span><br><span class="line">             do &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置</span><br><span class="line">                e.next = newTable[i]; //标记[1]</span><br><span class="line">                newTable[i] = e;      //将元素放在数组上</span><br><span class="line">                e = next;             //访问下一个Entry链上的元素</span><br><span class="line">            &#125; while (e != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。<br><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="image"></p><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，<br>++所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。++<br>看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE1.png" alt="image"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE2.png" alt="image"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://tech.meituan.com/img/java-hashmap/jdk1.8%20hashMap%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="image"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，<br>++由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。++<br>有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr = threshold;</span><br><span class="line">        int newCap, newThr = 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">          // 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br><span class="line">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">             // 没超过最大值，就扩充为原来的2倍</span><br><span class="line">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0) // initial capacity was placed in threshold初始容量被放入阈值</span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        else &#123;               // zero initial threshold signifies using defaults零初始阈值表示使用默认值</span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        // 计算新的resize上限</span><br><span class="line">        if (newThr == 0) &#123;</span><br><span class="line">            float ft = (float)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        if (oldTab != null) &#123;</span><br><span class="line">        // 把每个bucket都移动到新的buckets中</span><br><span class="line">            for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                    oldTab[j] = null;</span><br><span class="line">                    if (e.next == null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; // preserve order 链表优化重hash的代码块</span><br><span class="line">                        Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                             // 原索引</span><br><span class="line">                            if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                                if (loTail == null)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                             // 原索引+oldCap</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail == null)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e = next) != null);</span><br><span class="line">                         // 原索引放到bucket里</span><br><span class="line">                        if (loTail != null) &#123;</span><br><span class="line">                            loTail.next = null;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 原索引+oldCap放到bucket里</span><br><span class="line">                        if (hiTail != null) &#123;</span><br><span class="line">                            hiTail.next = null;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全性-待深入"><a href="#线程安全性-待深入" class="headerlink" title="线程安全性(待深入)"></a>线程安全性(待深入)</h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class HashMapInfiniteLoop &#123;  </span><br><span class="line"></span><br><span class="line">    private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f);  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        map.put(5， &quot;C&quot;);  </span><br><span class="line"></span><br><span class="line">        new Thread(&quot;Thread1&quot;) &#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                map.put(7, &quot;B&quot;);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        new Thread(&quot;Thread2&quot;) &#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                map.put(3, &quot;A);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p><p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。<br><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE1.png" alt="image"><br>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。<br><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE2.png" alt="image"><br>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。<br><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE4.png" alt="image"><br>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p><h2 id="JDK1-8与JDK1-7的性能对比"><a href="#JDK1-8与JDK1-7的性能对比" class="headerlink" title="JDK1.8与JDK1.7的性能对比"></a>JDK1.8与JDK1.7的性能对比</h2><p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。</p><h3 id="Hash较均匀的情况"><a href="#Hash较均匀的情况" class="headerlink" title="Hash较均匀的情况"></a>Hash较均匀的情况</h3><p>为了便于测试，我们先写一个类Key，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Key implements Comparable&lt;Key&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final int value;</span><br><span class="line"></span><br><span class="line">    Key(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Key o) &#123;</span><br><span class="line">        return Integer.compare(this.value, o.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass())</span><br><span class="line">            return false;</span><br><span class="line">        Key key = (Key) o;</span><br><span class="line">        return value == key.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Keys &#123;</span><br><span class="line"></span><br><span class="line">    public static final int MAX_KEY = 10_000_000;</span><br><span class="line">    private static final Key[] KEYS_CACHE = new Key[MAX_KEY];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        for (int i = 0; i &lt; MAX_KEY; ++i) &#123;</span><br><span class="line">            KEYS_CACHE[i] = new Key(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Key of(int value) &#123;</span><br><span class="line">        return KEYS_CACHE[value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void test(int mapSize) &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize);</span><br><span class="line">        for (int i = 0; i &lt; mapSize; ++i) &#123;</span><br><span class="line">            map.put(Keys.of(i), i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long beginTime = System.nanoTime(); //获取纳秒</span><br><span class="line">        for (int i = 0; i &lt; mapSize; i++) &#123;</span><br><span class="line">            map.get(Keys.of(i));</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime = System.nanoTime();</span><br><span class="line">        System.out.println(endTime - beginTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i=10;i&lt;= 1000 0000;i*= 10)&#123;</span><br><span class="line">            test(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：<br><img src="https://tech.meituan.com/img/java-hashmap/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A81.png" alt="image"></p><p>通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。</p><h3 id="Hash极不均匀的情况"><a href="#Hash极不均匀的情况" class="headerlink" title="Hash极不均匀的情况"></a>Hash极不均匀的情况</h3><p>假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Key implements Comparable&lt;Key&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仍然执行main方法，得出的结果如下表所示：<br><img src="https://tech.meituan.com/img/java-hashmap/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A82.png" alt="image"><br>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p><blockquote><p>测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p><p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p><p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p><p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p><p>(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap的源码解析&quot;&gt;&lt;a href=&quot;#HashMap的源码解析&quot; class=&quot;headerlink&quot; title=&quot;HashMap的源码解析&quot;&gt;&lt;/a&gt;HashMap的源码解析&lt;/h1&gt;&lt;h2 id=&quot;HashMap的概述&quot;&gt;&lt;a href=&quot;#Has
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java源码" scheme="http://yoursite.com/tags/java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>关于String的理解</title>
    <link href="http://yoursite.com/2018/06/07/%E5%85%B3%E4%BA%8EString%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/06/07/关于String类的理解/</id>
    <published>2018-06-07T07:08:00.000Z</published>
    <updated>2018-06-22T15:25:07.765Z</updated>
    
    <content type="html"><![CDATA[<p>关于下面的代码，为什么结果为true？在我们的想法里，String是一个引用类型，为什么对象可以相等？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lq.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> magic_jh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String s1=<span class="string">"helloworld"</span>;</span><br><span class="line">String s2=<span class="string">"helloworld"</span>;</span><br><span class="line">String s3=<span class="keyword">new</span> String(<span class="string">"helloworld"</span>);</span><br><span class="line">System.out.println(s1==s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1==s3);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实可以看一下内存的分配，就一目了然了。</p><p><img src="https://img-blog.csdn.net/20180423233411390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQxMjM3NDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Markdown"></p><p>从图中可以看出其实s1和s2指向的不是堆内存，而是方法区的字符常量池，所以我们知道==比的是地址值，s1,s2指向的是同一个地址，肯定结果为true。我们现在来看s3，s3使用的是构造方法，它就在堆内存开辟了一个空间，其中的”helloworld”还是来自于字符常量池。所以s3指向的是堆内存中的地址，最后与s1比较的是s3指向的地址是堆内存的地址，所以为false。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于下面的代码，为什么结果为true？在我们的想法里，String是一个引用类型，为什么对象可以相等？&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="分享" scheme="http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>简单的操作示例</title>
    <link href="http://yoursite.com/2018/06/06/jh0904/"/>
    <id>http://yoursite.com/2018/06/06/jh0904/</id>
    <published>2018-06-06T11:07:24.000Z</published>
    <updated>2018-06-07T07:03:05.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="magic-jh"><a href="#magic-jh" class="headerlink" title="magic_jh"></a>magic_jh</h1><h2 id="第一次测试"><a href="#第一次测试" class="headerlink" title="第一次测试"></a>第一次测试</h2><h4 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h4><a id="more"></a><ul><li>列表1</li><li>列表2<br>  a子列表<br>  b子列表<br>  c子列表</li><li>列表3</li><li>列表4</li></ul><hr><hr><hr><p> <a href="http://www.jh0904.top/" target="_blank" rel="noopener">jh</a></p><p> <img src="http://www.jh0904.top/jh/static/2.jpeg" alt="jh"></p><p><img src="http://i2.bvimg.com/648776/ef337292942813bas.png" alt="Markdown"><br> <em>字体是斜体</em></p><p> <strong>字体加粗</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">asdas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我的内容是引用</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;magic-jh&quot;&gt;&lt;a href=&quot;#magic-jh&quot; class=&quot;headerlink&quot; title=&quot;magic_jh&quot;&gt;&lt;/a&gt;magic_jh&lt;/h1&gt;&lt;h2 id=&quot;第一次测试&quot;&gt;&lt;a href=&quot;#第一次测试&quot; class=&quot;headerlink&quot; title=&quot;第一次测试&quot;&gt;&lt;/a&gt;第一次测试&lt;/h2&gt;&lt;h4 id=&quot;三级标题&quot;&gt;&lt;a href=&quot;#三级标题&quot; class=&quot;headerlink&quot; title=&quot;三级标题&quot;&gt;&lt;/a&gt;三级标题&lt;/h4&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="导航" scheme="http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"/>
    
      <category term="分享" scheme="http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Vector的源码解析</title>
    <link href="http://yoursite.com/2018/06/06/Vector%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/06/06/Vector的源码解析/</id>
    <published>2018-06-06T06:20:17.000Z</published>
    <updated>2018-06-08T05:32:35.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vector源码解析"><a href="#Vector源码解析" class="headerlink" title="Vector源码解析"></a>Vector源码解析</h2><h3 id="1-Vector概述及继承体系"><a href="#1-Vector概述及继承体系" class="headerlink" title="1. Vector概述及继承体系"></a>1. Vector概述及继承体系</h3><p>Vector 类可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。与新 collection 实现不同，Vector 是同步的。<br> 看一下Vector的继承体系：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><p><img src="//img-blog.csdn.net/20180509232220757?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTIzNzQy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>RandomAccess接口是在源码中的注释如下：</p><blockquote><p>Marker interface used by List implementations to indicate that  they<br>support fast (generally constant time) random access.</p></blockquote><p>翻译下就是：这是一个标记性的接口，谁实现了这个接口就表明他具有快速随机访问的能力。</p><h3 id="2-Vector属性"><a href="#2-Vector属性" class="headerlink" title="2. Vector属性"></a>2. Vector属性</h3><p>capacityIncrement：自动扩容的大小，即当数组满了之后，就添加capacityIncrement个空间装载元素，如果capacityIncrement&lt;=0,则扩容时就扩容到目前Vector容量的两倍。</p><p>elementCount:记录数组中数据的个数。</p><p>elementData:数组，因为Vector底层也是数组存储的，所以用这个来存储数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;  <span class="comment">//扩容大小</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> elementCount;<span class="comment">//数组数据条数</span></span><br><span class="line"><span class="keyword">protected</span> Object[] elementData;<span class="comment">//数组</span></span><br></pre></td></tr></table></figure><h3 id="3-Vector构造方法"><a href="#3-Vector构造方法" class="headerlink" title="3. Vector构造方法"></a>3. Vector构造方法</h3><p> Vector构造方法有四个构造方法<br> 3.1.Vector()<br>构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//这里的this调用的是Vector(int initialCapacity) 方法</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p> 3.2.Vector(Collection &lt;\?extends E&gt; c)<br>构造一个包含指定 collection 中的元素的向量，这些元素按其 collection 的迭代器返回元素的顺序排列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        elementCount = elementData.length;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="comment">//c.toArray可能（不正确）不返回Object []（参见6260652）</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">``````            elementData = Arrays.copyOf(elementData, elementCount, Object[].class);</span><br><span class="line">            <span class="comment">//用Arrays.copyOf()方法转换类型。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p> 3.3.Vector(int initialCapacity)<br>使用指定的初始容量和等于零的容量增量构造一个空向量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);<span class="comment">//这里的this其实调用的是Vector(int initialCapacity, int capacityIncrement)方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p> 3.4.Vector(int initialCapacity, int capacityIncrement)<br> 我们从前面知道，无参构造和单参构造本质上都调用的是这个方法。我们来具体了解一下。<br>使用指定的初始容量和容量增量构造一个空的向量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initialCapacity指的是初始容量。</span></span><br><span class="line"><span class="comment">//capacityIncrement指的是扩容容量。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="comment">//从这里可以看出Vector底层也是数组实现的。</span></span><br><span class="line">        <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-Vector常用方法"><a href="#4-Vector常用方法" class="headerlink" title="4. Vector常用方法"></a>4. Vector常用方法</h3><ul><li>4.1.Vector最初的方法<br> a.addElement(E obj)<br>将指定的组件添加到此向量的末尾，将其大小增加 1。如果向量的大小比容量大，则增大其容量。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">     modCount++;</span><br><span class="line">     ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">     elementData[elementCount++] = obj;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>从addElement方法中有<font color="red">ensureCapacityHelper(elementCount + 1);</font><br>我们大致可以推测出这一步是用来扩容的。接着看这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code检测是否大于数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="comment">//注意：这是和ArrayList不同的地方，这个的自动扩容是直接增加一个oldCapacity，也就是扩大了一倍。</span></span><br><span class="line">    <span class="comment">/*第一个判断是怕扩容的数组长度还是太小，就用minCapacity 来进行对数组的扩张。</span></span><br><span class="line"><span class="comment">第二个判断是如果扩张1倍太大或者是我们所需的空间大小minCapacity太大，则进行Integer.MAX_VALUE来进行扩张。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.elementAt(int index)</strong><br>返回指定索引处的组件。 其实这个方法就是和我们之前使用的get方法很相似。源码很简单，就是说先进行一个index的有效位检验，如果正确在进入elementData(int index)方法，直接取数组的数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//---------------------------------------------</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>3. elements()</strong><br>返回此向量的组件的枚举。返回的 Enumeration 对象将生成此向量中的所有项。生成的第一项为索引 0 处的项，然后是索引 1 处的项，依此类推。<br>其实我们仔细观察就可以发现，这个和我们之前遍历时候用的Iterator很相似。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;E&gt;() &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> count &lt; elementCount;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count &lt; elementCount) &#123;</span><br><span class="line">                        <span class="keyword">return</span> elementData(count++);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Vector Enumeration"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>Enumeration是一个接口，直接在方法里面实现。从中我们可以看到hasMoreElements（）和nextElement（）方法。下来举个例子来体会一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *  对Vector的一个简单使用</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        Vector v=<span class="keyword">new</span> Vector ();</span><br><span class="line">        v.addElement (<span class="string">"hello"</span>);   <span class="comment">//--------------&gt;add()</span></span><br><span class="line">        v.addElement (<span class="string">"world"</span>);</span><br><span class="line">        v.addElement (<span class="string">"java"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println (v.elementAt (<span class="number">1</span>));<span class="comment">//下标从0开始 //--------------&gt;get()</span></span><br><span class="line">        System.out.println (<span class="string">"-----------------"</span>);</span><br><span class="line">        Enumeration elements = v.elements ();   <span class="comment">//--------------&gt;Iterator()</span></span><br><span class="line">        <span class="keyword">while</span> (elements.hasMoreElements ())&#123;    <span class="comment">//--------------&gt;hasNext()</span></span><br><span class="line">            Object o = elements.nextElement (); <span class="comment">//--------------&gt;next()</span></span><br><span class="line">            System.out.println (o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>4.2.Vector JDK1.2之后的方法</p><p> JDK1.2之后出来的方法，为什么有之前的方法还要再加入新方法？</p><p> JDK1.2升级的原因无非有三个：1.安全问题2.效率问题3.简化书写</p><p> 1.add</p><p> 添加元素的方法实现比较简单：直接在数组的后一个位置添加即可，不过在添加元素之前需要检查数组中是否已满，如果已满，则扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//添加一个元素到末尾，数组长度+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">       elementData[elementCount++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//添加一个元素到指定位置。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       insertElementAt(element, index);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*insertElementAt()方法，先进行有效位检验，然后在使用ensureCapacityHelper更改数组长度+1，在使用</span></span><br><span class="line"><span class="comment">System.arraycopy()方法，这个方法的具体解析，可以去看ArrayList的源码，里面有分析。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                    + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">       &#125;</span><br><span class="line">       ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">       elementData[index] = obj;</span><br><span class="line">       elementCount++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">       ensureCapacityHelper(elementCount + numNew);</span><br><span class="line">       System.arraycopy(a, <span class="number">0</span>, elementData, elementCount, numNew);</span><br><span class="line">       elementCount += numNew;</span><br><span class="line">       <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>2.get</p><p>返回向量中指定位置的元素。 </p><p>先进行有效位检验，直接从数组取相应下标元素。类似于elementAt（int index）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> elementData(index);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>set<br>4<br>用指定的元素替换此向量中指定位置处的元素。</li></ol><p>Vector底层使用的是数组，所以这就相当于对数组的操作。先进行有效位检验，然后把指定下标的元素改成element。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4.remove</p><p>remove方法其实和ArrayList里面的方法区别不大。我们主要来看两个方法就可以了。</p><p>4.4.1.remove(int index)</p><p> 先进行有效位检测，然后取出index下标的元素，在计算index元素之后的长度，最后使用 System.arraycopy()直接把index位置跳过，再把elementData[]最后一位元素置为null,让垃圾回收器将其回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">       E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>4.4.2.remove(Object o)</p><p>删除指定元素。其实这个也特别简单，remove(Object o)底层调用了removeElement(o)方法。removeElement(o)的实现就是先把当前元素的位置下标取出来，然后有了下标就可以使用remove(int index)方法了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//--------------------------------</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            removeElementAt(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>Vector里面是基于数组来实现的需要注意的是：Vector是线程安全的，因此，在多线程并发中是不需要使用额外同步的，而ArrayList实现基本与Vector一样，但是区别是：ArrayList是线程不安全的，在多线程并发时，需要我们进行额外的同步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vector源码解析&quot;&gt;&lt;a href=&quot;#Vector源码解析&quot; class=&quot;headerlink&quot; title=&quot;Vector源码解析&quot;&gt;&lt;/a&gt;Vector源码解析&lt;/h2&gt;&lt;h3 id=&quot;1-Vector概述及继承体系&quot;&gt;&lt;a href=&quot;#1-Vect
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java源码" scheme="http://yoursite.com/tags/java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
