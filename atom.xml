<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>magic</title>
  
  <subtitle>jh</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-28T04:21:20.140Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>magic_jh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解java虚拟机（一）</title>
    <link href="http://yoursite.com/2018/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/28/深入理解java虚拟机（一）/</id>
    <published>2018-07-28T04:14:26.000Z</published>
    <updated>2018-07-28T04:21:20.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>今天主要学习了《深入理解java虚拟机》的前两章节，第一章主要讲解了java语法的一些特性，及java发展的历史，还有java虚拟机的一些知识。<br>第二章主要讲了java内存区域与内存溢出异常。主要的内容我都总结了思维导图，如果需要导图，可以从百度云下载<a href="https://pan.baidu.com/s/1esP5YDPv_5UZ_neUvGo2BQ" target="_blank" rel="noopener">java虚拟机导图</a>  ，密码是0n73</p><p>好了，废话不说，直接上图。有不正确的地方，欢迎大家指正。</p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-28/92420488.jpg" alt="java"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天主要学习了《深入理解java虚拟机》的前两章节，第一章主要讲解了java语法的一些特性，及java发展的历史，还有java虚
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>阶段性总结</title>
    <link href="http://yoursite.com/2018/07/24/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/07/24/阶段性总结/</id>
    <published>2018-07-24T15:44:43.000Z</published>
    <updated>2018-07-24T15:45:42.276Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="实训总结"><a href="#实训总结" class="headerlink" title="实训总结"></a>实训总结</h3><p>今天是实训结束，实训期间主要还是自己状态不是很好，主要学习了Mybatis和Spring MVC的一些东西。其次实训单位让做一个简单的项目。我们小组做了一个简单的易买网项目.具体项目我已经上传到服务器，大家可以去访问。链接放在这里：<a href="http://www.jh0904.top/MStorage" target="_blank" rel="noopener">易买网</a>。时间短，任务比较重，所以就大概这个样子啦，其中还有很多缺陷，还要继续完善，希望大家指正。</p><h3 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h3><p>现在在学校东门租了房子，准备利用这个时间，好好的去复习一下之前的知识，并且去加深印象。去备战9月的秋招。<br>大概学习计划如下：</p><h4 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h4><ul><li>反射的总结、集合的总结、IO的总结、NIO的总结。（博客）</li><li>对于基础部分，还有笔试题的任务，每天规定做20-30道牛客的题目。编程题1道。（习题）</li><li>每日的博客（主要是面试题）</li><li>其次，还有对高并发的学习。java8的了解，java9暂时不考虑。</li><li>还有对java虚拟机的学习。</li><li>对之前几本武林秘籍的复习。</li></ul><h4 id="框架和web开发"><a href="#框架和web开发" class="headerlink" title="框架和web开发"></a>框架和web开发</h4><ul><li>学习《web开发指南》了解web开发的基本业务逻辑。</li><li>首先前段时间学习了Mybatis和Spring MVC,但是基础不牢靠，需要总结。（博客）</li><li>学习SSM的整合项目，并且根据尚硅谷的视频搭载一个简单的项目。</li><li>复习Spring的开发，复习方法有：1.学习spring的注解开发（视频）2.阅读spring实战（书籍）<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4></li><li>复习数据库的知识，简单的操作，并且还有高级的开发（索引的一些东西）</li><li>学习NoSQL数据库（Redis），主要以视频为主，书籍为辅导资料。</li><li>练习简单的sql语句练习题（牛客网）</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>熟悉简单的排序方法，了解基本思想，每周写一遍。</li><li>练习编程题，每日一道。</li><li>学习java视频（主要是简单的算法和letcood的视频）</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>以上是我对假期的一些安排和期望，希望我能在接下来的一个月中，砥砺前行，不忘初心。加油！！！</p><p>我对我的寄语：</p><h1 id="加油，相信自己。想要改变世界，先改变自己。"><a href="#加油，相信自己。想要改变世界，先改变自己。" class="headerlink" title=" 加油，相信自己。想要改变世界，先改变自己。 "></a><font style="color:red"> 加油，相信自己。想要改变世界，先改变自己。 </font></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实训总结&quot;&gt;&lt;a href=&quot;#实训总结&quot; class=&quot;headerlink&quot; title=&quot;实训总结&quot;&gt;&lt;/a&gt;实
      
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="自我总结" scheme="http://yoursite.com/tags/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93/"/>
    
      <category term="学习计划" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>纪念一次json解析错误！！！</title>
    <link href="http://yoursite.com/2018/07/23/%E7%BA%AA%E5%BF%B5%E4%B8%80%E6%AC%A1json%E8%A7%A3%E6%9E%90%E9%94%99%E8%AF%AF%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://yoursite.com/2018/07/23/纪念一次json解析错误！！！/</id>
    <published>2018-07-23T14:38:38.000Z</published>
    <updated>2018-07-23T14:41:09.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>今天做了一个简单的ssm项目，在用spring mvc解析json数据时，网页一直返回数据显示406错误。对于这个错误，头疼了一天。首先介绍一下我的小项目。</p><h3 id="项目代码与思路"><a href="#项目代码与思路" class="headerlink" title="项目代码与思路"></a>项目代码与思路</h3><p>首先先创建一个jsp页面，json数据的传输有两种：</p><ul><li>一、请求json，输出是json </li><li>二、请求key/value，输出是json</li></ul><p>接下来首先分析一下请求json返回也是json的形式（第二种不做简述，照猫画虎，思想一致，只提供代码）<br>使用jquery的ajax提交json串，对输出的json结果进行解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        //请求json，输出是json</span><br><span class="line">        function requestJson() &#123;</span><br><span class="line">            alert(&quot;requestJson&quot;);</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type: &apos;post&apos;,</span><br><span class="line">                url: &apos;$&#123;pageContext.request.contextPath &#125;/requestJson&apos;,</span><br><span class="line">                contentType: &apos;application/json;charset=utf-8&apos;,</span><br><span class="line">                //数据格式是json串,商品信息</span><br><span class="line">                data: &apos;&#123;&quot;name&quot;:&quot;手机&quot;,&quot;price&quot;:999&#125;&apos;,</span><br><span class="line">                success: function (data) &#123;//返回json结果</span><br><span class="line">                    alert(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;input type=&quot;button&quot; onclick=&quot;requestJson()&quot; value=&quot;请求json，输出是json&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>然后在controller中写一个JsonTest类存储方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.how2java.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.ItemsCustom;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JsonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求json串(商品信息)，输出json(商品信息)</span></span><br><span class="line"><span class="comment">//@RequestBody将请求的商品信息的json串转成itemsCustom对象</span></span><br><span class="line"><span class="comment">//@ResponseBody将itemsCustom转成json输出</span></span><br><span class="line">@RequestMapping(<span class="string">"/requestJson"</span>)</span><br><span class="line">public @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom)&#123;</span><br><span class="line"><span class="comment">//@ResponseBody将itemsCustom转成json输出</span></span><br><span class="line"><span class="keyword">return</span> itemsCustom;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个代码的意思就是从jsp发送到controller中，然后其中的@RequestBody标明传输json数据，最后在返回数据到页面上。</p><h3 id="错误问题"><a href="#错误问题" class="headerlink" title="错误问题"></a>错误问题</h3><p>在写完上述代码之后，出现了网页无法解析json数据的状况，检查头文件发现后端传数据过来到前端了，但是显示406错误。总共出现了两个问题：</p><h4 id="问题一：jar问题"><a href="#问题一：jar问题" class="headerlink" title="问题一：jar问题"></a>问题一：jar问题</h4><p>导入的jar包不正确，之前一直使用的是1.9.2版本的下面三个jar包，在网上查询了之后发现，spring3.* 支持1.9.2 ,在spring4.0之后已经不支持了，所以把jar全部更新到2.4.1的jar包。我使用的是maven工程，具体的依赖可以看下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">             &lt;!--jackson--&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;jackson-core&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;jackson-annotations&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;jackson-databind&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-23/91348004.jpg" alt=""></p><h4 id="问题二：spring-MVC-xml配置文件出现问题"><a href="#问题二：spring-MVC-xml配置文件出现问题" class="headerlink" title="问题二：spring MVC.xml配置文件出现问题"></a>问题二：spring MVC.xml配置文件出现问题</h4><p>在需要解析json1的时候需要在spring MVC.xml添加如下配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 避免IE执行AJAX时,返回<span class="built_in">JSON</span>出现下载文件 --&gt;</span><br><span class="line">   &lt;bean id=<span class="string">"mappingJacksonHttpMessageConverter"</span></span><br><span class="line">         <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"supportedMediaTypes"</span>&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">               &lt;value&gt;text/html;charset=UTF<span class="number">-8</span>&lt;<span class="regexp">/value&gt;</span></span><br><span class="line"><span class="regexp">           &lt;/</span>list&gt;</span><br><span class="line">       &lt;<span class="regexp">/property&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 启动Spring MVC的注解功能，完成请求和注解POJO的映射 --&gt;</span><br><span class="line">   &lt;bean</span><br><span class="line">           <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"messageConverters"</span>&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">               &lt;ref bean=<span class="string">"mappingJacksonHttpMessageConverter"</span> /&gt;&lt;!-- json转换器 --&gt;</span><br><span class="line">           &lt;/list&gt;</span><br><span class="line">       &lt;<span class="regexp">/property&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>bean&gt;</span><br></pre></td></tr></table></figure></p><p>但是加入之后依然报错，显示无法加载<font style="color : red">org.springframework.http.converter.json.MappingJacksonHttpMessageConverter</font></p><p>网上查询之后发现，在导入jackson2.0版本以上的时候，其中的配置文件已经更换了<br>更换为</p><blockquote><p>org.springframework.http.converter.json.MappingJackson2HttpMessageConverter</p></blockquote><p>配置完成之后，重新启动项目，发现项目没有问题了，成功运行。<br>这次再配置的过程中浪费太多时间，为了避免下次还是出现此类问题，故此写了这篇文章，以便以后查阅和修改代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天做了一个简单的ssm项目，在用spring mvc解析json数据时，网页一直返回数据显示406错误。对于这个错误，头疼了一
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
      <category term="java项目" scheme="http://yoursite.com/tags/java%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>java提供了那些IO方式？NIO如何实现多路复用？</title>
    <link href="http://yoursite.com/2018/07/21/java%E6%8F%90%E4%BE%9B%E4%BA%86%E9%82%A3%E4%BA%9BIO%E6%96%B9%E5%BC%8F%EF%BC%9FNIO%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/21/java提供了那些IO方式？NIO如何实现多路复用？/</id>
    <published>2018-07-21T00:57:55.000Z</published>
    <updated>2018-07-21T00:58:30.708Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。</p><p>首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p><p>java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p><p>很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p><p>第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p><p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>上面所列出的回答是一种常见的分类方式，即所谓的BIO、NIO、AIO。</p><p>主要考察的点有：</p><ul><li>基础的API设计与功能<br>InputStream/OutputStream和Reader/Writer的区别和使用。</li><li>NIO、NIO2的基本组成。</li><li>不同场景下，分析BIO和NIO的设计和实现原理。</li><li>NIO提供高性能的原理</li><li><p>NIO还存在那些问题？改进的想法？</p><h3 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4></li><li>区分同步或异步（synchronous/asynchronous）<blockquote><p>所谓同步是指一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成，这是一个可靠的任务序列。要成功都成功，要失败都失败，两个任务的状态可以保持一致。<br>异步不需要等待依赖的任务完成。只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了，至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p></blockquote></li><li>区分阻塞与非阻塞（blocking/non-blocking）<blockquote><p>在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</p></blockquote></li></ul><p>对于IO，做一下总结：</p><ul><li>IO不仅仅是对文件的操作，在网络编程中，比如socket通信，都是典型的IO操作目标。</li><li>输入流、输出流（InputStream/OutputStream）适用于读取或者写入字节，例如图片操作文件。</li><li>Reader/Writer则是用于操作字符的，增加字符编解码的功能，适用于从文件中读取或者写入文本信息2，本质上计算机操作的都是字节，不管是从网络通信还是文件读取，Reader/Writer相当于构建了应用逻辑与原始数据之间的桥梁。</li><li>BufferedOutputStream等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。</li><li>参考下面这张类图，很多 IO工具类都实现了 Closeable接口，因为需要进行资源的释放。比如，打开 FileInputStream，它就会获取相应的文件描述符（ FileDescriptor），需要利用 try- with- resources、 try- finally等机制保证 FileInputStream被明确关闭，进而相应文件描述符也会失效，否则将导致资源无法被释放。利用专栏前面的内容提到的 Cleaner或 finalize机制作为资源释放的最后把关，也是必要的。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-21/67006062.jpg" alt=""></li></ul><h4 id="NIO的概览"><a href="#NIO的概览" class="headerlink" title="NIO的概览"></a>NIO的概览</h4><ol><li>首先了解一下NIO的基本组成部分：</li></ol><ul><li><p>Chnnel</p><blockquote><p>由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。<br>Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。<br>类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。<br>File 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过 Socket 获取 Channel，反之亦然。</p></blockquote></li><li><p>Buffer</p><blockquote><p>一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p></blockquote></li><li>Selector<blockquote><p>是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在 Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理。<br>Selector 同样是基于底层操作系统机制，不同模式、不同版本都存在区别，例如，在最新的代码库里，相关实现如下：<br>在Linux中依赖于epoll<br>在Windows中依赖于iocp模型</p></blockquote></li><li>Chartset<blockquote><p>提供 Unicode 字符串定义，NIO 也提供了相应的编解码器等，例如，通过下面的方式进行字符串到 ByteBuffer 的转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharSet.defaultCharSet().encode(<span class="string">"Hello,World"</span>)</span><br></pre></td></tr></table></figure></blockquote></li></ul><ol start="2"><li>NIO的具体作用</li></ol><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>对比HashMap、HashTable、TreeMap之间的区别</title>
    <link href="http://yoursite.com/2018/07/18/%E5%AF%B9%E6%AF%94HashMap%E3%80%81HashTable%E3%80%81TreeMap%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/07/18/对比HashMap、HashTable、TreeMap之间的区别/</id>
    <published>2018-07-18T13:41:46.000Z</published>
    <updated>2018-07-18T13:42:57.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。</p><p>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</p><p>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</p><p>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>我感觉这三个Map中最重要的肯定是HashMap，首先看一下我之前的文章了解一下：<a href="https://blog.jh0904.top/2018/06/08/hashmap/" target="_blank" rel="noopener">HashMap的源码解析</a>，我认为学习集合框架，首先要了解基本的操作用法，这个应该去读API。其次，应当去学习源码，去了解怎么实现的具体代码。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-18/32923831.jpg" alt=""></p><p>对于三者的区别，我主要从三方面来说：</p><h4 id="1-语法上面的区别："><a href="#1-语法上面的区别：" class="headerlink" title="1.语法上面的区别："></a>1.语法上面的区别：</h4><p>1）HashMap允许键值为空，Hashtable不允许。</p><p>2）HashMap包含了containsvalue和containsKey，不包含有contains。</p><h4 id="2-安全方面的区别"><a href="#2-安全方面的区别" class="headerlink" title="2.安全方面的区别"></a>2.安全方面的区别</h4><p>HashTable支持线程安全的，而HashMap不支持线程同步，是非线程安全的。因此，HashMap相对来说效率可能会高于Hashtable。</p><h4 id="3-源码级别的区别"><a href="#3-源码级别的区别" class="headerlink" title="3.源码级别的区别"></a>3.源码级别的区别</h4><p>Hashtable，hash数组默认的大小是11，增加的方式是old*2+1,而HashMap中，hash数组的默认大小是16，而且一定是2的指数。</p><p>相较于HashMap和HashTable，TreeMap是利用红黑树来实现的，实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap来进行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多线程（二）</title>
    <link href="http://yoursite.com/2018/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/17/多线程（二）/</id>
    <published>2018-07-17T14:30:53.000Z</published>
    <updated>2018-07-17T14:31:26.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>这是多线程的第二篇文章，主要介绍一写java多线程的简单锁机制和死锁、线程池等一些概念，多线程的高级部分过一段时间加上。</p><h3 id="1-JDK5以后的针对线程的锁定操作和释放操作"><a href="#1-JDK5以后的针对线程的锁定操作和释放操作" class="headerlink" title="(1)JDK5以后的针对线程的锁定操作和释放操作"></a>(1)JDK5以后的针对线程的锁定操作和释放操作</h3><p>之前的同步方法，我们学习了简单的synchronized同步代码块，还有用synchronized修饰方法，形成同步方法。还有静态同步方法。<br>现在我们要了解简单的锁机制。<br>Lock锁是JDK5之后加入的，为了更清晰的表达如何加锁和释放锁。具体的使用方法参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义锁对象</span></span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的Main方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，</span></span><br><span class="line"><span class="comment"> * 为了更清晰的表达如何加锁和释放锁,JDK5以后提供了一个新的锁对象Lock。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Lock：</span></span><br><span class="line"><span class="comment"> * void lock()： 获取锁。</span></span><br><span class="line"><span class="comment"> * void unlock():释放锁。  </span></span><br><span class="line"><span class="comment"> * ReentrantLock是Lock的实现类.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个窗口</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>Lock的主要方法还是<br>Lock<br>    &nbsp;&nbsp;&nbsp;&nbsp;  void lock()<br>    &nbsp;&nbsp;&nbsp;&nbsp;  void unlock()<br>   &nbsp;&nbsp;&nbsp;&nbsp; <font style="color:red"> ReentrantLock</font></p></blockquote><h3 id="死锁问题的描述和代码体现"><a href="#死锁问题的描述和代码体现" class="headerlink" title="死锁问题的描述和代码体现"></a>死锁问题的描述和代码体现</h3><p>死锁问题是java中一个比较重要的问题。一般面试经常会问，这个需要牢记。</p><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><blockquote><p>我们先看看这样一个生活中的例子：在一条河上有一座桥，桥面较窄，只能容纳一辆汽车通过，无法让两辆汽车并行。如果有两辆汽车A和B分别由桥的两端驶上该桥，则对于A车来说，它走过桥面左面的一段路（即占有了桥的一部分资源），要想过桥还须等待B车让出右边的桥面，此时A车不能前进；对于B车来说，它走过桥面右边的一段路（即占有了桥的一部分资源），要想过桥还须等待A车让出左边的桥面，此时B车也不能前进。两边的车都不倒车，结果造成互相等待对方让出桥面，但是谁也不让路，就会无休止地等下去。这种现象就是死锁。如果把汽车比做进程，桥面作为资源，那麽上述问题就描述为：进程A占有资源R1，等待进程B占有的资源Rr；进程B占有资源Rr，等待进程A占有的资源R1。而且资源R1和Rr只允许一个进程占用，即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。  </p></blockquote><h4 id="死锁的原因"><a href="#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h4><p>主要有以下四个必要条件。总的来说死锁的原因还是资源的相互占有，无法释放。</p><blockquote><ol><li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li><li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，⋯⋯，Pn正在等待已被P0占用的资源。即肯定存在相互等待的死循环。</li></ol></blockquote><h4 id="死锁的代码"><a href="#死锁的代码" class="headerlink" title="死锁的代码"></a>死锁的代码</h4><p>DieLock的实现（zhonmgdi）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_02;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DieLock</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">private boolean flag;</span><br><span class="line"></span><br><span class="line">public DieLock(boolean flag) &#123;</span><br><span class="line"><span class="keyword">this</span>.flag = flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">synchronized (MyLock.objA) &#123;</span><br><span class="line">System.out.println(<span class="string">"if objA"</span>);</span><br><span class="line">synchronized (MyLock.objB) &#123;</span><br><span class="line">System.out.println(<span class="string">"if objB"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">synchronized (MyLock.objB) &#123;</span><br><span class="line">System.out.println(<span class="string">"else objB"</span>);</span><br><span class="line">synchronized (MyLock.objA) &#123;</span><br><span class="line">System.out.println(<span class="string">"else objA"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MyLock—-&gt;创建锁对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_02;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建两把锁对象</span></span><br><span class="line">public <span class="keyword">static</span> final <span class="built_in">Object</span> objA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">public <span class="keyword">static</span> final <span class="built_in">Object</span> objB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Demo类，开启线程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 同步的弊端：</span></span><br><span class="line"><span class="comment"> * A:效率低</span></span><br><span class="line"><span class="comment"> * B:容易产生死锁</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 死锁：</span></span><br><span class="line"><span class="comment"> * 两个或两个以上的线程在争夺资源的过程中，发生的一种相互等待的现象。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 举例：</span></span><br><span class="line"><span class="comment"> * 中国人，美国人吃饭案例。</span></span><br><span class="line"><span class="comment"> * 正常情况：</span></span><br><span class="line"><span class="comment"> * 中国人:筷子两支</span></span><br><span class="line"><span class="comment"> * 美国人:刀和叉</span></span><br><span class="line"><span class="comment"> * 现在：</span></span><br><span class="line"><span class="comment"> * 中国人：筷子1支，刀一把</span></span><br><span class="line"><span class="comment"> * 美国人：筷子1支，叉一把</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DieLockDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">DieLock dl1 = <span class="keyword">new</span> DieLock(<span class="literal">true</span>);</span><br><span class="line">DieLock dl2 = <span class="keyword">new</span> DieLock(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">dl1.start();</span><br><span class="line">dl2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="生产者和消费者多线程体现-线程间通信问题"><a href="#生产者和消费者多线程体现-线程间通信问题" class="headerlink" title="生产者和消费者多线程体现(线程间通信问题)"></a>生产者和消费者多线程体现(线程间通信问题)</h3><p>具体的生产者消费者的模式如下图：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-17/63313147.jpg" alt=""><br>以学生作为资源来实现的</p><pre><code>资源类：Student设置数据类：SetThread(生产者)获取数据类：GetThread(消费者)测试类：StudentDemo</code></pre><p><img src="https://images2015.cnblogs.com/blog/868641/201703/868641-20170303152707641-1755807475.png" alt=""><br>上图就是对生产者消费者的解释。<br>具体的代码实现：<br>Student<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="built_in">String</span> name;</span><br><span class="line">int age;</span><br><span class="line">boolean flag; <span class="comment">// 默认情况是没有数据，如果是true，说明有数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SetThread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SetThread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">private Student s;</span><br><span class="line">private int x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">public SetThread(Student s) &#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">synchronized (s) &#123;</span><br><span class="line"><span class="comment">//判断有没有</span></span><br><span class="line"><span class="keyword">if</span>(s.flag)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.wait(); <span class="comment">//t1等着，释放锁</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">s.name = <span class="string">"林青霞"</span>;</span><br><span class="line">s.age = <span class="number">27</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s.name = <span class="string">"刘意"</span>;</span><br><span class="line">s.age = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line">x++; <span class="comment">//x=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改标记</span></span><br><span class="line">s.flag = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//唤醒线程</span></span><br><span class="line">s.notify(); <span class="comment">//唤醒t2,唤醒并不表示你立马可以执行，必须还得抢CPU的执行权。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//t1有，或者t2有</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetThread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">private Student s;</span><br><span class="line"></span><br><span class="line">public GetThread(Student s) &#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">synchronized (s) &#123;</span><br><span class="line"><span class="keyword">if</span>(!s.flag)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.wait(); <span class="comment">//t2就等待了。立即释放锁。将来醒过来的时候，是从这里醒过来的时候</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(s.name + <span class="string">"---"</span> + s.age);</span><br><span class="line"><span class="comment">//林青霞---27</span></span><br><span class="line"><span class="comment">//刘意---30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改标记</span></span><br><span class="line">s.flag = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//唤醒线程</span></span><br><span class="line">s.notify(); <span class="comment">//唤醒t1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StudentDemo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> * 资源类：Student</span></span><br><span class="line"><span class="comment"> * 设置学生数据:SetThread(生产者)</span></span><br><span class="line"><span class="comment"> * 获取学生数据：GetThread(消费者)</span></span><br><span class="line"><span class="comment"> * 测试类:StudentDemo</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题1：按照思路写代码，发现数据每次都是:null---0</span></span><br><span class="line"><span class="comment"> * 原因：我们在每个线程中都创建了新的资源,而我们要求的时候设置和获取线程的资源应该是同一个</span></span><br><span class="line"><span class="comment"> * 如何实现呢?</span></span><br><span class="line"><span class="comment"> * 在外界把这个数据创建出来，通过构造方法传递给其他的类。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题2：为了数据的效果好一些，我加入了循环和判断，给出不同的值,这个时候产生了新的问题</span></span><br><span class="line"><span class="comment"> * A:同一个数据出现多次</span></span><br><span class="line"><span class="comment"> * B:姓名和年龄不匹配</span></span><br><span class="line"><span class="comment"> * 原因：</span></span><br><span class="line"><span class="comment"> * A:同一个数据出现多次</span></span><br><span class="line"><span class="comment"> * CPU的一点点时间片的执行权，就足够你执行很多次。</span></span><br><span class="line"><span class="comment"> * B:姓名和年龄不匹配</span></span><br><span class="line"><span class="comment"> * 线程运行的随机性</span></span><br><span class="line"><span class="comment"> * 线程安全问题：</span></span><br><span class="line"><span class="comment"> * A:是否是多线程环境是</span></span><br><span class="line"><span class="comment"> * B:是否有共享数据是</span></span><br><span class="line"><span class="comment"> * C:是否有多条语句操作共享数据是</span></span><br><span class="line"><span class="comment"> * 解决方案：</span></span><br><span class="line"><span class="comment"> * 加锁。</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * A:不同种类的线程都要加锁。</span></span><br><span class="line"><span class="comment"> * B:不同种类的线程加的锁必须是同一把。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题3:虽然数据安全了，但是呢，一次一大片不好看，我就想依次的一次一个输出。</span></span><br><span class="line"><span class="comment"> * 如何实现呢?</span></span><br><span class="line"><span class="comment"> * 通过Java提供的等待唤醒机制解决。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 等待唤醒：</span></span><br><span class="line"><span class="comment"> * Object类中提供了三个方法：</span></span><br><span class="line"><span class="comment"> * wait():等待</span></span><br><span class="line"><span class="comment"> * notify():唤醒单个线程</span></span><br><span class="line"><span class="comment"> * notifyAll():唤醒所有线程</span></span><br><span class="line"><span class="comment"> * 为什么这些方法不定义在Thread类中呢?</span></span><br><span class="line"><span class="comment"> * 这些方法的调用必须通过锁对象调用，而我们刚才使用的锁对象是任意锁对象。</span></span><br><span class="line"><span class="comment"> * 所以，这些方法必须定义在Object类中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">//创建资源</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取的类</span></span><br><span class="line">SetThread st = <span class="keyword">new</span> SetThread(s);</span><br><span class="line">GetThread gt = <span class="keyword">new</span> GetThread(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程类</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(gt);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是具体的实现方法和操作，其中的注释可以参考着观看，有助于理解程序代码。</p><h3 id="线程的转化状态"><a href="#线程的转化状态" class="headerlink" title="线程的转化状态"></a>线程的转化状态</h3><p>主要参考下图<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-17/99854255.jpg" alt=""></p><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>线程组（ThreadGroup）就是由线程组成的管理线程的类，这个类是java.lang.ThreadGroup类。</p><blockquote><p>在Java中每一个线程都归属于某个线程组管理的一员，例如在主函数main()主工作流程中产生一个线程，则产生的线程属于main这个线程组管理的一员。<br>定义一个线程组，通过以下代码可以实现。<br>ThreadGroup group=new ThreadGroup(“group”);<br>Thread thread=new Thread(group,”the first thread of group”);<br>具体的java例子代码可以见下：</p></blockquote><p>MyRunnable—–&gt;实现线程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_06;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadGroupDemo—–&gt;首先先构建一个线程组，然后在线程构造的时候指定线程组，设置好线程可以通过tg.getThreadGroup().getName()获取当前的线程组名称。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_06;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程组： 把多个线程组合到一起。</span></span><br><span class="line"><span class="comment"> * 它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// method1();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们如何修改线程所在的组呢?</span></span><br><span class="line"><span class="comment">// 创建一个线程组</span></span><br><span class="line"><span class="comment">// 创建其他线程的时候，把其他线程的组指定为我们自己新建线程组</span></span><br><span class="line">method2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// t1.start();</span></span><br><span class="line"><span class="comment">// t2.start();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> method2() &#123;</span><br><span class="line"><span class="comment">// ThreadGroup(String name)</span></span><br><span class="line">ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">"这是一个新的组"</span>);</span><br><span class="line"></span><br><span class="line">MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"><span class="comment">// Thread(ThreadGroup group, Runnable target, String name)</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(tg, my, <span class="string">"林青霞"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(tg, my, <span class="string">"刘意"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(t1.getThreadGroup().getName());</span><br><span class="line">System.out.println(t2.getThreadGroup().getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过组名称设置后台线程，表示该组的线程都是后台线程</span></span><br><span class="line">tg.setDaemon(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> method1() &#123;</span><br><span class="line">MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(my, <span class="string">"林青霞"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(my, <span class="string">"刘意"</span>);</span><br><span class="line"><span class="comment">// 我不知道他们属于那个线程组,我想知道，怎么办</span></span><br><span class="line"><span class="comment">// 线程类里面的方法：public final ThreadGroup getThreadGroup()</span></span><br><span class="line">ThreadGroup tg1 = t1.getThreadGroup();</span><br><span class="line">ThreadGroup tg2 = t2.getThreadGroup();</span><br><span class="line"><span class="comment">// 线程组里面的方法：public final String getName()</span></span><br><span class="line"><span class="built_in">String</span> name1 = tg1.getName();</span><br><span class="line"><span class="built_in">String</span> name2 = tg2.getName();</span><br><span class="line">System.out.println(name1);</span><br><span class="line">System.out.println(name2);</span><br><span class="line"><span class="comment">// 通过结果我们知道了：线程默认情况下属于main线程组</span></span><br><span class="line"><span class="comment">// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组</span></span><br><span class="line">System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。</p><h4 id="线程池的实现方法"><a href="#线程池的实现方法" class="headerlink" title="线程池的实现方法"></a>线程池的实现方法</h4><blockquote><p>线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。<br>在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池</p></blockquote><h5 id="线程池具体方法"><a href="#线程池具体方法" class="headerlink" title="线程池具体方法"></a>线程池具体方法</h5><p>JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法</p><pre><code>public static ExecutorService newCachedThreadPool()创建一个具有缓存功能的线程池缓存：百度浏览过的信息再次访问public static ExecutorService newFixedThreadPool(int nThreads)创建一个可重用的，具有固定线程数的线程池public static ExecutorService newSingleThreadExecutor()创建一个只有单线程的线程池，相当于上个方法的参数是1    </code></pre><p>这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法</p><pre><code>Future&lt;?&gt; submit(Runnable task)&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></pre><h5 id="线程池的代码实现"><a href="#线程池的代码实现" class="headerlink" title="线程池的代码实现"></a>线程池的代码实现</h5><p>MyRunnable接口实现线程。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ExecutorsDemo<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程池的好处：线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如何实现线程的代码呢?</span></span><br><span class="line"><span class="comment"> * A:创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line"><span class="comment"> * public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment"> * B:这种线程池的线程可以执行：</span></span><br><span class="line"><span class="comment"> * 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line"><span class="comment"> * 做一个类实现Runnable接口。</span></span><br><span class="line"><span class="comment"> * C:调用如下方法即可</span></span><br><span class="line"><span class="comment"> * Future&lt;?&gt; submit(Runnable task)</span></span><br><span class="line"><span class="comment"> *&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</span></span><br><span class="line"><span class="comment"> *D:我就要结束，可以吗?</span></span><br><span class="line"><span class="comment"> *可以。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// 创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line"><span class="comment">// public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多线程的面试题"><a href="#多线程的面试题" class="headerlink" title="多线程的面试题"></a>多线程的面试题</h3><p>具体的面试题可以参考我的往期文章：<a href="https://blog.jh0904.top/2018/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" rel="noopener">多线程面试题</a></p><p>在看面试题的时候，要注意，自己是否是自己真的理解了透彻了。先去思考问题，再去想自己的语言如何回答，自己如果面试遇到这种问题了应该如何处理。之后再去看答案和解析，这样更有收获，一起加油ヾ(◍°∇°◍)ﾉﾞ。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是多线程的第二篇文章，主要介绍一写java多线程的简单锁机制和死锁、线程池等一些概念，多线程的高级部分过一段时间加上。&lt;/p&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程（一）</title>
    <link href="http://yoursite.com/2018/07/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/16/多线程（一）/</id>
    <published>2018-07-16T15:55:35.000Z</published>
    <updated>2018-07-16T15:57:02.647Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h2 id="多线程-一"><a href="#多线程-一" class="headerlink" title="多线程(一)"></a>多线程(一)</h2><h3 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h3><p>多线程：一个应用程序有多条执行路径<br>        进程：正在执行的应用程序<br>        线程：进程的执行单元，执行路径<br>        单线程：一个应用程序只有一条执行路径<br>        多线程：一个应用程序有多条执行路径</p><blockquote><p>并发和并行的区别：简单的说，并行是指同一时刻同时做多件事情，而并发是指同一时间间隔内做多件事情。</p><font style="color:red;font-size:12px">  并发是两个任务可以在重叠的时间段内启动，运行和完成。并行是任务在同一时间运行，例如，在多核处理器上。<br>并发是独立执行过程的组合，而并行是同时执行（可能相关的）计算。<br>并发是一次处理很多事情，并行是同时做很多事情。<br>应用程序可以是并发的，但不是并行的，这意味着它可以同时处理多个任务，但是没有两个任务在同一时刻执行。<br>应用程序可以是并行的，但不是并发的，这意味着它同时处理多核CPU中的任务的多个子任务。<br>一个应用程序可以即不是并行的，也不是并发的，这意味着它一次一个地处理所有任务。<br>应用程序可以即是并行的也是并发的，这意味着它同时在多核CPU中同时处理多个任务。</font></blockquote><h4 id="多进程的意义"><a href="#多进程的意义" class="headerlink" title="多进程的意义?"></a>多进程的意义?</h4><p>单进程的计算机只能做一件事情,而我们现在的计算机都可以做多件事情。<br>    举例:一边玩游戏(游戏进程),一边听音乐(音乐进程)。<br>    也就是说现在的计算机都是支持多进程的,可以在一个时间段内执行多个任务。<br>    并且呢,可以提高CPU的使用率。</p><h4 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义?"></a>多线程的意义?</h4><p>多线程的存在,不是提高程序的执行速度。其实是为了提高应用程序的使用率。<br>    程序的执行其实都是在抢CUP的资源,CPU的执行权。<br>    多个进程是在抢这个资源,而其中的某一个进程如果执行路径比较多,就会有更高的几率抢到CPU的执行权。<br>    我们是不敢保证哪一个线程在哪个时刻抢到,所以线程的执行有随机性。<br>    举例:一个美女抛绣球(CPU执行权),A,B,C…等,ABC(进程)三个人抢绣球(CPU执行权),但是由于B(进程)使用分身术(多条执行路径),而他抢到绣球的机率将会很高,但是不一定能抢到</p><h3 id="Java程序的运行原理及JVM的启动是多线程的吗"><a href="#Java程序的运行原理及JVM的启动是多线程的吗" class="headerlink" title="Java程序的运行原理及JVM的启动是多线程的吗?"></a>Java程序的运行原理及JVM的启动是多线程的吗?</h3><ol><li>Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。</li><li>JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。<h3 id="多线程的实现方案"><a href="#多线程的实现方案" class="headerlink" title="多线程的实现方案"></a>多线程的实现方案</h3></li><li><p>继承Thread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cn.thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/2 18:18</span></span><br><span class="line"><span class="comment"> * description:实现Thread方法，继承Thread类，然后再去重写run（）方法。</span></span><br><span class="line"><span class="comment"> * 不是所有类需要被多线程执行，run（）方法里面是被线程执行的代码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            System.out.println (getName ()+<span class="string">"------&gt;"</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep (<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace ();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* getName ()源码</span></span><br><span class="line"><span class="comment">public Thread() &#123;</span></span><br><span class="line"><span class="comment">         init(null, null, "Thread-" + nextThreadNum(), 0);</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest1 t = <span class="keyword">new</span> ThreadTest1 ();</span><br><span class="line">        ThreadTest1 t1 = <span class="keyword">new</span> ThreadTest1 ();</span><br><span class="line"></span><br><span class="line">        t.setName (<span class="string">"magic"</span>);</span><br><span class="line">        t1.setName (<span class="string">"jh"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        启动线程</span></span><br><span class="line"><span class="comment">        t.run ();</span></span><br><span class="line"><span class="comment">        t.run ();*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// java.lang.IllegalThreadStateException(非法的状态异常，相当于main线程启动了两次)</span></span><br><span class="line">       <span class="comment">/* t.start ();</span></span><br><span class="line"><span class="comment">        t.start ();*/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//如何获取线程的名称  public String getName()</span></span><br><span class="line">        t.start ();</span><br><span class="line">        t1.start ();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * run方法调用就相当于普通方法的调用，单线程的执行</span></span><br><span class="line"><span class="comment">         * 面试题：start和run的区别：</span></span><br><span class="line"><span class="comment">         * run：仅仅是封装被线程执行的代码，直接是调用是普通方法。</span></span><br><span class="line"><span class="comment">         * start：首先启动线程，然后再由JVM虚拟机调用该线程的run（）方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口<br>首先先实现一个线程，其次重写run()方法；下面这是一个卖票的多线程程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cn.thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/3 8:22</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj=<span class="keyword">new</span> Object ();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println (Thread.currentThread ().getName ()+<span class="string">"正在售票---&gt;"</span>+(count--));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>接下来是Main的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread1 my = <span class="keyword">new</span> MyThread1 ();</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread (my, <span class="string">"一号窗口"</span>);</span><br><span class="line">        Thread tt = <span class="keyword">new</span> Thread (my, <span class="string">"二号窗口"</span>);</span><br><span class="line">        Thread ttt = <span class="keyword">new</span> Thread (my, <span class="string">"三号窗口"</span>);</span><br><span class="line"></span><br><span class="line">        t.start ();</span><br><span class="line">        tt.start ();</span><br><span class="line">        ttt.start ();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>实现Callable接口<br>实现Callable接口，重写call（）方法；<br>具体代码见下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程求和案例(实现Callable接口，重写了call()方法)</span></span><br><span class="line"><span class="comment"> * Callable:是带泛型的接口。</span></span><br><span class="line"><span class="comment"> * 这里指定的泛型其实是call()方法的返回值类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= number; x++) &#123;</span><br><span class="line">sum += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多线程实现的方式3：</span></span><br><span class="line"><span class="comment"> *  A:创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line"><span class="comment"> * public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment"> * B:这种线程池的线程可以执行：</span></span><br><span class="line"><span class="comment"> * 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line"><span class="comment"> * 做一个类实现Runnable接口。</span></span><br><span class="line"><span class="comment"> * C:调用如下方法即可</span></span><br><span class="line"><span class="comment"> * Future&lt;?&gt; submit(Runnable task)</span></span><br><span class="line"><span class="comment"> *&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</span></span><br><span class="line"><span class="comment"> *D:我就要结束，可以吗?</span></span><br><span class="line"><span class="comment"> *可以。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"><span class="comment">// 创建线程池对象</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">Future&lt;Integer&gt; f1 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">100</span>));</span><br><span class="line">Future&lt;Integer&gt; f2 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// V get()</span></span><br><span class="line">Integer i1 = f1.get();</span><br><span class="line">Integer i2 = f2.get();</span><br><span class="line"></span><br><span class="line">System.out.println(i1);</span><br><span class="line">System.out.println(i2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line">pool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结：总的来说，虽然实现多线程有两种方式，但是还是推荐使用实现Runable接口的方式，让程序具有可扩展性。</p><h3 id="线程的调度和优先级问题"><a href="#线程的调度和优先级问题" class="headerlink" title="线程的调度和优先级问题"></a>线程的调度和优先级问题</h3><ol><li>线程的调度</li></ol><ul><li>分时调度，所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</li><li>抢占式调度 (Java采用的是该调度方式)，优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 </li></ul><ol start="2"><li>获取和设置线程优先级</li></ol><ul><li>默认是5</li><li>范围是1-10<br>在Java中，线程的优先级用setPriority()方法就行，线程的优先级分为1-10这10个等级，如果小于1或大于10，则抛出异常throw new IllegalArgumentException()，默认是5。<br>主要的方法是：<blockquote><p>public final int getPriority()      获取线程优先级<br>public final void setPriority(int newPriority)设置线程优先级（1-10）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriority</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>Main方法示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们的线程没有设置优先级,肯定有默认优先级。</span></span><br><span class="line"><span class="comment"> * 那么，默认优先级是多少呢?</span></span><br><span class="line"><span class="comment"> * 如何获取线程对象的优先级?</span></span><br><span class="line"><span class="comment"> * public final int getPriority():返回线程对象的优先级</span></span><br><span class="line"><span class="comment"> * 如何设置线程对象的优先级呢?</span></span><br><span class="line"><span class="comment"> * public final void setPriority(int newPriority)：更改线程的优先级。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 线程默认优先级是5。</span></span><br><span class="line"><span class="comment"> * 线程优先级的范围是：1-10。</span></span><br><span class="line"><span class="comment"> * 线程优先级高仅仅表示线程获取的 CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到比较好的效果。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * IllegalArgumentException:非法参数异常。</span></span><br><span class="line"><span class="comment"> * 抛出的异常表明向方法传递了一个不合法或不正确的参数。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriorityDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadPriority tp1 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line">ThreadPriority tp2 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line">ThreadPriority tp3 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line"></span><br><span class="line">tp1.setName(<span class="string">"东方不败"</span>);</span><br><span class="line">tp2.setName(<span class="string">"岳不群"</span>);</span><br><span class="line">tp3.setName(<span class="string">"林平之"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取默认优先级</span></span><br><span class="line"><span class="comment">// System.out.println(tp1.getPriority());</span></span><br><span class="line"><span class="comment">// System.out.println(tp2.getPriority());</span></span><br><span class="line"><span class="comment">// System.out.println(tp3.getPriority());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程优先级</span></span><br><span class="line"><span class="comment">// tp1.setPriority(100000);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置正确的线程优先级</span></span><br><span class="line">tp1.setPriority(<span class="number">10</span>);</span><br><span class="line">tp2.setPriority(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">tp1.start();</span><br><span class="line">tp2.start();</span><br><span class="line">tp3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="线程的控制-常见方法"><a href="#线程的控制-常见方法" class="headerlink" title="线程的控制(常见方法)"></a>线程的控制(常见方法)</h4><p>A:休眠线程  (public static void sleep(long millis))<br>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x + <span class="string">",日期："</span> + <span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">// 睡眠</span></span><br><span class="line"><span class="comment">// 困了，我稍微休息1秒钟</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程休眠</span></span><br><span class="line"><span class="comment"> *public static void sleep(long millis)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleepDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadSleep ts1 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">ThreadSleep ts2 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">ThreadSleep ts3 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line"></span><br><span class="line">ts1.setName(<span class="string">"林青霞"</span>);</span><br><span class="line">ts2.setName(<span class="string">"林志玲"</span>);</span><br><span class="line">ts3.setName(<span class="string">"林志颖"</span>);</span><br><span class="line"></span><br><span class="line">ts1.start();</span><br><span class="line">ts2.start();</span><br><span class="line">ts3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>B:加入线程  (public final void join())<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public final void join():等待该线程终止。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadJoin tj1 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">ThreadJoin tj2 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">ThreadJoin tj3 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line"></span><br><span class="line">tj1.setName(<span class="string">"李渊"</span>);</span><br><span class="line">tj2.setName(<span class="string">"李世民"</span>);</span><br><span class="line">tj3.setName(<span class="string">"李元霸"</span>);</span><br><span class="line"></span><br><span class="line">tj1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">tj1.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tj2.start();</span><br><span class="line">tj3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C:礼让线程  (public static void yield())<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYield</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">Thread.yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public static void yield():暂停当前正在执行的线程对象，并执行其他线程。 </span></span><br><span class="line"><span class="comment"> * 让多个线程的执行更和谐，但是不能靠它保证一人一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYieldDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadYield ty1 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line">ThreadYield ty2 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line"></span><br><span class="line">ty1.setName(<span class="string">"林青霞"</span>);</span><br><span class="line">ty2.setName(<span class="string">"刘意"</span>);</span><br><span class="line"></span><br><span class="line">ty1.start();</span><br><span class="line">ty2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>D:后台线程  (public final void setDaemon(boolean on))<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemon</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public final void setDaemon(boolean on):将该线程标记为守护线程或用户线程。</span></span><br><span class="line"><span class="comment"> * 当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 游戏：坦克大战。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemonDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadDaemon td1 = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line">ThreadDaemon td2 = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line"></span><br><span class="line">td1.setName(<span class="string">"关羽"</span>);</span><br><span class="line">td2.setName(<span class="string">"张飞"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置收获线程</span></span><br><span class="line">td1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">td2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">td1.start();</span><br><span class="line">td2.start();</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setName(<span class="string">"刘备"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>E:终止线程  (public final void stop()/public void interrupt())<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStop</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始执行："</span> + <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我要休息10秒钟，亲，不要打扰我哦</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// e.printStackTrace();</span></span><br><span class="line">System.out.println(<span class="string">"线程被终止了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"结束执行："</span> + <span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public final void stop():让线程停止，过时了，但是还可以使用。</span></span><br><span class="line"><span class="comment"> * public void interrupt():中断线程。 把线程的状态终止，并抛出一个InterruptedException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadStop ts = <span class="keyword">new</span> ThreadStop();</span><br><span class="line">ts.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你超过三秒不醒过来，我就干死你</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// ts.stop();</span></span><br><span class="line">ts.interrupt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程的生命周期-参照-线程生命周期图解-bmp"><a href="#线程的生命周期-参照-线程生命周期图解-bmp" class="headerlink" title="线程的生命周期(参照    线程生命周期图解.bmp)"></a>线程的生命周期(参照    线程生命周期图解.bmp)</h3><p>A:新建<br>B:就绪<br>C:运行<br>D:阻塞<br>E:死亡<br><strong>如图所示：</strong><br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-16/99895317.jpg" alt=""></p><h3 id="电影院卖票程序的实现"><a href="#电影院卖票程序的实现" class="headerlink" title="电影院卖票程序的实现"></a>电影院卖票程序的实现</h3><p>A:继承Thread类<br>B:实现Runnable接口</p><h3 id="电影院卖票程序出问题"><a href="#电影院卖票程序出问题" class="headerlink" title="电影院卖票程序出问题"></a>电影院卖票程序出问题</h3><ol><li>为了更符合真实的场景，加入了休眠100毫秒。</li><li>卖票问题</li></ol><ul><li>同票多次</li><li>负数票<h3 id="多线程安全问题的原因"><a href="#多线程安全问题的原因" class="headerlink" title="多线程安全问题的原因"></a>多线程安全问题的原因</h3></li><li>是否有多线程环境</li><li>是否有共享数据</li><li>是否有多条语句操作共享数据<h3 id="同步解决线程安全问题"><a href="#同步解决线程安全问题" class="headerlink" title="同步解决线程安全问题"></a>同步解决线程安全问题</h3></li></ul><ol><li><p>同步代码块</p><pre><code>synchronized(对象) {    需要被同步的代码;}</code></pre><p> 这里的锁对象可以是任意对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//创建锁对象</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//while (true) &#123;</span></span><br><span class="line"><span class="comment">//synchronized(new Object())&#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100); </span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName() + "正在出售第"</span></span><br><span class="line"><span class="comment">//+ (tickets--) + "张票");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_09;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何解决线程安全问题呢?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 要想解决问题，就要知道哪些原因会导致出问题:(而且这些原因也是以后我们判断一个程序是否会有线程安全问题的标准)</span></span><br><span class="line"><span class="comment"> * A:是否是多线程环境</span></span><br><span class="line"><span class="comment"> * B:是否有共享数据</span></span><br><span class="line"><span class="comment"> * C:是否有多条语句操作共享数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 我们来回想一下我们的程序有没有上面的问题呢?</span></span><br><span class="line"><span class="comment"> * A:是否是多线程环境是</span></span><br><span class="line"><span class="comment"> * B:是否有共享数据是</span></span><br><span class="line"><span class="comment"> * C:是否有多条语句操作共享数据是</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 由此可见我们的程序出现问题是正常的，因为它满足出问题的条件。</span></span><br><span class="line"><span class="comment"> * 接下来才是我们要想想如何解决问题呢?</span></span><br><span class="line"><span class="comment"> * A和B的问题我们改变不了，我们只能想办法去把C改变一下。</span></span><br><span class="line"><span class="comment"> * 思想：</span></span><br><span class="line"><span class="comment"> * 把多条语句操作共享数据的代码给包成一个整体，让某个线程在执行的时候，别人不能来执行。</span></span><br><span class="line"><span class="comment"> * 问题是我们不知道怎么包啊?其实我也不知道，但是Java给我们提供了：同步机制。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步代码块：</span></span><br><span class="line"><span class="comment"> * synchronized(对象)&#123;</span></span><br><span class="line"><span class="comment"> * 需要同步的代码;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * A:对象是什么呢?</span></span><br><span class="line"><span class="comment"> * 我们可以随便创建一个对象试试。</span></span><br><span class="line"><span class="comment"> * B:需要同步的代码是哪些呢?</span></span><br><span class="line"><span class="comment"> * 把多条语句操作共享数据的代码的部分给包起来</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。</span></span><br><span class="line"><span class="comment"> * 多个线程必须是同一把锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个线程对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>同步方法</p><pre><code>把同步加在方法上。</code></pre><p> 这里的锁对象是this</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义同一把锁</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// t1,t2,t3都能走到这里</span></span><br><span class="line"><span class="comment">// 假设t1抢到CPU的执行权，t1就要进来</span></span><br><span class="line"><span class="comment">// 假设t2抢到CPU的执行权，t2就要进来,发现门是关着的，进不去。所以就等着。</span></span><br><span class="line"><span class="comment">// 门(开,关)</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123; <span class="comment">// 发现这里的代码将来是会被锁上的，所以t1进来后，就锁了。(关)</span></span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>); <span class="comment">// t1就睡眠了</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line"><span class="comment">//窗口1正在出售第100张票</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//t1就出来可，然后就开门。(开)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_10;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 举例：</span></span><br><span class="line"><span class="comment"> * 火车上厕所。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步的特点：</span></span><br><span class="line"><span class="comment"> * 前提：</span></span><br><span class="line"><span class="comment"> * 多个线程</span></span><br><span class="line"><span class="comment"> *解决问题的时候要注意：</span></span><br><span class="line"><span class="comment"> *多个线程使用的是同一个锁对象</span></span><br><span class="line"><span class="comment"> * 同步的好处 </span></span><br><span class="line"><span class="comment"> *同步的出现解决了多线程的安全问题。</span></span><br><span class="line"><span class="comment"> * 同步的弊端</span></span><br><span class="line"><span class="comment"> *当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个线程对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>静态同步方法</p><pre><code>把同步加在方法上。</code></pre><p> 这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义同一把锁</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步代码块用obj做锁</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//while (true) &#123;</span></span><br><span class="line"><span class="comment">//synchronized (obj) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同步代码块用任意对象做锁</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//while (true) &#123;</span></span><br><span class="line"><span class="comment">//synchronized (d) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SellTicket.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//synchronized (d) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">sellTicket();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private void sellTicket() &#123;</span></span><br><span class="line"><span class="comment">//synchronized (d) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果一个方法一进去就看到了代码被同步了，那么我就再想能不能把这个同步加在方法上呢?</span></span><br><span class="line"><span class="comment">// private synchronized void sellTicket() &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_11;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A:同步代码块的锁对象是谁呢?</span></span><br><span class="line"><span class="comment"> * 任意对象。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * B:同步方法的格式及锁对象问题?</span></span><br><span class="line"><span class="comment"> * 把同步关键字加在方法上。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步方法是谁呢?</span></span><br><span class="line"><span class="comment"> * this</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * C:静态方法及锁对象问题?</span></span><br><span class="line"><span class="comment"> * 静态方法的锁对象是谁呢?</span></span><br><span class="line"><span class="comment"> * 类的字节码文件对象。(反射会讲)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个线程对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="回顾以前的线程安全的类"><a href="#回顾以前的线程安全的类" class="headerlink" title="回顾以前的线程安全的类"></a>回顾以前的线程安全的类</h3><blockquote><p> StringBuffer<br>Vector<br>Hashtable</p></blockquote><p>如何把一个线程不安全的集合类变成一个线程安全的集合类<br>有两种方法，首先寻找原本就线程安全的类：CopyOnWriteArrayList、ConcurrentHashMap等方法来实现。<br>用Collections工具类的方法即可。比如synchronizedSet(Set<t> s)的静态方法，具体见下图。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-16/80203006.jpg" alt=""></t></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;多线程-一&quot;&gt;&lt;a href=&quot;#多线程-一&quot; class=&quot;headerlink&quot; title=&quot;多线程(一)&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Vector、ArrayList、LinkedList之间的区别？</title>
    <link href="http://yoursite.com/2018/07/14/Vector%E3%80%81ArrayList%E3%80%81LinkedList/"/>
    <id>http://yoursite.com/2018/07/14/Vector、ArrayList、LinkedList/</id>
    <published>2018-07-14T15:11:26.000Z</published>
    <updated>2018-07-14T15:12:11.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><p><strong>Vector</strong> 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</p><p><strong>ArrayList</strong> 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。</p><p><strong>LinkedList</strong> 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>一般来说，不同容器适合不同的场景。</p><ul><li>Vector和ArrayList都是动态数组，其内部元素以数组的顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会比较差，比如我们在元素中间插入一个元素，需要移动后续所有元素。</li><li>而LinkedList进行节点插入、删除效率很高，但是随机访问性能则要比动态数组慢很多。<br>对于Vector的分析可以看我之前的文章<a href="https://blog.jh0904.top/2018/06/06/Vector%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Vector的源码解析</a>，还有我在CSDN上面写的关于ArrayList的文章：<a href="https://blog.csdn.net/qq_34123742/article/details/80137160" target="_blank" rel="noopener">ArrayList源码分析</a><br>有什么不对请大家指正，感谢❤<br><strong>集合框架的整体设计</strong><br>可以如下图所示（并没有Map。虽然通常概念上它作为集合 框架的一部分，但是本本身并不是真正的集合）：</li></ul><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-14/77561179.jpg" alt="集合框架"></p><p>我们可以看到java的集合框架，Collection接口是所有的根，然后主要扩展了三大类集合：</p><ol><li><p>List,也就是我们前面介绍最多的有序集合，它提供了方便的访问、插入、删除等操作。</p></li><li><p>SetSet 是不允许重复元素的，这是和 List 最明显的区别，也就是不存在两个对象 equals 返回 true。我们在日常开发中有很多需要保证元素唯一性的场合。</p></li></ol><ol start="3"><li>Queue则是 Java 提供的标准队列结构的实现，除了集合的基本功能，它还支持类似先入先出（FIFO， First-in-First-Out）或者后入先出（LIFO，Last-In-First-Out）等特定行为。这里不包括 BlockingQueue，因为通常是并发编程场合，所以被放置在并发包里。</li></ol><p>其实总的来说，集合框架的学习还是重在源码的学习，里面有很多优秀的设计思路，也封装了很多数据结构，并且在并发编程的时候，还要注意使用不同的集合或是使用Collections的同步方法。<br>下面我放一些我对源码解析的文章（未完待续…大家一起学习，一起进步）</p><ul><li><a href="https://blog.csdn.net/qq_34123742/article/details/80077732" target="_blank" rel="noopener">Collection概述</a></li><li><a href="https://blog.csdn.net/qq_34123742/article/details/80137160" target="_blank" rel="noopener">ArrayList源码分析</a></li><li><a href="https://blog.csdn.net/qq_34123742/article/details/80261319" target="_blank" rel="noopener">Vector源码解析</a></li><li><a href="https://blog.jh0904.top/2018/06/08/hashmap/" target="_blank" rel="noopener">HashMap的源码解析</a></li><li>未完待续</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;基本概述&quot;&gt;&lt;a href=&quot;#基本概述&quot; class=&quot;headerlink&quot; title=&quot;基本概述&quot;&gt;&lt;/a&gt;基
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>int和Integer的区别？Integer的值缓存范围？</title>
    <link href="http://yoursite.com/2018/07/13/int%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FInteger%E7%9A%84%E5%80%BC%E7%BC%93%E5%AD%98%E8%8C%83%E5%9B%B4%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/13/int和Integer的区别？Integer的值缓存范围？/</id>
    <published>2018-07-13T12:45:33.000Z</published>
    <updated>2018-07-13T12:46:38.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>int 是我们常说的整形数字，是 Java 的 8 个原始数据类型（Primitive Types），boolean、byte 、short、char、int、float、double、long之一。Java 语言虽然号称一切都是对象，但原始数据类型是例外。</p><p>Integer 是 int 对应的包装类，它有一个 int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间转换等。在 Java 5 中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。</p><p>关于 Integer 的值缓存，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，这个值默认缓存是 -128 到 127 之间。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><h4 id="理解自动拆箱，自动装箱。"><a href="#理解自动拆箱，自动装箱。" class="headerlink" title="理解自动拆箱，自动装箱。"></a>理解自动拆箱，自动装箱。</h4><p>自动装箱实际是一种语法糖，语法糖是指java平台为我们自动进行了一些转换，保证不同写法在运行时等价，它们发生在编译阶段，而且生成的字节码是一致的。<br>就像之前说的int整数，javac会替我们自动装箱为Integer.valueOf()，把拆箱自动转换成Integer.valueOf()。我们可以看一下java的class文件反编译后的结果。<br>大致的包装类有：</p><blockquote><p>int——Integer<br>float——Float<br>double——Double<br>byte——Byte<br>long——Long<br>char——Character<br>boolean——Boolean<br>short——Short</p></blockquote><p>这是一个简单的自动拆/装箱的程序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Integer i=<span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> totalprim = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反编译输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Integer i = Integer.valueOf(<span class="number">99</span>);</span><br><span class="line">i.intValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仔细观察，其实就是通过Integer.valueOf(99)实现自动装箱。i.intValue()实现自动拆箱。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1=<span class="number">100</span>;</span><br><span class="line">      Integer i2=<span class="number">100</span>;</span><br><span class="line">      Integer i3=<span class="number">300</span>;</span><br><span class="line">      Integer i4=<span class="number">300</span>;</span><br><span class="line">      System.out.println(i1==i2);<span class="comment">//true</span></span><br><span class="line">      System.out.println(i3==i4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>在源码中，Integer.valueOf(int i)的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)  </span><br><span class="line">          <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];  </span><br><span class="line">      <span class="keyword">else</span>  </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到当i&gt;=-128且i&lt;=IntegerCache.high时，直接返回IntegerCache.cache[i + 128]。其中，IntegerCache为Integer的内部静态类。我们可以清楚地看到，IntegerCache有静态成员变量cache，为一个拥有256个元素的数组。在IntegerCache中也对cache进行了初始化，即第i个元素是值为i-128的Integer对象。而-128至127是最常用的Integer对象，这样的做法也在很大程度上提高了性能。也正因为如此，“Integeri1=100;Integer i2=100;”，i1与i2得到是相同的对象。</p><p><font style="color:red"><b>也就是说在-128—127的范围内为自动拆装箱。超过范围则不会自动转换，应该注意！！！<br></b><br></font><br>其实在阿里巴巴Java开发手册中，已经有介绍：</p><blockquote><p>所有的包装类对象之间值的比较，全部使用equals方法比较。<br>说明：对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 235;</span><br><span class="line">    Integer b = 235;</span><br><span class="line">    if (a.equals(b)) &#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>整体看一下Integer的职责，主要包括各种基础的常量，比如最大值、最小值、位数等。<br>首先，java默认大小是-128-127之间，其实这个值是可以修改的，可以通过JVM参数修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-xx:AutoBoxCacheMax=N</span><br></pre></td></tr></table></figure></p><p>这些实现都体现在java.lang.Integer中，并且实现在IntegerCache的静态初始化块中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =                VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>第二，我们在分析字符串的设计实现时，提到过字符串是不可变的，保证了基本的信息安全和并发编程中的线程安全。如果你去看包装类里存储数值的成员变量“ value”，你会发现，不管是 Integer还 Boolean等，都被声明为“ private final”，所以，它们同样是不可变类型！<br>这种设计是可以理解的，或者说是必须的选择。想象一下这个应用场景，比如 Integer提供了 getInteger()方法，用于方便地读取系统属性，我们可以用属性来设置服务器某个服务的端口，如果我可以轻易地把获取到的 Integer对象改变为其他数值，这会带来产品可靠性方面的严重问题。<br>第三， Integer等包装类，定义了类似 SIZE或者 BYTES这样的常量，这反映了什么样的设计考虑呢？如果你使用过其他语言，比如 C、 C++，类似整数的位数，其实是不确定的，可能在不同的平台，比如32位或者64位平台，存在非常大的不同。那么，在32位 JDK或者64。<br>其实，这种移植对于 Java来说相对要简单些，因为原始数据类型是不存在差异的，这些明确定义在 Java语言规范里面，不管是32位还是64位环境，开发者无需担心数据的位数差异。</p><h4 id="原始类线程安全"><a href="#原始类线程安全" class="headerlink" title="原始类线程安全"></a>原始类线程安全</h4><p>原始数据类型是不是线程安全？</p><ul><li>原始数据类型的变量，显然要通过使用并发相关手段，才能保证线程安全。如果需要线程安全这样的需求，可以直接考虑使用线程安全的类，比如：AtomicInteger/AtomicLong.</li><li>特别是一些比较宽的数据类型，比如float、do，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半的数据位。</li></ul><h4 id="java原始数据类型和应用类型的局限性"><a href="#java原始数据类型和应用类型的局限性" class="headerlink" title="java原始数据类型和应用类型的局限性"></a>java原始数据类型和应用类型的局限性</h4><p>原始数据类型的一些局限性：</p><ul><li><p><strong>原始数据类型不能和java泛型配合使用。</strong><br>这是因为 Java 的泛型某种程度上可以算作伪泛型，它完全是一种编译期的技巧，Java 编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为 Object。</p></li><li><p><strong>无法高效地表达数据，也不能表达复杂的数据结构，不如vector和tuple。</strong><br>我们知道 Java 的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。<br>Java 为对象内建了各种多态、线程安全等方面的支持，但这不是所有场合的需求，尤其是数据处理重要性日益提高，更加高密度的值类型是非常现实的需求。<br>目前，针对这些方面的增强，OpenJDK也在开发中，估计之后会有更好的发展。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>动态代理基于什么原理？</title>
    <link href="http://yoursite.com/2018/07/12/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/12/动态代理基于什么原理？/</id>
    <published>2018-07-12T03:08:48.000Z</published>
    <updated>2018-07-12T03:12:02.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p><p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>这道题会让人下意识的感觉是在考反射，但是实现动态代理的方式有很多，不止是反射一种。功能才是目的，实现的方法有很多。<br>主要的考察点：</p><ul><li>考察对反射的了解程度。</li><li>动态代理解决了什么问题，应用场景是什么？</li><li>JDK的动态代理的设计和实现和cgilb的方式有什么不同，如何选择两者？</li></ul><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.<br>通过反射可以动态获取Constructors、Method、Class、Field。这些只能获取公共的方法，要想获取私有的方法，需要加上getDeclared+…，。<br>其中还有反射提供的AccessibleObject.setAccessible(boolean flag),<br>这里的Accessible可以理解为修改成修饰成员public、protected、private。可以修改为false，取消java语法检查。这意味着可以在运行时修改成员变量的访问限制。<br>setAccessible 的应用场景非常普遍，遍布我们的日常开发、测试、依赖注入等各种框架中。比如，在 O/R Mapping 框架中，我们为一个 Java 实体对象，运行时自动生成 setter、getter 的逻辑，这是加载或者持久化数据非常必要的，框架通常可以利用反射做这个事情，而不需要开发者手动写类似的重复代码。</p><blockquote><p> <font style="color:red">需要注意的是在java9以后，这个方法有一些改变，因为新增的模块化系统，处于对系统封装性的考虑，对反射进行了一些限制,Jigsaw引入了所谓的open的概念，只有当被反射对象操作的模块和指定的包对反射调用者模块open，才能使用setAccessible，否则被认为不合法（illegal）。<br> </font><br>具体的操作可以参考我写的Demo：<a href="https://https://github.com/jh0904/GitTest/tree/master/GitTest1/src/cn/reflect" target="_blank" rel="noopener">reflect</a></p></blockquote><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>代理可以看做对调用目标的一个包装，这样我们可以对目标代码的调用不是直接发生的，而是通过代理完成的。<br>动态代理的作用可以用来做AOP。可以去做一些重复的工作（比如权限呢检验，日志记录），用动态代理去抽取出来。增强代码的易用性。</p><p>具体介绍一下java里面内置的Proxy类的一些简单操作：<br>在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib。</p><p>Proxy类中的方法创建动态代理类对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure></p><p>最终会调用InvocationHandler的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler Object invoke(Object proxy,Method method,Object[] args)</span><br></pre></td></tr></table></figure></p><p>动态代理的具体实现可以参考我的GitHub：<a href="https://github.com/jh0904/GitTest/tree/master/GitTest1/src/cn/reflect/proxy" target="_blank" rel="noopener">Proxy</a>。</p><p>cgilb实现动态代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待续...</span><br></pre></td></tr></table></figure></p><p>动态代理的使用场景：<br>AOP 通过（动态）代理机制可以让开发者从这些繁琐事项中抽身出来，大幅度提高了代码的抽象程度和复用度。从逻辑上来说，我们在软件设计和实现中的类似代理，如 Facade、Observer 等很多设计目的，都可以通过动态代理优雅地实现。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-12/37239512.jpg" alt=""></p><h4 id="JDK的动态代理的设计和实现和cgilb的方式有什么不同"><a href="#JDK的动态代理的设计和实现和cgilb的方式有什么不同" class="headerlink" title="JDK的动态代理的设计和实现和cgilb的方式有什么不同?"></a>JDK的动态代理的设计和实现和cgilb的方式有什么不同?</h4><p>我大概简单介绍一下：<br><strong>对于JDK Proxy的优势：</strong></p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li><li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li><li>代码实现简单。</li></ul><p><strong>cglib框架的优势：</strong></p><ul><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder的区别？</title>
    <link href="http://yoursite.com/2018/07/11/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/11/String、StringBuffer、StringBuilder的区别？/</id>
    <published>2018-07-11T06:18:26.000Z</published>
    <updated>2018-07-11T06:19:08.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p><h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><table><thead><tr><th></th><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>对象类型</td><td>字符串常量</td><td>字符串变量</td><td>字符串变量</td></tr><tr><td>线程安全</td><td>不安全</td><td>不安全</td><td>安全</td></tr><tr><td>执行效率</td><td>低</td><td>高</td><td>中</td></tr><tr><td>使用场景</td><td>操作少，数据少</td><td>单线程，操作多，数据多</td><td>多线程，操作多，数据多</td></tr></tbody></table><h3 id="String为什么设计成final？"><a href="#String为什么设计成final？" class="headerlink" title="String为什么设计成final？"></a>String为什么设计成final？</h3><p>原因无非就是下面几点：</p><ul><li>为了实现字符串池</li><li>为了线程安全</li><li>为了实现String可以创建HashCode不可变性</li></ul><p>首先要了解final关键字的含义，在之前的文章已经介绍过什么是fina具体可以查看之前的文章：<a href="https://blog.jh0904.top/2018/07/09/final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">final、finally、finalize的区别</a><br>我大概简述一下：final可以修饰类，方法和变量，并且被修饰的类或方法，被final修饰的类不能被继承，即它不能拥有自己的子类，被final修饰的方法不能被重写， final修饰的变量，无论是类属性、对象属性、形参还是局部变量，都需要进行初始化操作。<br>字符串在内存存储的样子如下图：<br><img src="http://i.imgur.com/3zlNPQJ.png" alt=""></p><p><strong>实现字符串池</strong><br>所以只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。<br><strong>线程安全</strong><br>如果字符串是可变的，那么会引起很严重的安全问题。因为字符串是不可变的，所以它的值是不可改变的，否则改变字符串指向的对象的值，造成安全漏洞。<br>因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。<br>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。<br><strong>HashCode不可变性</strong><br>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>强引用、软引用、弱引用、幻象引用有什么区别？</title>
    <link href="http://yoursite.com/2018/07/10/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/10/强引用、软引用、弱引用、幻象引用有什么区别？/</id>
    <published>2018-07-10T03:29:45.000Z</published>
    <updated>2018-07-10T03:31:56.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h3><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o=<span class="keyword">new</span> Object();   <span class="comment">//  强引用</span></span><br></pre></td></tr></table></figure></p><p>通过关键字new创建对象，所关联的引用就是强引用。当JVM内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。<br>如果不使用时，要通过如下方式来弱化引用，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o=<span class="keyword">null</span>;     <span class="comment">// 帮助垃圾收集器回收此对象</span></span><br></pre></td></tr></table></figure></p><p>显式的将o设置为null；或者超出对象的生命周期范围，则gc认为该对象不存在引用。这样就可以被垃圾收集了，具体回收时机还是要看垃圾回收机制。<br><strong>例子：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Object o=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于上述代码，可以看出方法的内部有一个强引用，这个引用保存在栈中，真正的引用内容（Object）保存在堆中。当这个方法运行完成之后就会退出方法栈，则引用内容的引用就不存在了，这个Object会被回收。<br>但是当这个o是全局变量时，就需要在不使用这个对象时要赋值为null，因为强引用不会被垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment">   * be empty after this call returns.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">          elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个就是在java源码中的体现。就是在需要清除的时候，需要把elementData里面全部置为空，因为elementData是全局变量。</p><h3 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h3><p>是一种相对强引用的弱化一些的引用，可以让豁免一些垃圾收集，只有当JVM尝试内存不足时。才会尝试回收软引用指定的对象。JVM会确保在抛出OutOfMemoryError之前，会先清理软引用指定的对象。软引用通常用于内存敏感的高速缓存，如果还有空内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"abc"</span>);                     </span><br><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;String&gt; softRef=<span class="keyword">new</span> SoftReference&lt;String&gt;(str);</span><br><span class="line"><span class="comment">// 软引用</span></span><br></pre></td></tr></table></figure></p><p>当内存不足时，等价于：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">If(JVM.内存不足()) &#123;</span><br><span class="line">   str = <span class="keyword">null</span>;  <span class="comment">// 转换为软引用</span></span><br><span class="line">   System.gc(); <span class="comment">// 垃圾回收器进行回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h3 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h3><p>弱引用并不能对对象实现豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系。比如，维护一种非强制性的映射关系，如果试图获取时对象还存在，就使用它，否则重现实例化。它同样是对缓存实现的选择。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"abc"</span>);    </span><br><span class="line">WeakReference&lt;String&gt; abcWeakRef = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br><span class="line">str=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>当垃圾回收器进行扫描时,等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = null;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure></p><p><strong>弱引用和软引用之间的去区别</strong>：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 </p><h3 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h3><p> “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  Java4种引用的级别由高到低依次为：<br> <font style="color:red"></font></p><blockquote><p>强引用  &gt;  软引用  &gt;  弱引用  &gt;  虚引用<br></p></blockquote><p>可以看一下在垃圾回收时候的图解：</p><center><br><br><img src="https://images2015.cnblogs.com/blog/647994/201702/647994-20170215235400691-2090269215.png" alt=""><br></center><p>当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章：</p><p>通过表格来说明一下，如下：</p><table><thead><tr><th>引用类型</th><th>被垃圾回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVN停止运行时终止</td></tr><tr><td>软引用</td><td>在内存不足时</td><td>对象缓存</td><td>内存不足时终止</td></tr><tr><td>弱引用</td><td>在垃圾回收时</td><td>对象缓存</td><td>GC运行后终止</td></tr><tr><td>虚引用</td><td>Unknow</td><td>Unknow</td><td>Unknow</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;强引用（StrongReference）&quot;&gt;&lt;a href=&quot;#强引用（StrongReference）&quot; class
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>final、finally、finalize的区别</title>
    <link href="http://yoursite.com/2018/07/09/final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/07/09/final、finally、finalize的区别/</id>
    <published>2018-07-09T13:03:35.000Z</published>
    <updated>2018-07-09T13:10:37.512Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，要我说，这个面试题，其中是三个其实没有什么联系，只不过是因为长的比较像，就拉出来考…但是从另一个方面看的话，这三个关键字还是很重要的。接下来简单介绍一下。</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final可以用来修饰类、方法、变量，分别有不同的意义，final修饰的类不可以继承的扩展。final修饰的方法不可以被重写（overrride），final修饰的变量则为常量（即不可修改的量）。</p><h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3><p>finally则是java保证重点代码一定要被执行的一种机制，我们可以使用try-catch-fianlly或者try-finally来进行关闭JDBC连接、或者用于关闭一些流对象（现在也有新方法，就是try-with-catch可以不使用fianlly）。</p><h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h3><p>finalize是基础类java.lang.Object的一个方法。它的设计目的是保证对象在垃圾收集前完成特定资源的回收。JDK9中已不推荐使用。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><h3 id="深入理解final关键字"><a href="#深入理解final关键字" class="headerlink" title="深入理解final关键字"></a>深入理解final关键字</h3><p>在java类库中的定义和源码中，在java.lang包下，相当一部分被声明成final class ？因为这可以有效避免API使用者更改基础功能，某种程度上，这是保证平台安全性的必要手段。</p><ul><li>使用fianl修饰变量或者参数，也可以清楚地避免意外赋值导致的编程错误。甚至有人明确推荐将所有的方法参数、本地变量、成员变量都声明成final。</li><li>final变量产生了某种程度上的不可变（immutable）的效果,所以，可以用来保护只读数据，尤其在并发编程中，因为明确地不能再赋值fianl变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。</li></ul><p>final还有性能上的好处<br>下面这段话摘自<i>《Java编程思想》</i>第四版第143页：</p><blockquote><p>“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。</p></blockquote><font style="color:red">注：类的private方法会隐式地被指定为final方法。</font><h3 id="深入理解finally关键字"><a href="#深入理解finally关键字" class="headerlink" title="深入理解finally关键字"></a>深入理解finally关键字</h3><p>对于finally来说，最常见的还是在try-catch-finally中。在Java语言的异常处理中，finally块的作用就是为了保证无论出现什么情况，finally块里的代码一定会被执行。但是其中有一些特殊情况。比如说出现java虚拟机退出的时候。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"><span class="comment">// do something Syst... </span></span><br><span class="line">System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello,World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就像出现上面的代码的时候，finally中并不会有任何反应。<br>对于finally还有其他的问题，比如，finally中return值到底会返回谁？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(getInt());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(a / <span class="number">0</span>);</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">a = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * return a在程序执行到这一步的时候，这里不是return a而是return 30;这个返回路径就形成了。</span></span><br><span class="line"><span class="comment"> * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span></span><br><span class="line"><span class="comment"> * 再次回到以前的返回路径，继续走return 30;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">a = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//如果这样结果就是40了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// return a;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大家仔细观察，其实最后的返回值是30，并没有返回其中的40，这就是说明返回值时，还是返回的是当时的值，和finally中的值并没有关系。这个是比较重要的一点。</p><p>其中在JDK1.7中有一个新特性：try-with-resources<br>try-with-resources语句是一个声明一个或多个资源的try语句。一个资源作为一个对象，必须在程序结束之后关闭。try-with-resources语句确保在语句的最后每个资源都被关闭，任何实现了java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resource来实现异常处理和关闭资源。<br>具体使用见下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line"><span class="keyword">return</span> br.readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把需要关闭的对象写在括号中，其中要关闭的对象必须实现java.lang.AutoCloseable和java.io.Closeable。</p><h3 id="深入理解finalize方法"><a href="#深入理解finalize方法" class="headerlink" title="深入理解finalize方法"></a>深入理解finalize方法</h3><p>finalize方法是比较难理解的一个方法，其中涉及了java垃圾回收机制的一些知识。<br>java提供finalize()方法，垃圾回收器准备释放内存的时候，会先调用finalize()。</p><ul><li>对象不一定会被回收。</li><li>垃圾回收不是析构函数。</li><li>垃圾回收只与内存有关。</li><li>垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。<br>上面的解释来自《java编程思想》，本人对其了解也不是很多。有待提升。</li></ul><blockquote><p>这就是今天的内容，来自于杨晓峰老师的讲解和一些自己的理解和认识。有能力的同学可以支持一下，共同进步，共同努力。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-8/91450487.jpg" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Exception与Error的区别</title>
    <link href="http://yoursite.com/2018/07/08/Exception%E4%B8%8EError%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/07/08/Exception与Error的区别/</id>
    <published>2018-07-08T06:10:27.000Z</published>
    <updated>2018-07-09T13:11:39.076Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h2 id="标准回答"><a href="#标准回答" class="headerlink" title="标准回答"></a>标准回答</h2><p>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p><p>Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a><strong>Error</strong></h3><p>是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a><strong>Exception</strong></h3><p>又分为可检查（checked）异常和不检查（unchecked）异常</p><p>可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。</p><p>不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>我们还需要注意两个方面的问题。</p><h3 id="一、理解Throwable、Exception、Error的设计和分类"><a href="#一、理解Throwable、Exception、Error的设计和分类" class="headerlink" title="一、理解Throwable、Exception、Error的设计和分类"></a>一、理解Throwable、Exception、Error的设计和分类</h3><p>下面是一个类的结构图，有助于我们去理解和掌握下面的子类</p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-8/36114315.jpg" alt="理解Throwable"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Throwable</span><br><span class="line">|--Error严重问题，我们不处理。</span><br><span class="line">|--Exception</span><br><span class="line">|--RuntimeException运行期异常，我们需要修正代码</span><br><span class="line">|--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过</span><br></pre></td></tr></table></figure></p><p>其中需要重点理解的是NoClassDefFoundError和NoClassFoundException的区别。</p><blockquote><p><strong>NoClassDefFoundError</strong>出现的时机是当你真正使用这个类的信息的时候，当class-path上没有这个类的时候会出现.<br>如果jvm或者一个ClassLoader的实例尝试去载入一个class的定义内容（普通方法的调用或者用new去创建这个class的实例）但是没有找到这个class的信息。这个是无法捕获的。<br><strong>ClassNotFoundException</strong>出现的时机就是一些反射操作，通过名称在Runtime去动态加载这个类的信息。这个可以抛出异常。</p></blockquote><h3 id="二、掌握java语言中操作Throwable的元素和实践。"><a href="#二、掌握java语言中操作Throwable的元素和实践。" class="headerlink" title="二、掌握java语言中操作Throwable的元素和实践。"></a>二、掌握java语言中操作Throwable的元素和实践。</h3><p>比如try-catch-finally块。throw、throws关键字等。</p><p>抛出异常的一些注意事项：</p><blockquote><p>A:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)<br>B:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常<br>C:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws</p></blockquote><p><strong>编译期异常和运行期异常的区别?</strong><br>            编译期异常 必须要处理的，否则编译不通过<br>            运行期异常 可以不处理，也可以处理</p><p><strong>throw、throws的区别？</strong><br><strong>throw:</strong><br>在方法体中,后面跟的是异常对象名,并且只能抛出一个异常对象名。表示抛出异常，由方法体内的语句进行处理。<br>throw抛出的是一个异常对象，说明这里肯定有一个异常产生了<br><strong>throws:</strong><br>在方法声明后面,后面跟的是异常的类名,可以抛出多个异常，用”，”隔开。表示抛出异常，由方法调用者进行处理。<br>throws是声明方法有异常，是一种可能性，这个异常并不一定会产生</p><hr><p>简单说一下try-catch-finally的一些注意事项和面试题：</p><ol><li><p>finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了，比如System.exit(0)。</p></li><li><p>如果catch里面有return语句，请问finally里面的代码还会执行吗<br>如果会，请问是在return前，还是return后。<br>会。前。<br>准确的说，应该是在中间。<br>具体可以仔细体会下面的代码，思考一下a的值最后是多少？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(getInt());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(a / <span class="number">0</span>);</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">a = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * return a在程序执行到这一步的时候，这里不是return a而是return 30;这个返回路径就形成了。</span></span><br><span class="line"><span class="comment"> * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span></span><br><span class="line"><span class="comment"> * 再次回到以前的返回路径，继续走return 30;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">a = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//如果这样结果就是40了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// return a;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中在JDK1.7中有一个新特性：<strong>try-with-resources</strong><br>try-with-resources语句是一个声明一个或多个资源的try语句。一个资源作为一个对象，必须在程序结束之后关闭。try-with-resources语句确保在语句的最后每个资源都被关闭，任何实现了java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resource来实现异常处理和关闭资源。<br>具体使用见下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line"><span class="keyword">return</span> br.readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把需要关闭的对象写在括号中，其中要关闭的对象必须实现java.lang.AutoCloseable和java.io.Closeable。</p><hr><blockquote><p>最后，衷心感谢杨晓峰老师的讲解。很清晰和透彻，也希望大家可以支持一下。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-8/91450487.jpg" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;标准回答&quot;&gt;&lt;a href=&quot;#标准回答&quot; class=&quot;headerlink&quot; title=&quot;标准回答&quot;&gt;&lt;/a&gt;标
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://yoursite.com/2018/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/07/04/多线程/</id>
    <published>2018-07-04T02:42:32.000Z</published>
    <updated>2018-07-04T02:43:21.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-多线程-理解"><a href="#1-多线程-理解" class="headerlink" title="1:多线程(理解)"></a>1:多线程(理解)</h3><ol><li>多线程：一个应用程序有多条执行路径<pre><code>进程：正在执行的应用程序线程：进程的执行单元，执行路径单线程：一个应用程序只有一条执行路径多线程：一个应用程序有多条执行路径**多进程的意义?**    提高CPU的使用率**多线程的意义?**    提高应用程序的使用率</code></pre></li><li><p><strong>Java程序的运行原理及JVM的启动是多线程的吗</strong>?</p><p>A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。</p><p>B:JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。</p></li><li><p><strong>多线程的实现方案(自己补齐步骤及代码    掌握)</strong></p><pre><code>A:继承Thread类B:实现Runnable接口</code></pre></li><li><strong>线程的调度和优先级问题</strong><pre><code>A:线程的调度    a:分时调度    b:抢占式调度 (Java采用的是该调度方式)B:获取和设置线程优先级    a:默认是5    b:范围是1-10</code></pre></li><li><strong>线程的控制(常见方法)</strong><pre><code>A:休眠线程B:加入线程C:礼让线程D:后台线程E:终止线程(掌握)</code></pre></li><li><strong>线程的生命周期(参照    线程生命周期图解.bmp)</strong><pre><code>A:新建B:就绪C:运行D:阻塞E:死亡</code></pre></li><li><strong>电影院卖票程序的实现</strong><pre><code>A:继承Thread类B:实现Runnable接口</code></pre></li><li><strong>电影院卖票程序出问题</strong><pre><code>A:为了更符合真实的场景，加入了休眠100毫秒。B:卖票问题    a:同票多次    b:负数票</code></pre></li><li><strong>多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)</strong><pre><code>A:是否有多线程环境B:是否有共享数据C:是否有多条语句操作共享数据</code></pre></li><li><p><strong>同步解决线程安全问题</strong></p><p>A:同步代码块</p><pre><code>synchronized(对象) {    需要被同步的代码;}这里的锁对象可以是任意对象。</code></pre><p>B:同步方法</p><pre><code>把同步加在方法上。这里的锁对象是this</code></pre><p>C:静态同步方法</p><pre><code>把同步加在方法上。这里的锁对象是当前类的字节码文件对象</code></pre></li><li><strong>回顾以前的线程安全的类</strong><pre><code>A:StringBufferB:VectorC:HashtableD:如何把一个线程不安全的集合类变成一个线程安全的集合类    用Collections工具类的方法即可。</code></pre></li><li><strong>JDK5以后的针对线程的锁定操作和释放操作</strong><pre><code>Lock锁</code></pre></li><li><p><strong>死锁问题的描述和代码体现</strong></p></li><li><p><strong>生产者和消费者多线程体现(线程间通信问题)</strong></p><pre><code>以学生作为资源来实现的</code></pre><p>资源类：Student</p><pre><code>设置数据类：SetThread(生产者)获取数据类：GetThread(消费者)测试类：StudentDemo</code></pre><p>代码：</p><pre><code>A:最基本的版本，只有一个数据。B:改进版本，给出了不同的数据，并加入了同步机制C:等待唤醒机制改进该程序，让数据能够实现依次的出现    wait()    notify()    notifyAll() (多生产多消费)D:等待唤醒机制的代码优化。把数据及操作都写在了资源类中</code></pre></li><li><strong>线程组</strong></li><li><strong>线程池</strong></li><li><strong>多线程实现的第三种方案</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h2&gt;&lt;h3 id=&quot;1-多线程-理解&quot;&gt;&lt;a href=&quot;#1-多线程-理解&quot; class=&quot;headerlink&quot; title=&quot;1:多线程
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程面试题</title>
    <link href="http://yoursite.com/2018/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/07/04/多线程面试题/</id>
    <published>2018-07-03T16:03:12.000Z</published>
    <updated>2018-07-03T16:04:07.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程面试题"><a href="#多线程面试题" class="headerlink" title="多线程面试题"></a>多线程面试题</h2><h4 id="1、多线程有什么用？"><a href="#1、多线程有什么用？" class="headerlink" title="1、多线程有什么用？"></a>1、多线程有什么用？</h4><p>一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p><p>（1）发挥多核CPU的优势</p><p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p><p>（2）防止阻塞</p><p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p><p>（3）便于建模</p><p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p><h4 id="2、创建线程的方式"><a href="#2、创建线程的方式" class="headerlink" title="2、创建线程的方式"></a>2、创建线程的方式</h4><p>比较常见的一个问题了，一般就是两种：</p><p>（1）继承Thread类</p><p>（2）实现Runnable接口</p><p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。</p><h4 id="3、start-方法和run-方法的区别"><a href="#3、start-方法和run-方法的区别" class="headerlink" title="3、start()方法和run()方法的区别"></a>3、start()方法和run()方法的区别</h4><p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p><h4 id="4、Runnable接口和Callable接口的区别"><a href="#4、Runnable接口和Callable接口的区别" class="headerlink" title="4、Runnable接口和Callable接口的区别"></a>4、Runnable接口和Callable接口的区别</h4><p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p><h4 id="5、CyclicBarrier和CountDownLatch的区别"><a href="#5、CyclicBarrier和CountDownLatch的区别" class="headerlink" title="5、CyclicBarrier和CountDownLatch的区别"></a>5、CyclicBarrier和CountDownLatch的区别</h4><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p><h4 id="6、Volatile关键字的作用"><a href="#6、Volatile关键字的作用" class="headerlink" title="6、Volatile关键字的作用"></a>6、Volatile关键字的作用</h4><p>一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：</p><p>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p><p>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</p><p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p><h4 id="7、什么是线程安全"><a href="#7、什么是线程安全" class="headerlink" title="7、什么是线程安全"></a>7、什么是线程安全</h4><p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</p><p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><p>（1）不可变</p><p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p><p>（2）绝对线程安全</p><p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p><p>（3）相对线程安全</p><p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</p><p>（4）线程非安全</p><p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><h4 id="8、Java中如何获取到线程dump文件"><a href="#8、Java中如何获取到线程dump文件" class="headerlink" title="8、Java中如何获取到线程dump文件"></a>8、Java中如何获取到线程dump文件</h4><p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p><p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p><p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，</p><h4 id="9、一个线程如果出现了运行时异常会怎么样"><a href="#9、一个线程如果出现了运行时异常会怎么样" class="headerlink" title="9、一个线程如果出现了运行时异常会怎么样"></a>9、一个线程如果出现了运行时异常会怎么样</h4><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p><h4 id="10、如何在两个线程之间共享数据"><a href="#10、如何在两个线程之间共享数据" class="headerlink" title="10、如何在两个线程之间共享数据"></a>10、如何在两个线程之间共享数据</h4><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><h4 id="11、sleep方法和wait方法有什么区别"><a href="#11、sleep方法和wait方法有什么区别" class="headerlink" title="11、sleep方法和wait方法有什么区别"></a>11、sleep方法和wait方法有什么区别</h4><p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><h4 id="12、生产者消费者模型的作用是什么"><a href="#12、生产者消费者模型的作用是什么" class="headerlink" title="12、生产者消费者模型的作用是什么"></a>12、生产者消费者模型的作用是什么</h4><p>这个问题很理论，但是很重要：</p><p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</p><p>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p><p>13、ThreadLocal有什么用<br>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p><h4 id="14、为什么wait-方法和notify-notifyAll-方法要在同步块中被调用"><a href="#14、为什么wait-方法和notify-notifyAll-方法要在同步块中被调用" class="headerlink" title="14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用"></a>14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</h4><p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p><h4 id="15、wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别"><a href="#15、wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别" class="headerlink" title="15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别"></a>15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</h4><p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p><h4 id="16、为什么要使用线程池"><a href="#16、为什么要使用线程池" class="headerlink" title="16、为什么要使用线程池"></a>16、为什么要使用线程池</h4><p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p><h4 id="17、怎么检测一个线程是否持有对象监视器"><a href="#17、怎么检测一个线程是否持有对象监视器" class="headerlink" title="17、怎么检测一个线程是否持有对象监视器"></a>17、怎么检测一个线程是否持有对象监视器</h4><p>我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程。</p><h4 id="18、synchronized和ReentrantLock的区别"><a href="#18、synchronized和ReentrantLock的区别" class="headerlink" title="18、synchronized和ReentrantLock的区别"></a>18、synchronized和ReentrantLock的区别</h4><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p><p>（2）ReentrantLock可以获取各种锁的信息</p><p>（3）ReentrantLock可以灵活地实现多路通知</p><p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><h4 id="19、ConcurrentHashMap的并发度是什么"><a href="#19、ConcurrentHashMap的并发度是什么" class="headerlink" title="19、ConcurrentHashMap的并发度是什么"></a>19、ConcurrentHashMap的并发度是什么</h4><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><h4 id="20、ReadWriteLock是什么"><a href="#20、ReadWriteLock是什么" class="headerlink" title="20、ReadWriteLock是什么"></a>20、ReadWriteLock是什么</h4><p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><h4 id="21、FutureTask是什么"><a href="#21、FutureTask是什么" class="headerlink" title="21、FutureTask是什么"></a>21、FutureTask是什么</h4><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><h4 id="22、Linux环境下如何查找哪个线程使用CPU最长"><a href="#22、Linux环境下如何查找哪个线程使用CPU最长" class="headerlink" title="22、Linux环境下如何查找哪个线程使用CPU最长"></a>22、Linux环境下如何查找哪个线程使用CPU最长</h4><p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p><p>（2）top -H -p pid，顺序不能改变</p><p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><h4 id="23、Java编程写一个会导致死锁的程序"><a href="#23、Java编程写一个会导致死锁的程序" class="headerlink" title="23、Java编程写一个会导致死锁的程序"></a>23、Java编程写一个会导致死锁的程序</h4><p>第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p><p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p><p>（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p><p>（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p><p>（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p><p>这样，线程1″睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。</p><h4 id="24、怎么唤醒一个阻塞的线程"><a href="#24、怎么唤醒一个阻塞的线程" class="headerlink" title="24、怎么唤醒一个阻塞的线程"></a>24、怎么唤醒一个阻塞的线程</h4><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><h4 id="25、不可变对象对多线程有什么帮助"><a href="#25、不可变对象对多线程有什么帮助" class="headerlink" title="25、不可变对象对多线程有什么帮助"></a>25、不可变对象对多线程有什么帮助</h4><p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><h4 id="26、什么是多线程的上下文切换"><a href="#26、什么是多线程的上下文切换" class="headerlink" title="26、什么是多线程的上下文切换"></a>26、什么是多线程的上下文切换</h4><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><h4 id="27、如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#27、如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="27、如果你提交任务时，线程池队列已满，这时会发生什么"></a>27、如果你提交任务时，线程池队列已满，这时会发生什么</h4><p>如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</p><h4 id="28、Java中用到的线程调度算法是什么"><a href="#28、Java中用到的线程调度算法是什么" class="headerlink" title="28、Java中用到的线程调度算法是什么"></a>28、Java中用到的线程调度算法是什么</h4><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><h4 id="29、Thread-sleep-0-的作用是什么"><a href="#29、Thread-sleep-0-的作用是什么" class="headerlink" title="29、Thread.sleep(0)的作用是什么"></a>29、Thread.sleep(0)的作用是什么</h4><p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><h4 id="30、什么是自旋"><a href="#30、什么是自旋" class="headerlink" title="30、什么是自旋"></a>30、什么是自旋</h4><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行地非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><h4 id="31、什么是Java内存模型"><a href="#31、什么是Java内存模型" class="headerlink" title="31、什么是Java内存模型"></a>31、什么是Java内存模型</h4><p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p><p>（1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p><p>（2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p><p>（3）定义了volatile变量的使用规则</p><p>（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p><h4 id="32、什么是CAS"><a href="#32、什么是CAS" class="headerlink" title="32、什么是CAS"></a>32、什么是CAS</h4><p>CAS，全称为Compare and Set，即比较-设置。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p><h4 id="33、什么是乐观锁和悲观锁"><a href="#33、什么是乐观锁和悲观锁" class="headerlink" title="33、什么是乐观锁和悲观锁"></a>33、什么是乐观锁和悲观锁</h4><p>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><h4 id="34、什么是AQS"><a href="#34、什么是AQS" class="headerlink" title="34、什么是AQS"></a>34、什么是AQS</h4><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p><p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p><p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p><h4 id="35、单例模式的线程安全性"><a href="#35、单例模式的线程安全性" class="headerlink" title="35、单例模式的线程安全性"></a>35、单例模式的线程安全性</h4><p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p><p>（1）饿汉式单例模式的写法：线程安全</p><p>（2）懒汉式单例模式的写法：非线程安全</p><p>（3）双检锁单例模式的写法：线程安全</p><h4 id="36、Semaphore有什么作用"><a href="#36、Semaphore有什么作用" class="headerlink" title="36、Semaphore有什么作用"></a>36、Semaphore有什么作用</h4><p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p><h4 id="37、Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步？"><a href="#37、Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步？" class="headerlink" title="37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？"></a>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</h4><p>这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p><p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p><p>（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p><p>（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。</p><h4 id="38、线程类的构造方法、静态块是被哪个线程调用的"><a href="#38、线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="38、线程类的构造方法、静态块是被哪个线程调用的"></a>38、线程类的构造方法、静态块是被哪个线程调用的</h4><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><p>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p><p>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p><h4 id="39、同步方法和同步块，哪个是更好的选择"><a href="#39、同步方法和同步块，哪个是更好的选择" class="headerlink" title="39、同步方法和同步块，哪个是更好的选择"></a>39、同步方法和同步块，哪个是更好的选择</h4><p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越少越好。</p><p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><h4 id="40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"><a href="#40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？" class="headerlink" title="40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"></a>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</h4><p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p><p>（2）并发不高、任务执行时间长的业务要区分开看：</p><p>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p><p>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p><p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多线程面试题&quot;&gt;&lt;a href=&quot;#多线程面试题&quot; class=&quot;headerlink&quot; title=&quot;多线程面试题&quot;&gt;&lt;/a&gt;多线程面试题&lt;/h2&gt;&lt;h4 id=&quot;1、多线程有什么用？&quot;&gt;&lt;a href=&quot;#1、多线程有什么用？&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>初识NIO一</title>
    <link href="http://yoursite.com/2018/06/22/NIO/"/>
    <id>http://yoursite.com/2018/06/22/NIO/</id>
    <published>2018-06-22T12:05:03.000Z</published>
    <updated>2018-07-07T10:08:34.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NIO概述"><a href="#NIO概述" class="headerlink" title="NIO概述"></a>NIO概述</h2><blockquote><p>[name=magic]</p></blockquote><p>Java NIO（New IO） 是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同， NIO支持面向缓冲区的、基于通道的IO操作。 NIO将以更加高效的方式进行文件的读写操作。</p><p>JDK之后的NIO：也叫做NIO2（BIO）</p><p>  Path：路径（与平台无关）</p><p>  Paths：有一个静态方法返回路径（返回Path的静态方法）</p><pre><code>public static Path get(URI uri);</code></pre><p>  Files：提供静态方法（操作文件的工具类）</p><pre><code>public static long copy(Path source, OutputStream out)将文件中的所有字节复制到输出流。public static Path write(Path path, Iterable lines, Charset cs, OpenOption... options)将文本行写入文件。</code></pre><h2 id="NIO与IO区别"><a href="#NIO与IO区别" class="headerlink" title="NIO与IO区别"></a>NIO与IO区别</h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(Blocking IO)</td><td>非阻塞IO(Non Blocking IO)</td></tr><tr><td>(无)</td><td>选择器(Selectors)</td></tr></tbody></table><h2 id="通道和缓冲区"><a href="#通道和缓冲区" class="headerlink" title="通道和缓冲区"></a>通道和缓冲区</h2><hr><p>Java NIO系统的核心在于：通道(Channel)和(Buffer)。通道表示打开到 IO 设备(例如：套接字)的连接。若需要使用 NIO 系统，需用于连接 IO 设备的通道以及用于容纳数据区。然后操作缓冲区，对数据进行处理</p><p><strong>简而言之， Channel 负责传输， Buffer 负责存储</strong></p><h3 id="NIO缓冲区（Buffer）"><a href="#NIO缓冲区（Buffer）" class="headerlink" title="NIO缓冲区（Buffer）"></a>NIO缓冲区（Buffer）</h3><hr><h4 id="缓冲区概述"><a href="#缓冲区概述" class="headerlink" title="缓冲区概述"></a>缓冲区概述</h4><ul><li><p>缓冲区（Buffer） ：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类</p></li><li><p>Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p></li></ul><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类：</p><ul><li><p>ByteBuffer</p></li><li><p>CharBuffer</p></li><li><p>ShortBuffer</p></li><li><p>IntBuffer</p></li><li><p>LongBuffer</p></li><li><p>FloatBuffer</p></li><li><p>DoubleBuffer</p></li></ul><p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。</p><p>都是通过如下方法获取一个 Buffer对象：</p><p>static XxxBuffer allocate(int capacity) : 创建一个容量为 capacity 的 XxxBuffer 对象</p><p>Buffer 中的重要概念：</p><blockquote><p>容量 (capacity) ： 表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。</p></blockquote><blockquote><p>限制 (limit)： 第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。</p></blockquote><blockquote><p>位置 (position)： 下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制</p></blockquote><blockquote><p>标记 (mark)与重置 (reset)： 标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position</p></blockquote><blockquote><p>并且  0 &lt; mark &lt;= position &lt;=limit &lt;= capacity</p></blockquote><h4 id="1-分配一个缓冲区"><a href="#1-分配一个缓冲区" class="headerlink" title="1. 分配一个缓冲区"></a>1. 分配一个缓冲区</h4><p>要获得一个Buffer对象，你必须首先分配它，通过allocate()分配了一个10字节大小的缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-6-30/44561032.jpg" alt="allocate"></p><h4 id="2-将数据写入缓冲区"><a href="#2-将数据写入缓冲区" class="headerlink" title="2. 将数据写入缓冲区"></a>2. 将数据写入缓冲区</h4><p>将数据写入缓冲区有两种方式：</p><p>  1.利用 put() 存入数据到缓冲区中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String str = <span class="string">"abcde"</span>;</span><br><span class="line"></span><br><span class="line">buf.put(str.getBytes());</span><br></pre></td></tr></table></figure><blockquote><p>put的方法总结<br>put(byte b)：将给定单个字节写入缓冲区的当前位置<br>put(byte[] src)：将 src 中的字节写入缓冲区的当前位置<br>put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position)</p></blockquote><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-6-30/31746203.jpg" alt="allocate"></p><p>  2.将数据从 Channel写入Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read（buf）;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入缓冲区。</span></span><br></pre></td></tr></table></figure><h4 id="3-filp"><a href="#3-filp" class="headerlink" title="3. filp()"></a>3. filp()</h4><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-6-30/52177585.jpg" alt="filp()"></p><p>该flip()方法将Buffer从写入模式切换到读取模式。调用flip()将position设置为0，并将其设置为limit 刚才的位置。</p><p>换句话说，position现在标记了读取位置，并limit标记了多少字节，字符等被写入缓冲区,可以读取的字节数，字节数等限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">buf.flip();</span><br></pre></td></tr></table></figure><h4 id="4-从缓冲区读取数据"><a href="#4-从缓冲区读取数据" class="headerlink" title="4. 从缓冲区读取数据"></a>4. 从缓冲区读取数据</h4><p>有两种方法可以从Buffer中读取数据。</p><p>1.将数据从缓冲区读入通道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//从缓冲区读入通道。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write（buf）;</span><br></pre></td></tr></table></figure><p>2.使用其中一个get（）方法自己从缓冲区中读取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line"></span><br><span class="line">buf.get(dst);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, dst.length));</span><br></pre></td></tr></table></figure><blockquote><p>get的一些方法总结<br>get() ：读取单个字节<br>get(byte[] dst)：批量读取多个字节到 dst 中<br>get(int index)：读取指定索引位置的字节(不会移动 position)</p></blockquote><h4 id="5-rewind"><a href="#5-rewind" class="headerlink" title="5. rewind()"></a>5. rewind()</h4><p>Buffer.rewind() 让 position 返回到0,这样你就可以重新读取缓冲区中的所有数据。在limit保持不变，因此仍然标记多少个元素（字节，字符等），可以从被读取Buffer。</p><h4 id="6-clear（）和compact（）"><a href="#6-clear（）和compact（）" class="headerlink" title="6. clear（）和compact（）"></a>6. clear（）和compact（）</h4><p>一旦你完成了读取数据，Buffer 准备好再次写入。你可以通过调用clear()或调用compact()。</p><p>如果调用clear（），则position将设置回0并且limit会变成capacity。, 换句话说，缓冲区被清除,但是缓冲区中的数据未被清除。, 只有markers告诉您可以将数据写入缓冲区的位置。</p><p>如果在调用clear（）时缓冲区中存在未读取的数据，那么数据将处于“forgotten”，这意味着不再有任何标记，指示已读取的数据以及尚未读取的数据。</p><p>如果Buffer中仍有未读数据，并且想稍后read，需要先写一些内容，调用compact（）而不是clear（）。</p><p>compact（）将所有未读数据复制到缓冲区的开始处。, 然后它将position设置在最后一个未读元素之后。, 极限属性仍然设置为容量，就像clear（）一样。, 现在缓冲区已准备好写入，但不会覆盖未读数据。</p><h4 id="7-mark（）和reset（）"><a href="#7-mark（）和reset（）" class="headerlink" title="7. mark（）和reset（）"></a>7. mark（）和reset（）</h4><p>可以通过调用Buffer.mark()方法在Buffer中标记给定的位置。然后可以通过调用该Buffer.reset() 方法将位置重新设置回标记的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        String str = <span class="string">"abcde"</span>;</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">buf.put(str.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line"></span><br><span class="line">buf.get(dst, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(buf.position());</span><br><span class="line"></span><br><span class="line"><span class="comment">//mark() : 标记</span></span><br><span class="line"></span><br><span class="line">buf.mark();</span><br><span class="line"></span><br><span class="line">buf.get(dst, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst, <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(buf.position());</span><br><span class="line"></span><br><span class="line"><span class="comment">//reset() : 恢复到 mark 的位置</span></span><br><span class="line"></span><br><span class="line">buf.reset();</span><br><span class="line"></span><br><span class="line">System.out.println(buf.position());</span><br></pre></td></tr></table></figure><h4 id="8-equals（）和compareTo（）"><a href="#8-equals（）和compareTo（）" class="headerlink" title="8. equals（）和compareTo（）"></a>8. equals（）和compareTo（）</h4><p>可以使用equals（）和compareTo（）来比较两个缓冲区</p><p>equals()</p><p>它们是相同的类型（byte，char，int等）</p><p>它们在缓冲区中具有相同数量的剩余字节，字符等。</p><p>所有剩余的字节，字符等是相等的。</p><p>正如你所看到的，equals只比较缓冲区的一部分，而不是它内部的每一个元素。, 实际上，它只是比较缓冲区中的其余元素。</p><p>compareTo()</p><p>该compareTo()方法比较两个缓冲区的其余元素（字节，字符等），用于例如排序例程。在下列情况下，缓冲区被认为比另一个缓冲区“小”</p><p>第一个元素等于另一个缓冲区中的对应元素，小于另一个缓冲区中的元素。</p><p>所有的元素都是相等的，但第一个缓冲区在第二个缓冲区之前耗尽元素（元素较少）。</p><h4 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h4><p><strong>非直接缓冲区</strong>：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中。<br><strong>直接缓冲区</strong>：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率。</p><ol><li>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在<br>此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），<br>虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。</li><li>直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消<br>分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对<br>应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的<br>本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好<br>处时分配它们。</li><li><p>直接字节缓冲区还可以通过 FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建。该方法返回<br>MappedByteBuffer 。 Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区<br>中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在<br>访问期间或稍后的某个时间导致抛出不确定的异常。</p></li><li><p>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在<br>性能关键型代码中执行显式缓冲区管理。<br><strong>非直接缓冲区</strong>：<br><img src="https://images2015.cnblogs.com/blog/554581/201706/554581-20170626235823993-1417525264.png" alt="非直接缓冲区"><br><strong>直接缓冲区</strong>：<br><img src="https://images2015.cnblogs.com/blog/554581/201706/554581-20170626235939664-204697244.png" alt="直接缓冲区"></p></li></ol><h3 id="NIO通道-Channel"><a href="#NIO通道-Channel" class="headerlink" title="NIO通道(Channel)"></a>NIO通道(Channel)</h3><hr><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>通道（Channel）</strong>：由 java.nio.channels 包定义<br>的。 Channel 表示 IO 源与目标打开的连接。<br>Channel 类似于传统的“流”。只不过 Channel<br>本身不能直接访问数据， Channel 只能与<br>Buffer 进行交互。</p><h4 id="通道和流的区别"><a href="#通道和流的区别" class="headerlink" title="通道和流的区别"></a>通道和流的区别</h4><p>通道有点类似于流，但是还是有一些区别的：</p><ul><li>流是单向的，或者输出流或是输入流，而通道是双向的。</li><li>通道可以被异步读取和写入。</li><li>通道始终读取或写入缓冲区。</li></ul><p>总的来说可以把之前学习的的流想象成水流，数据通过水流去传输，或是往上流或者往下流（单向）。<br>可以把通道想象成轨道，轨道本身不拥有数据，其中数据的传输是依靠火车（也就是缓冲区）来传输数据。并且双向都可。</p><h4 id="Channel实现类"><a href="#Channel实现类" class="headerlink" title="Channel实现类"></a>Channel实现类</h4><blockquote><p>FileChannel：用于读取、写入、映射和操作文件的通道。</p></blockquote><blockquote><p>DatagramChannel：通过 UDP 读写网络中的数据通道。</p></blockquote><blockquote><p>SocketChannel：通过 TCP 读写网络中的数据。</p></blockquote><blockquote><p>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</p></blockquote><h4 id="获取通道"><a href="#获取通道" class="headerlink" title="获取通道"></a>获取通道</h4><p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><p>获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获<br>取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道。</p><ul><li><p>将 Buffer 中数据写入 Channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Buffer中数据写入Channel中</span></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure></li><li><p>从 Channel 读取数据到 Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从Channel中读取数据到Buffer</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure></li></ul><p>两个例子：</p><hr><p><strong>1.利用通道复制文件（非直接缓冲区）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream (<span class="string">"d:/aa.mkv"</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream (<span class="string">"d:/11.mkv"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取通道</span></span><br><span class="line">    FileChannel fisChannel = fis.getChannel ();</span><br><span class="line">    FileChannel fosChannel = fos.getChannel ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.分配指定大小缓冲区</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate (<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将同道中的数据存入缓冲区</span></span><br><span class="line">    <span class="keyword">while</span> (fisChannel.read (buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buffer.flip ();<span class="comment">//切换成读数据模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.将缓冲区数据写入通道</span></span><br><span class="line">        fosChannel.write (buffer);</span><br><span class="line">        buffer.clear ();<span class="comment">//清空缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fosChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fosChannel.close ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fisChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fisChannel.close ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fos.close ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fis.close ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2.利用直接缓冲区（只有ByteBuffer支持）完成文件的复制（内存映射文件）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"d:/aa.mkv"</span>), StandardOpenOption.READ);</span><br><span class="line">       FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"d:/2.mkv"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * StandardOpenOption.CREATE-----------&gt;不存在就创建，存在就覆盖</span></span><br><span class="line"><span class="comment">        * StandardOpenOption.CREATE_NEW-----------&gt;不存在就创建，存在就报错</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//内存映射文件</span></span><br><span class="line">       MappedByteBuffer inMappedBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</span><br><span class="line">       MappedByteBuffer outMappedBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, inChannel.size());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//直接对缓冲区进行读写操作</span></span><br><span class="line">       <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[inMappedBuf.limit()];</span><br><span class="line">       inMappedBuf.get(dst);</span><br><span class="line">       outMappedBuf.put(dst);</span><br><span class="line"></span><br><span class="line">       inChannel.close();</span><br><span class="line">       outChannel.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="分散-Scatter-和聚集-Gather"><a href="#分散-Scatter-和聚集-Gather" class="headerlink" title="分散(Scatter)和聚集(Gather)"></a>分散(Scatter)和聚集(Gather)</h4><h5 id="分散读取（Scattering-Reads）"><a href="#分散读取（Scattering-Reads）" class="headerlink" title="分散读取（Scattering Reads）"></a>分散读取（Scattering Reads）</h5><p>分散读取（Scattering Reads）是指从 Channel 中读取的数据“分散” 到多个 Buffer 中.<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-7/60456679.jpg" alt=""><br>具体代码参考下例：</p><blockquote><p>注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满</p></blockquote><h5 id="聚集写入-Gathering-Writers"><a href="#聚集写入-Gathering-Writers" class="headerlink" title="聚集写入(Gathering Writers)"></a>聚集写入(Gathering Writers)</h5><p>聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。按照顺序写入通道中。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-7/75977247.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile (<span class="string">"aa.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="comment">//获取通道</span></span><br><span class="line">        FileChannel channel = file.getChannel ();</span><br><span class="line">        <span class="comment">//分配指定大小缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate (<span class="number">100</span>);</span><br><span class="line">        ByteBuffer buffer1 = ByteBuffer.allocate (<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//分散读取</span></span><br><span class="line">        ByteBuffer[] buf = &#123;buffer, buffer1&#125;;</span><br><span class="line">        channel.read (buf);</span><br><span class="line">        <span class="keyword">for</span> (ByteBuffer byteBuffer : buf) &#123;</span><br><span class="line">            byteBuffer.flip ();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println (<span class="keyword">new</span> String (buf[<span class="number">0</span>].array (), <span class="number">0</span>, buf[<span class="number">0</span>].limit ()));</span><br><span class="line">        System.out.println (<span class="string">"--------------------------------------------------------"</span>);</span><br><span class="line">        System.out.println (<span class="keyword">new</span> String (buf[<span class="number">1</span>].array (), <span class="number">0</span>, buf[<span class="number">1</span>].limit ()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//聚集写入</span></span><br><span class="line">        RandomAccessFile rw = <span class="keyword">new</span> RandomAccessFile (<span class="string">"hy.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel channel1 = rw.getChannel ();</span><br><span class="line">        channel1.write (buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="字符集（CharSet）"><a href="#字符集（CharSet）" class="headerlink" title="字符集（CharSet）"></a>字符集（CharSet）</h4><p>编码：字符串  —-&gt;字符数组。<br>解码：字符数组—-&gt;字符串。<br>首先常见的字符集有UTF-8和GBK。解码有一个思想，就是用什么编码， 用什么解码，就不会乱码。出现乱码肯定是因为编码和解码的码制不一样。</p><ol><li><p>首先了解都有什么码制,Charset就是java中码制的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       SortedMap&lt;String, Charset&gt; stringCharsetSortedMap = Charset.availableCharsets ();</span><br><span class="line">       Set&lt;Map.Entry&lt;String, Charset&gt;&gt; entries = stringCharsetSortedMap.entrySet ();</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, Charset&gt; entry : entries) &#123;</span><br><span class="line">           System.out.println (entry.getKey () + <span class="string">"---"</span> + entry.getValue ());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>用NIO实现编码和解码</p></li></ol><p>这个就是先用GBK进行编码和解码。没有乱码问题，但是用UTF-8进行解码。就出现了乱码。<br>所以说，解决乱码的根本途径就是编码和解码一致。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> CharacterCodingException </span>&#123;</span><br><span class="line">      Charset gbk = Charset.forName (<span class="string">"GBK"</span>);</span><br><span class="line">      <span class="comment">//获取编码器</span></span><br><span class="line">      CharsetEncoder ce = gbk.newEncoder ();</span><br><span class="line">      <span class="comment">//获取解码器</span></span><br><span class="line">      CharsetDecoder cd = gbk.newDecoder ();</span><br><span class="line"></span><br><span class="line">      CharBuffer allocate = CharBuffer.allocate (<span class="number">1024</span>);</span><br><span class="line">      allocate.put (<span class="string">"爱生活爱java"</span>);</span><br><span class="line">      allocate.flip ();</span><br><span class="line">      <span class="comment">//编码</span></span><br><span class="line">      ByteBuffer encode = ce.encode (allocate);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">          System.out.println (encode.get ());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//解码</span></span><br><span class="line">      encode.flip ();</span><br><span class="line">      CharBuffer decode = cd.decode (encode);</span><br><span class="line">      System.out.println (decode.toString ());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      System.out.println (<span class="string">"------------------------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      encode.flip ();</span><br><span class="line">      Charset utf = Charset.forName (<span class="string">"UTF-8"</span>);</span><br><span class="line">      CharBuffer decode1 = utf.decode (encode);</span><br><span class="line">      System.out.println (decode1.toString ());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NIO概述&quot;&gt;&lt;a href=&quot;#NIO概述&quot; class=&quot;headerlink&quot; title=&quot;NIO概述&quot;&gt;&lt;/a&gt;NIO概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;[name=magic]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java NIO（Ne
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Mysql必知必会（连接，查询，排序）</title>
    <link href="http://yoursite.com/2018/06/10/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%EF%BC%88%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%A3%80%E7%B4%A2%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/10/Mysql必知必会（连接，检索，排序）/</id>
    <published>2018-06-10T02:00:00.000Z</published>
    <updated>2018-06-10T04:24:26.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql必知必会（连接，检索，排序）"><a href="#Mysql必知必会（连接，检索，排序）" class="headerlink" title="Mysql必知必会（连接，检索，排序）"></a>Mysql必知必会（连接，检索，排序）</h1><p>分别对应Mysql必知必会3,4,5章节的内容。下面做简单的示例。</p><h2 id="连接数据库和进入"><a href="#连接数据库和进入" class="headerlink" title="连接数据库和进入"></a>连接数据库和进入</h2><ul><li>连接数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql -u ben   </span><br><span class="line">//以ben用户进入数据库  </span><br><span class="line">mysql -uroot -proot -h localhost -P 3306    </span><br><span class="line">//以root用户，root密码，本地ip，端口号3306进入mysql。</span><br><span class="line">mysql -uroot -proot   </span><br><span class="line">//默认本地，3306登录。</span><br></pre></td></tr></table></figure></li></ul><p>登录成功页面：</p><p><img src="http://i2.bvimg.com/648776/9a80d0733de45792.png" alt="Markdown"></p><p>选择数据库</p><blockquote><p>SHOW DATABASES;</p></blockquote><p>  //显示所有表空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| demo               |</span><br><span class="line">| exam               |</span><br><span class="line">| how2java           |</span><br><span class="line">| jh                 |</span><br><span class="line">| magic              |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| root               |</span><br><span class="line">| ssh                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><blockquote><p>USE jh</p></blockquote><p>  //使用jh数据库表空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use jh;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><blockquote><p>show tables;</p></blockquote><p>  //显示jh数据库中有哪些表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+--------------+</span><br><span class="line">| Tables_in_jh |</span><br><span class="line">+--------------+</span><br><span class="line">| category     |</span><br><span class="line">| customers    |</span><br><span class="line">| knowledge    |</span><br><span class="line">| orderitems   |</span><br><span class="line">| orders       |</span><br><span class="line">| productnotes |</span><br><span class="line">| products     |</span><br><span class="line">| user         |</span><br><span class="line">| vendors      |</span><br><span class="line">+--------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><blockquote><p>SHOW COLUMNS FROM customers<br>//查看表结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW COLUMNS FROM customers;</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">| Field        | Type      | Null | Key | Default | Extra          |</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">| cust_id      | int(11)   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| cust_name    | char(50)  | NO   |     | NULL    |                |</span><br><span class="line">| cust_address | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_city    | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_state   | char(5)   | YES  |     | NULL    |                |</span><br><span class="line">| cust_zip     | char(10)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_country | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_contact | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_email   | char(255) | YES  |     | NULL    |                |</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">9 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></p></blockquote><p>其实还有一些数据库的show语句：</p><blockquote><p>SHOW STATUS;   //显示服务器状态</p></blockquote><blockquote><p>SHOW CREATE DATABASE  ||  SHOW CREATE TABLE;  //显示特定数据库或表的语句</p></blockquote><blockquote><p>SHOW GRANTS;  //显示授权用户的安全权限</p></blockquote><blockquote><p>SHOW ERROR || SHOW WARNINGS;    //显示服务器错误和警告</p></blockquote><blockquote><p>DESC product;<br>查看表结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC products;</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra |</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">| prod_id    | char(10)     | NO   | PRI | NULL    |       |</span><br><span class="line">| vend_id    | int(11)      | NO   | MUL | NULL    |       |</span><br><span class="line">| prod_name  | char(255)    | NO   |     | NULL    |       |</span><br><span class="line">| prod_price | decimal(8,2) | NO   |     | NULL    |       |</span><br><span class="line">| prod_desc  | text         | YES  |     | NULL    |       |</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="数据库的查询"><a href="#数据库的查询" class="headerlink" title="数据库的查询"></a>数据库的查询</h2><p>select语句是用来从数据库中查询的语句，也是最重要的语句。<br>简单的说一下sql语句的一些要求:</p><ul><li>结束sql语句，用(;)号隔开；多条语句也是。</li><li>SQL语句不区分大小写，但是尽量在SQL关键字的时候使用大写，便于阅读和区分。</li><li>处理SQL语句的时候，其中所有的空格都被忽略，可以把所有语句写在一行，但是便于阅读，尽量分行写。<h3 id="检索单个列"><a href="#检索单个列" class="headerlink" title="检索单个列"></a>检索单个列</h3><blockquote><p>SELECT prod_name FROM products;</p></blockquote></li></ul><p>这个语句就是检索products中的  prod_name  这一列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">| prod_name      |</span><br><span class="line">+----------------+</span><br><span class="line">| .5 ton anvil   |</span><br><span class="line">| 1 ton anvil    |</span><br><span class="line">| 2 ton anvil    |</span><br><span class="line">| Detonator      |</span><br><span class="line">| Bird seed      |</span><br><span class="line">| Carrots        |</span><br><span class="line">| Fuses          |</span><br><span class="line">| JetPack 1000   |</span><br><span class="line">| JetPack 2000   |</span><br><span class="line">| Oil can        |</span><br><span class="line">| Safe           |</span><br><span class="line">| Sling          |</span><br><span class="line">| TNT (1 stick)  |</span><br><span class="line">| TNT (5 sticks) |</span><br><span class="line">+----------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h3><blockquote><p>select prod_id,prod_name,prod_price from products;</p></blockquote><p>这个语句就是检索products中的  prod_name,prod_name,prod_price  三列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id,prod_name,prod_price from products;</span><br><span class="line">+---------+----------------+------------+</span><br><span class="line">| prod_id | prod_name      | prod_price |</span><br><span class="line">+---------+----------------+------------+</span><br><span class="line">| ANV01   | .5 ton anvil   |       5.99 |</span><br><span class="line">| ANV02   | 1 ton anvil    |       9.99 |</span><br><span class="line">| ANV03   | 2 ton anvil    |      14.99 |</span><br><span class="line">| DTNTR   | Detonator      |      13.00 |</span><br><span class="line">| FB      | Bird seed      |      10.00 |</span><br><span class="line">| FC      | Carrots        |       2.50 |</span><br><span class="line">| FU1     | Fuses          |       3.42 |</span><br><span class="line">| JP1000  | JetPack 1000   |      35.00 |</span><br><span class="line">| JP2000  | JetPack 2000   |      55.00 |</span><br><span class="line">| OL1     | Oil can        |       8.99 |</span><br><span class="line">| SAFE    | Safe           |      50.00 |</span><br><span class="line">| SLING   | Sling          |       4.49 |</span><br><span class="line">| TNT1    | TNT (1 stick)  |       2.50 |</span><br><span class="line">| TNT2    | TNT (5 sticks) |      10.00 |</span><br><span class="line">+---------+----------------+------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h3><p>这个使用了通配符（*），这个代表所有的意思。</p><blockquote><p>select * from products;</p></blockquote><p>检索products的所有信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from products;</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">| prod_id | vend_id | prod_name      | prod_price | prod_desc                                                      |</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">| ANV01   |    1001 | .5 ton anvil   |       5.99 | .5 ton anvil, black, complete with handy hook                  |</span><br><span class="line">| ANV02   |    1001 | 1 ton anvil    |       9.99 | 1 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| ANV03   |    1001 | 2 ton anvil    |      14.99 | 2 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| DTNTR   |    1003 | Detonator      |      13.00 | Detonator (plunger powered), fuses not included                |</span><br><span class="line">| FB      |    1003 | Bird seed      |      10.00 | Large bag (suitable for road runners)                          |</span><br><span class="line">| FC      |    1003 | Carrots        |       2.50 | Carrots (rabbit hunting season only)                           |</span><br><span class="line">| FU1     |    1002 | Fuses          |       3.42 | 1 dozen, extra long                                            |</span><br><span class="line">| JP1000  |    1005 | JetPack 1000   |      35.00 | JetPack 1000, intended for single use                          |</span><br><span class="line">| JP2000  |    1005 | JetPack 2000   |      55.00 | JetPack 2000, multi-use                                        |</span><br><span class="line">| OL1     |    1002 | Oil can        |       8.99 | Oil can, red                                                   |</span><br><span class="line">| SAFE    |    1003 | Safe           |      50.00 | Safe with combination lock                                     |</span><br><span class="line">| SLING   |    1003 | Sling          |       4.49 | Sling, one size fits all                                       |</span><br><span class="line">| TNT1    |    1003 | TNT (1 stick)  |       2.50 | TNT, red, single stick                                         |</span><br><span class="line">| TNT2    |    1003 | TNT (5 sticks) |      10.00 | TNT, red, pack of 10 sticks                                    |</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="检索不同行"><a href="#检索不同行" class="headerlink" title="检索不同行"></a>检索不同行</h3><p>比如我们要查询的数据中，有多个重复的数据，我们只想要不同的数据。</p><blockquote><p>select vend_id from products;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select vend_id from products;</span><br><span class="line">+---------+</span><br><span class="line">| vend_id |</span><br><span class="line">+---------+</span><br><span class="line">|    1001 |</span><br><span class="line">|    1001 |</span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">|    1005 |</span><br><span class="line">+---------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>很明显很多数据是无用的。我们现在要来剔除这些重复。我们要使用这个关键字：distinct；要注意的是不能同时使用distinct限制多行， select distinct vend_id，prod_price from products;</p><blockquote><p>select distinct vend_id from products;除非两列都相同，否则都会被查出来。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select distinct vend_id from products;</span><br><span class="line">+---------+</span><br><span class="line">| vend_id |</span><br><span class="line">+---------+</span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">+---------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="限制结果-分页"><a href="#限制结果-分页" class="headerlink" title="限制结果(分页)"></a>限制结果(分页)</h3><blockquote><p>select prod_name from products limit 0,5;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name from products limit 0,5;</span><br><span class="line">+--------------+</span><br><span class="line">| prod_name    |</span><br><span class="line">+--------------+</span><br><span class="line">| .5 ton anvil |</span><br><span class="line">| 1 ton anvil  |</span><br><span class="line">| 2 ton anvil  |</span><br><span class="line">| Detonator    |</span><br><span class="line">| Bird seed    |</span><br><span class="line">+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>其中 0是开始位置，5是显示长度。</p><h2 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h2><h3 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h3><blockquote><p>select prod_name from products order by prod_name;</p></blockquote><p>把查询到的数据按照prod_name排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_name from products order by prod_name;</span><br><span class="line">+----------------+</span><br><span class="line">| prod_name      |</span><br><span class="line">+----------------+</span><br><span class="line">| .5 ton anvil   |</span><br><span class="line">| 1 ton anvil    |</span><br><span class="line">| 2 ton anvil    |</span><br><span class="line">| Bird seed      |</span><br><span class="line">| Carrots        |</span><br><span class="line">| Detonator      |</span><br><span class="line">| Fuses          |</span><br><span class="line">| JetPack 1000   |</span><br><span class="line">| JetPack 2000   |</span><br><span class="line">| Oil can        |</span><br><span class="line">| Safe           |</span><br><span class="line">| Sling          |</span><br><span class="line">| TNT (1 stick)  |</span><br><span class="line">| TNT (5 sticks) |</span><br><span class="line">+----------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="多个序列排序"><a href="#多个序列排序" class="headerlink" title="多个序列排序"></a>多个序列排序</h3><blockquote><p>select prod_id,prod_price,prod_name from products order by prod_price,prod_name;</p></blockquote><p>这个例子其实要这样子理解，就是只有在prod_price有相同的情况下，然后取按照prod_name排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id,prod_price,prod_name from products order by prod_price,prod_name;</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">| FU1     |       3.42 | Fuses          |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| ANV01   |       5.99 | .5 ton anvil   |</span><br><span class="line">| OL1     |       8.99 | Oil can        |</span><br><span class="line">| ANV02   |       9.99 | 1 ton anvil    |</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">| DTNTR   |      13.00 | Detonator      |</span><br><span class="line">| ANV03   |      14.99 | 2 ton anvil    |</span><br><span class="line">| JP1000  |      35.00 | JetPack 1000   |</span><br><span class="line">| SAFE    |      50.00 | Safe           |</span><br><span class="line">| JP2000  |      55.00 | JetPack 2000   |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="正序，倒序"><a href="#正序，倒序" class="headerlink" title="正序，倒序"></a>正序，倒序</h3><blockquote><p>select prod_id,prod_price,prod_name from products order by prod_price DESC;</p></blockquote><p>其中DESC是倒序的意思，升序就是ASC，但是ASC没有多大作用，因为默认就是ASC的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id,prod_price,prod_name from products order by prod_price DESC;</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| JP2000  |      55.00 | JetPack 2000   |</span><br><span class="line">| SAFE    |      50.00 | Safe           |</span><br><span class="line">| JP1000  |      35.00 | JetPack 1000   |</span><br><span class="line">| ANV03   |      14.99 | 2 ton anvil    |</span><br><span class="line">| DTNTR   |      13.00 | Detonator      |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| ANV02   |       9.99 | 1 ton anvil    |</span><br><span class="line">| OL1     |       8.99 | Oil can        |</span><br><span class="line">| ANV01   |       5.99 | .5 ton anvil   |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| FU1     |       3.42 | Fuses          |</span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="排序小结"><a href="#排序小结" class="headerlink" title="排序小结"></a>排序小结</h3><p>排序是不区分大小写的，对于sql语句来说，A和a的一样的。其实可以用order by 和 limit混合来使用。<br>比如，查询最高价格。</p><blockquote><p>select * from products order by prod_price DESC limit 1;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from products order by prod_price DESC limit 1;</span><br><span class="line">+---------+---------+--------------+------------+-------------------------+</span><br><span class="line">| prod_id | vend_id | prod_name    | prod_price | prod_desc               |</span><br><span class="line">+---------+---------+--------------+------------+-------------------------+</span><br><span class="line">| JP2000  |    1005 | JetPack 2000 |      55.00 | JetPack 2000, multi-use |</span><br><span class="line">+---------+---------+--------------+------------+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mysql必知必会（连接，检索，排序）&quot;&gt;&lt;a href=&quot;#Mysql必知必会（连接，检索，排序）&quot; class=&quot;headerlink&quot; title=&quot;Mysql必知必会（连接，检索，排序）&quot;&gt;&lt;/a&gt;Mysql必知必会（连接，检索，排序）&lt;/h1&gt;&lt;p&gt;分别
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>了解SQL</title>
    <link href="http://yoursite.com/2018/06/10/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%EF%BC%881,2%E7%AB%A0%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/10/Mysql必知必会（1,2章）/</id>
    <published>2018-06-10T01:48:00.000Z</published>
    <updated>2018-06-10T01:48:59.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解SQL"><a href="#了解SQL" class="headerlink" title="了解SQL"></a>了解SQL</h1><h2 id="1-DBMS数据库管理系统"><a href="#1-DBMS数据库管理系统" class="headerlink" title="1.DBMS数据库管理系统"></a>1.DBMS数据库管理系统</h2><ul><li><strong>数据库（database）</strong></li></ul><p>保存有组织的数据容器。DBMS是操纵和创建数据库的软件，不能直接访问数据库，是通过DBMS去访问。</p><ul><li><strong>表（table）</strong></li></ul><p>某种特定类型数据的结构化清单。一个结构化的文件，用来存储某种特定类型的数据。</p><ul><li><strong>模式（schema）</strong></li></ul><p>关于数据库和表的布局以及特征的信息</p><ul><li><strong>列（column）</strong></li></ul><p>表中的一个字段。所有的表都是由多个或一个列组成的。可以把它想象成一个网格，网格中每个列存储着一条特定的信息。</p><ul><li><strong>数据类型（datatype）</strong></li></ul><p>所容许的数据类型，它限制列中存储的数据。</p><ul><li><strong>行（row）</strong></li></ul><p>表中的一个记录。表中的行数也为记录的总数。</p><ul><li><strong>主键（primary key）</strong></li></ul><p>一列（或一组列），其值能够唯一区分表中的每个行。</p><p>++主键的规范++：</p><blockquote><p>任意两行都不能具有相同的主键值。<br>每个行都必须具有一个主键值（主键不允许为NULL）。</p></blockquote><h2 id="2-什么是SQL"><a href="#2-什么是SQL" class="headerlink" title="2.什么是SQL?"></a>2.什么是SQL?</h2><p>SQL是结构化查询语言（Structured Query Language），是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。<br>SQL的优点：</p><ul><li>SQL不是某个特定的数据库专用的语言，几乎所有的DBMS都支持SQL。</li><li>SQL简单易学，语句描述性很强。</li><li>SQL看上去很简单，但是是一个强有力的语言，可以进行很复杂的数据库操作。</li></ul><h2 id="3-MySQL简述"><a href="#3-MySQL简述" class="headerlink" title="3.MySQL简述"></a>3.MySQL简述</h2><p> MySQL是一个小型关系型数据库管理系统，开发者为瑞典MySQL AB公司，现在已经被Sun公司收购，支持FreeBSD、Linux、MAC、Windows等多种操作系统与其他的大型数据库例如Oracle、DB2、SQL Server等相比功能稍弱一些。其特点有：</p><p>1、可以处理拥有上千万条记录的大型数据；</p><p>2、支持常见的SQL语句规范；</p><p>3、可移植行高，安装简单小巧；</p><p>4、良好的运行效率，有丰富信息的网络支持；</p><p>5、调试、管理，优化简单（相对其他大型数据库）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;了解SQL&quot;&gt;&lt;a href=&quot;#了解SQL&quot; class=&quot;headerlink&quot; title=&quot;了解SQL&quot;&gt;&lt;/a&gt;了解SQL&lt;/h1&gt;&lt;h2 id=&quot;1-DBMS数据库管理系统&quot;&gt;&lt;a href=&quot;#1-DBMS数据库管理系统&quot; class=&quot;header
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的源码解析</title>
    <link href="http://yoursite.com/2018/06/08/hashmap/"/>
    <id>http://yoursite.com/2018/06/08/hashmap/</id>
    <published>2018-06-08T05:32:00.000Z</published>
    <updated>2018-06-30T02:12:15.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap的源码解析"><a href="#HashMap的源码解析" class="headerlink" title="HashMap的源码解析"></a>HashMap的源码解析</h1><h2 id="HashMap的概述"><a href="#HashMap的概述" class="headerlink" title="HashMap的概述"></a>HashMap的概述</h2><p>HashMap是常用的Java集合之一，是基于哈希表的Map接口的实现。<br>由于HashMap不是线程安全的，如果想要线程安全，可以使用ConcurrentHashMap代替。</p><p>API里面给的解释是：</p><blockquote><p>基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p></blockquote><h2 id="HashMap的继承体系"><a href="#HashMap的继承体系" class="headerlink" title="HashMap的继承体系"></a>HashMap的继承体系</h2><p>我们要了解一个类，首先要了解一下他的继承结构，，才能更好的理解这个类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt;</span><br><span class="line">extends AbstractMap&lt;K,V&gt;</span><br><span class="line">implements Map&lt;K,V&gt;,Cloneable, Serializable</span><br></pre></td></tr></table></figure><p>我们可以看一下继承图。这里我们要注意HashMap和Hashtable的继承是不一样的，Hashtable继承的是Dictionary。</p><p><img src="https://tech.meituan.com/img/java-hashmap/java.util.map%E7%B1%BB%E5%9B%BE.png" alt="Markdown"></p><p>大概介绍一下HashMap和Hashtable，</p><ul><li>HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li><li>Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</li></ul><h2 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h2><p>从结构实现来讲，HashMap 是数组+链表+红黑树<br>给大家一个图可以更加直观的了解其结构<br><img src="https://tech.meituan.com/img/java-hashmap/hashMap%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image"></p><p>我们其实还要想，到底是在底层是怎样存储的？为什么这样存，或者说有什么优点？</p><ol><li>我们能从上图看出来，首先是一个数组的存储,查看源码可知，有一个很重要的数组，Node&lt;K,V&gt;[] table，很明显，它是一个Node数组，我们来看一下Node的结构。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;  <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;  <span class="comment">//链表的下一个节点</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p><p>2.HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hs.put(1,&quot;magic&quot;);</span><br></pre></td></tr></table></figure></p><p>系统将调用”1”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。不会都加到一个下标下面的链表去。保证每一个的分散性、均匀性。要做到雨露均沾。</p><p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。</p><p>那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的==Hash算法==和==扩容机制==。</p><p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int threshold;             // 所能容纳的key-value对极限 </span><br><span class="line">  final float loadFactor;    // 负载因子</span><br><span class="line">  int modCount;  </span><br><span class="line">  int size;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">在 HashMap 中定义了几个常量:</span><br><span class="line"></span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line">  </span><br><span class="line">依次解释一下上面的变量：</span><br><span class="line">1. DEFAULT_INITIAL_CAPACITY: </span><br><span class="line">初始容量，也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。</span><br><span class="line">2. MAXIMUM_CAPACITY:</span><br><span class="line">哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。</span><br><span class="line">3. DEFAULT_LOAD_FACTOR:</span><br><span class="line">默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。</span><br><span class="line">4. TREEIFY_THRESHOLD:</span><br><span class="line">上文说过，如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于 8 时，有可能会转化成树。</span><br><span class="line">5. UNTREEIFY_THRESHOLD:</span><br><span class="line">在哈希表扩容时，如果发现链表长度小于 6，则会由树重新退化为链表。</span><br><span class="line">6. MIN_TREEIFY_CAPACITY:</span><br><span class="line">在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span><br></pre></td></tr></table></figure><p>首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p><p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，++扩容后的HashMap容量是之前容量的两倍++。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p><p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量（数组中现有的元素）。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p><p>在HashMap中，++哈希桶数组table的长度length大小必须为2的n次方(一定是合数)++，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="noopener">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a>，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，<br>==在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。==<br>而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="noopener">http://blog.csdn.net/v_july_v/article/details/6105630。</a></p><h2 id="HashMap的功能实现-方法"><a href="#HashMap的功能实现-方法" class="headerlink" title="HashMap的功能实现-方法"></a>HashMap的功能实现-方法</h2><p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p><h3 id="1-确定哈希桶数组索引位置"><a href="#1-确定哈希桶数组索引位置" class="headerlink" title="1. 确定哈希桶数组索引位置"></a>1. 确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">static final int hash(Object key) &#123;   //jdk1.8 </span><br><span class="line">     int h;</span><br><span class="line">     // h = key.hashCode() 为第一步 取hashCode值</span><br><span class="line">     // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span><br><span class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line">//jdk1.7</span><br><span class="line">static int hash(int h) &#123;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br><span class="line">方法二：</span><br><span class="line">static int indexFor(int h, int length) &#123;  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span><br><span class="line">     return h &amp; (length-1);  //第三步 取模运算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p><p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p><p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。<br>下面举例说明下，n为table的长度。<br><img src="https://tech.meituan.com/img/java-hashmap/hashMap%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE.png" alt="image"></p><h3 id="2-分析HashMap的put方法"><a href="#2-分析HashMap的put方法" class="headerlink" title="2. 分析HashMap的put方法"></a>2. 分析HashMap的put方法</h3><p>HashMap的put方法执行过程可以通过下图来理解.<br><img src="https://tech.meituan.com/img/java-hashmap/hashMap%20put%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image"><br>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">         // 对key的hashCode()做hash</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">//从put()进入putVal(hash(key), key, value, false, true)；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        // 步骤①：tab为空则创建</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        // 步骤②：计算index，并对null做处理 </span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">             // 步骤③：节点key存在，直接覆盖value</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            // 步骤④：判断该链为红黑树</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">             // 步骤⑤：该链为链表</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                          //链表长度大于8转换为红黑树进行处理</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                     // key已经存在直接覆盖value</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">         // 步骤⑥：超过最大容量 就扩容</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. 扩容机制</h3><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;   //传入新的容量</span><br><span class="line">      Entry[] oldTable = table;    //引用扩容前的Entry数组</span><br><span class="line">      int oldCapacity = oldTable.length;         </span><br><span class="line">      if (oldCapacity == MAXIMUM_CAPACITY) &#123;  //扩容前的数组大小如果已经达到最大(2^30)了</span><br><span class="line">          threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组</span><br><span class="line">     transfer(newTable);                         //！！将数据转移到新的Entry数组里</span><br><span class="line">     table = newTable;                           //HashMap的table属性引用新的Entry数组</span><br><span class="line">     threshold = (int)(newCapacity * loadFactor);//修改阈值</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line">     Entry[] src = table;                   //src引用了旧的Entry数组</span><br><span class="line">     int newCapacity = newTable.length;</span><br><span class="line">     for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组</span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             //取得旧Entry数组的每个元素</span><br><span class="line">         if (e != null) &#123;</span><br><span class="line">             src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span><br><span class="line">             do &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置</span><br><span class="line">                e.next = newTable[i]; //标记[1]</span><br><span class="line">                newTable[i] = e;      //将元素放在数组上</span><br><span class="line">                e = next;             //访问下一个Entry链上的元素</span><br><span class="line">            &#125; while (e != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。<br><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="image"></p><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，<br>++所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。++<br>看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE1.png" alt="image"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE2.png" alt="image"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://tech.meituan.com/img/java-hashmap/jdk1.8%20hashMap%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="image"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，<br>++由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。++<br>有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr = threshold;</span><br><span class="line">        int newCap, newThr = 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">          // 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br><span class="line">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">             // 没超过最大值，就扩充为原来的2倍</span><br><span class="line">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0) // initial capacity was placed in threshold初始容量被放入阈值</span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        else &#123;               // zero initial threshold signifies using defaults零初始阈值表示使用默认值</span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        // 计算新的resize上限</span><br><span class="line">        if (newThr == 0) &#123;</span><br><span class="line">            float ft = (float)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        if (oldTab != null) &#123;</span><br><span class="line">        // 把每个bucket都移动到新的buckets中</span><br><span class="line">            for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                    oldTab[j] = null;</span><br><span class="line">                    if (e.next == null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; // preserve order 链表优化重hash的代码块</span><br><span class="line">                        Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                             // 原索引</span><br><span class="line">                            if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                                if (loTail == null)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                             // 原索引+oldCap</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail == null)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e = next) != null);</span><br><span class="line">                         // 原索引放到bucket里</span><br><span class="line">                        if (loTail != null) &#123;</span><br><span class="line">                            loTail.next = null;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 原索引+oldCap放到bucket里</span><br><span class="line">                        if (hiTail != null) &#123;</span><br><span class="line">                            hiTail.next = null;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全性-待深入"><a href="#线程安全性-待深入" class="headerlink" title="线程安全性(待深入)"></a>线程安全性(待深入)</h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class HashMapInfiniteLoop &#123;  </span><br><span class="line"></span><br><span class="line">    private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f);  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        map.put(5， &quot;C&quot;);  </span><br><span class="line"></span><br><span class="line">        new Thread(&quot;Thread1&quot;) &#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                map.put(7, &quot;B&quot;);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        new Thread(&quot;Thread2&quot;) &#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                map.put(3, &quot;A);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p><p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。<br><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE1.png" alt="image"><br>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。<br><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE2.png" alt="image"><br>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。<br><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE4.png" alt="image"><br>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p><h2 id="JDK1-8与JDK1-7的性能对比"><a href="#JDK1-8与JDK1-7的性能对比" class="headerlink" title="JDK1.8与JDK1.7的性能对比"></a>JDK1.8与JDK1.7的性能对比</h2><p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。</p><h3 id="Hash较均匀的情况"><a href="#Hash较均匀的情况" class="headerlink" title="Hash较均匀的情况"></a>Hash较均匀的情况</h3><p>为了便于测试，我们先写一个类Key，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Key implements Comparable&lt;Key&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final int value;</span><br><span class="line"></span><br><span class="line">    Key(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Key o) &#123;</span><br><span class="line">        return Integer.compare(this.value, o.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass())</span><br><span class="line">            return false;</span><br><span class="line">        Key key = (Key) o;</span><br><span class="line">        return value == key.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Keys &#123;</span><br><span class="line"></span><br><span class="line">    public static final int MAX_KEY = 10_000_000;</span><br><span class="line">    private static final Key[] KEYS_CACHE = new Key[MAX_KEY];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        for (int i = 0; i &lt; MAX_KEY; ++i) &#123;</span><br><span class="line">            KEYS_CACHE[i] = new Key(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Key of(int value) &#123;</span><br><span class="line">        return KEYS_CACHE[value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void test(int mapSize) &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize);</span><br><span class="line">        for (int i = 0; i &lt; mapSize; ++i) &#123;</span><br><span class="line">            map.put(Keys.of(i), i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long beginTime = System.nanoTime(); //获取纳秒</span><br><span class="line">        for (int i = 0; i &lt; mapSize; i++) &#123;</span><br><span class="line">            map.get(Keys.of(i));</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime = System.nanoTime();</span><br><span class="line">        System.out.println(endTime - beginTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i=10;i&lt;= 1000 0000;i*= 10)&#123;</span><br><span class="line">            test(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：<br><img src="https://tech.meituan.com/img/java-hashmap/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A81.png" alt="image"></p><p>通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。</p><h3 id="Hash极不均匀的情况"><a href="#Hash极不均匀的情况" class="headerlink" title="Hash极不均匀的情况"></a>Hash极不均匀的情况</h3><p>假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Key implements Comparable&lt;Key&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仍然执行main方法，得出的结果如下表所示：<br><img src="https://tech.meituan.com/img/java-hashmap/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A82.png" alt="image"><br>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p><blockquote><p>测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p><p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p><p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p><p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p><p>(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap的源码解析&quot;&gt;&lt;a href=&quot;#HashMap的源码解析&quot; class=&quot;headerlink&quot; title=&quot;HashMap的源码解析&quot;&gt;&lt;/a&gt;HashMap的源码解析&lt;/h1&gt;&lt;h2 id=&quot;HashMap的概述&quot;&gt;&lt;a href=&quot;#Has
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java源码" scheme="http://yoursite.com/tags/java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
