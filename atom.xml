<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>magic</title>
  
  <subtitle>jh</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-09T09:41:04.284Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>magic_jh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习TCP/UDP</title>
    <link href="http://yoursite.com/2018/08/09/TCP%E7%9A%84%E7%9F%A5%E8%AF%86%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/08/09/TCP的知识讲解/</id>
    <published>2018-08-09T09:39:20.000Z</published>
    <updated>2018-08-09T09:41:04.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol><li>UDP是无连接的</li><li>UDP使用尽最大努力支付</li><li>UDP是面向报文</li><li>UDP是没有拥塞控制的</li><li>UDP支持一对一、一对多、多对一和多对多的交互通信</li><li>UDP首部开销小</li></ol><h4 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h4><blockquote><p>(1)  源端口      源端口号。在需要对方回信时选用。不需要时可用全0。</p></blockquote><blockquote><p>(2)  目的端口    目的端口号。 这在终点交付报文时必须要使用到。</p></blockquote><blockquote><p>(3)  长度        UDP用户数据报的长度，其最小值是8（仅有首部）</p></blockquote><blockquote><p>(4)  检验和      检测UDP用户数据报在传输中是否有错。有错就丢弃。 </p></blockquote><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-8/40408471.jpg" alt=""></p><h3 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h3><p>(1).TCP是面向连接的传输层协议。</p><p>(2).TCP连接只能有两个端点，TCP是点到点的。</p><p>(3).TCP提供可靠的交付服务，保证 传输的数据无差错，不可重，有序，不丢失。</p><p>(4).TCP提供全双工通信，TCP允许通信双 方任何时间都能发送数据，因此TCP两端都设有发送和接收缓存。</p><p>(5).TCP是面向字节流的。</p><p>TCP连接的端点是Socket。Socket=（ip地址:端口号）<br>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确认</p><blockquote><p>TCP连接 ::={socket1,socket2}={(IP1:port1),(IP2,port2)}</p></blockquote><h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><h5 id="无差错等待"><a href="#无差错等待" class="headerlink" title="无差错等待"></a>无差错等待</h5><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-9/31372188.jpg" alt=""></p><h5 id="出现差错"><a href="#出现差错" class="headerlink" title="出现差错"></a>出现差错</h5><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-9/4362718.jpg" alt=""></p><p>出现差错至少等待一轮发送时间，在重新发送请求。只有在收到确认之后才会删除之前的数据包缓存。</p><h5 id="确认丢失或确认迟到"><a href="#确认丢失或确认迟到" class="headerlink" title="确认丢失或确认迟到"></a>确认丢失或确认迟到</h5><p><img src="https://pic002.cnblogs.com/images/2012/387401/2012071009004976.png" alt="image"></p><p><strong>确认和重传机制就可以在不可靠的网路上实现可靠通信</strong></p><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>在说连续ARQ协议之前，先说一下信道利用率。<br>之前我们的传输是这样子的<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-9/56973725.jpg" alt=""><br>信道利用率的公式为 信道利用率U = TD / (TD + RTT + TA)</p><p>这样的信道利用率太低，很多时间都在等待确认的时候。所以出现了流水线传输（高信道利用率）。<br>就类似于这样子<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=410391870,930934059&amp;fm=27&amp;gp=0.jpg" alt="image"><br>一次性发送很多，再去等待确认。一般采用累计确认的方法，就是对到达的最后一个分组进行确认。<br>连续ARQ指的就是发送方维持的发送窗口，把位于窗口内的5个分组都发送出去，而不需要等待对方的确认。<br><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916130460.png" alt="image"></p><h3 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h3><p><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916030558.png" alt="image"></p><ul><li>源端口和目的端口:各占 2 字节.端口是传输层与应用层的服务接口.传输层的复用和分用功能都要通过端口才能实现</li><li>序号:　　占 4 字节.TCP 连接中传送的数据流中的每一个字节都编上一个序号.序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</li><li>确认号:　　占 4 字节,是期望收到对方的下一个报文段的数据的第一个字节的序号</li><li>数据偏移/首部长度:　　占 4 位,它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远.“数据偏移”的单位是 32 位字(以 4 字节为计算单位)</li><li>保留:　　占 6 位,保留为今后使用,但目前应置为 0</li><li>紧急URG:　　当 URG=1 时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)</li><li>确认ACK:　　只有当 ACK=1 时确认号字段才有效.当 ACK=0 时,确认号无效</li><li>PSH(PuSH):　　接收 TCP 收到 PSH = 1 的报文段,就尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付</li><li>RST (ReSeT):　　当 RST=1 时,表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）,必须释放连接,然后再重新建立运输连接</li><li>同步 SYN:　　同步 SYN = 1 表示这是一个连接请求或连接接受报文</li><li>终止 FIN:　　用来释放一个连接.FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接</li><li>检验和:　　占 2 字节.检验和字段检验的范围包括首部和数据这两部分.在计算检验和时,要在 TCP 报文段的前面加上 12 字节的伪首部</li><li>紧急指针:　　占 16 位,指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）</li><li>选项:　　长度可变.TCP 最初只规定了一种选项,即最大报文段长度 MSS.MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节.” [MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度.数据字段加上 TCP 首部才等于整个的 TCP 报文段]</li><li>填充:　　这是为了使整个首部长度是 4 字节的整数倍</li><li>在其中ACK应该和SYN放在一起学习<blockquote><p>ACK：确认 当ACK=1时，字段有效，ACK=0时，字段无效。<br>SYN：同步。<br>当SYN=1而ACK=0时，请求连接。当SYN=1，ACK=1时同意连接</p></blockquote></li></ul><h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><p>主要使用的是滑动窗口，主要实现如下：</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916135320.png" alt="image"></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916140463.png" alt="image"></h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916141121.png" alt="image"></h2><p><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916144958.png" alt="image"></p><p>特点:</p><ul><li>以字节为单位的滑动窗口</li><li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）</li></ul><p>要求:</p><ul><li>TCP 标准没有规定对不按序到达的数据应如何处理.通常是先临时存放在接收窗口中,等到字节流中所缺少的字节收到后,再按序交付上层的应用进程</li><li>TCP 要求接收方必须有累积确认的功能,这样可以减小传输开销</li></ul><p>还有一个就是选择确认SACK，就是说比如之前发送了这样的数据包</p><blockquote><p>[1,2,3][4,5,6]…[10,11,12]</p></blockquote><p>从上图我们可以看出丢失了[7,8,9]这几个数据包，下次应该从6开始重新发，但是[10,11,12]都已经接收了，需要把这些已经接收了的数据告诉发送法，不用在发送这些数据包了。</p><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>流量控制就是让发送方的数据不要太快，要让接收方来得及接收<br>在A向B发送数据，建立连接的时候。B就告诉了A。它的接收窗口（rwnd）的大小。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>拥塞控制的原理：就是网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这就是拥塞。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533786273784&amp;di=3c295c623aa38e1c1af1f0a705e500b4&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.elecfans.com%2Fbaike%2FUploadPic%2F2010-3%2F2010318145847583.JPG" alt="image"></p><p>拥塞控制的几个方法：发送方维持一个拥塞窗口，拥塞窗口取决于网络的拥塞程度，一直在动态变化着。发送方让自己的发送窗口等于拥塞窗口。<br>网络没有出现拥塞，拥塞窗口就大一点。出现就小一点。</p><p>慢开始就是由小到大逐渐增大发送窗口。每次加倍。</p><p>拥塞避免就是让拥塞窗口cwnd缓慢的增大，每经过一个往返时间RTT就把发送方的拥塞窗口加一，而不是加倍。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533786273784&amp;di=c24f0037bdc4a58b1abdec5415a424a2&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo2%2F98782a32beaf43c58acb22460859a38e.gif" alt="image"></p><p>快重传和快恢复：</p><p>快重传：一连收到三个重复确认的请求之后，就立即重传未被确认的报文段<br><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3472718141,1456460351&amp;fm=27&amp;gp=0.jpg" alt="image"></p><p>快恢复：当发送方接收到了三个重复请求之后，就执行“乘法减小”算法，把慢开始门限减半，而不是像慢开始降为1。</p><p>发送方窗口的上限值=Min[rend,cwnd]；发送方的发送窗口一定不能超过对方给出的接收窗口值。</p><h3 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h3><p>这个问题就比较经典了。主要就是连接时候的三次握手和断开连接的四次挥手协议。</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916204517.jpg" alt="image"></p><p>步骤:</p><ul><li>A 的 TCP 向 B 发出连接请求报文段,其首部中的同步位 SYN = 1,并选择序号 seq = x,表明传送数据时的第一个数据字节的序号是 x</li><li>B 的 TCP 收到连接请求报文段后,如同意,则发回确认(B 在确认报文段中应使 SYN = 1,使 ACK = 1,其确认号ack = x﹢1,自己选择的序号 seq = y)</li><li>A 收到此报文段后向 B 给出确认,其 ACK = 1,确认号 ack = y﹢1(A 的 TCP 通知上层应用进程,连接已经建立,B 的 TCP 收到主机 A 的确认后,也通知其上层应用进程：TCP 连接已经建立)<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4></li></ul><p><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916205749.jpg" alt="image"></p><p>步骤:</p><ul><li>数据传输结束后,通信的双方都可释放连接.现在 A 的应用进程先向其 TCP 发出连接释放报文段,并停止再发送数据,主动关闭 TCP 连接(A 把连接释放报文段首部的 FIN = 1,其序号seq = u,等待 B 的确认)</li><li>B 发出确认,确认号 ack = u＋1,而这个报文段自己的序号 seq = v(TCP 服务器进程通知高层应用进程.从 A 到 B 这个方向的连接就释放了,TCP 连接处于半关闭状态.B 若发送数据,A 仍要接收)</li><li>若 B 已经没有要向 A 发送的数据,其应用进程就通知 TCP 释放连接</li><li>A 收到连接释放报文段后,必须发出确认,在确认报文段中 ACK = 1,确认号 ack=w﹢1,自己的序号 seq = u + 1</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用户数据报协议UDP&quot;&gt;&lt;a href=&quot;#用户数据报协议UDP&quot; class=&quot;headerlink&quot; title=&quot;用户数据报协议UDP&quot;&gt;&lt;/a&gt;用户数据报协议UDP&lt;/h3&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络基础" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTTP面试考点</title>
    <link href="http://yoursite.com/2018/08/09/HTTP%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/"/>
    <id>http://yoursite.com/2018/08/09/HTTP面试考点/</id>
    <published>2018-08-09T09:39:01.000Z</published>
    <updated>2018-08-09T09:40:26.264Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><h3 id="Http与Https的区别"><a href="#Http与Https的区别" class="headerlink" title="Http与Https的区别"></a>Http与Https的区别</h3><ul><li>HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头</li><li>HTTP 是不安全的，而 HTTPS 是安全的</li><li>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</li><li>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</li><li>HTTP 无法加密，而HTTPS 对传输的数据进行加密</li><li>HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书<h3 id="什么是Http协议无状态协议-怎么解决Http协议无状态协议"><a href="#什么是Http协议无状态协议-怎么解决Http协议无状态协议" class="headerlink" title="什么是Http协议无状态协议?怎么解决Http协议无状态协议?"></a>什么是Http协议无状态协议?怎么解决Http协议无状态协议?</h3></li></ul><p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息</p><ul><li>也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。</li><li>可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。</li></ul><h3 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h3><p>上面这个图片具体解析了HTTPS的一个传输过程<br>具体的步骤如下：</p><ul><li>一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；</li><li>二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；</li><li>三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；</li><li>四、发送给服务端，此时只有服务端（RSA私钥）能解密。</li><li>五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-9/43312410.jpg" alt=""><h3 id="URI、URL、URN"><a href="#URI、URL、URN" class="headerlink" title="URI、URL、URN"></a>URI、URL、URN</h3></li></ul><h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。<br>URI一般由三部组成：</p><ul><li>①访问资源的命名机制</li><li>②存放资源的主机名</li><li>③资源自身的名称，由路径表示，着重强调于资源。<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：</li><li>①协议(或称为服务方式)</li><li>②存有该资源的主机IP地址(有时也包括端口号)</li><li>③主机资源的具体地址。如目录和文件名等</li></ul><h4 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h4><p>RN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:<a href="mailto:java-net@java.sun.com" target="_blank" rel="noopener">java-net@java.sun.com</a>。</p><h4 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h4><p>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</p><h4 id="在java中的区别"><a href="#在java中的区别" class="headerlink" title="在java中的区别"></a>在java中的区别</h4><p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。</p><p>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。</p><p>相反的是，URL类可以打开一个到达资源的流。</p><h3 id="常见的HTTP方法有哪些"><a href="#常见的HTTP方法有哪些" class="headerlink" title="常见的HTTP方法有哪些"></a>常见的HTTP方法有哪些</h3><blockquote><p>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</p></blockquote><blockquote><p>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</p></blockquote><blockquote><p>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</p></blockquote><blockquote><p>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</p></blockquote><blockquote><p>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</p></blockquote><blockquote><p>OPTIONS：查询相应URI支持的HTTP方法。</p></blockquote><h3 id="HTTP请求报文与响应报文格式"><a href="#HTTP请求报文与响应报文格式" class="headerlink" title="HTTP请求报文与响应报文格式"></a>HTTP请求报文与响应报文格式</h3><p><img src="https://segmentfault.com/img/remote/1460000013229039?w=735&amp;h=272" alt="image"><br>a、请求行：包含请求方法、URI、HTTP版本信息</p><p>b、请求首部字段</p><p>c、请求内容实体</p><p>d、空行<br><img src="https://segmentfault.com/img/remote/1460000013229040?w=724&amp;h=260" alt="image"><br>a、状态行：包含HTTP版本、状态码、状态码的原因短语</p><p>b、响应首部字段</p><p>c、响应内容实体</p><p>d、空行</p><h3 id="常见的HTTP相应状态码"><a href="#常见的HTTP相应状态码" class="headerlink" title="常见的HTTP相应状态码"></a>常见的HTTP相应状态码</h3><h4 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h4><pre><code>200：请求被正常处理204：请求被受理但没有资源可以返回206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</code></pre><h4 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h4><pre><code>301：永久性重定向302：临时重定向303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上304：发送附带条件的请求时，条件不满足时返回，与重定向无关307：临时重定向，与302类似，只是强制要求使用POST方法</code></pre><h4 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h4><pre><code>400：请求报文语法有误，服务器无法识别401：请求需要认证403：请求的对应资源禁止被访问404：服务器无法找到对应资源</code></pre><h4 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h4><pre><code>500：服务器内部错误503：服务器正忙</code></pre><h3 id="HTTP优化方案"><a href="#HTTP优化方案" class="headerlink" title="HTTP优化方案"></a>HTTP优化方案</h3><ul><li>TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。</li><li>内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。<br>压缩：将文本数据进行压缩，减少带宽</li><li>SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速</li><li>TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。</li><li><h3 id="为什么TCP需要第三次握手？"><a href="#为什么TCP需要第三次握手？" class="headerlink" title="为什么TCP需要第三次握手？"></a>为什么TCP需要第三次握手？</h3>三次握手是建立连接的过程，主要第一次是客户端请求服务端通信，第二次是服务端相应请求，接收通信。第三次就开始传输数据。<br>第三次的意义就在于，为了防止之前的连接请求报文段突然又传送到了服务器，因而发生错误。所以第三次请求。<blockquote><p>这是服务器的一种异常状况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才能到达B。 本来这是一个早已失效的报文段。   但B收到此失效的连接请求报文段后，就误认为A又发出了一次新的连接请求。    于是又向A发出确认报文段，同意建立连接。    假定不采用三次握手，那么只要B发出确认，新的连接就建立了。  由于现在A并没有发出建立连接的请求，因此不会理财B的确认，也不会向B发送数据。 但B却以为新的运输连接已经建立了，并一直等待A发来数据。 B的许多资源就这样浪费了。</p></blockquote></li></ul><h3 id="访问一个URl会发生什么？"><a href="#访问一个URl会发生什么？" class="headerlink" title="访问一个URl会发生什么？"></a>访问一个URl会发生什么？</h3><p>这个图是我在阅读深入分析Java Web技术内幕时候的一张图片，其实很好。这个其实比较像我们日常生活中经常使用的网页访问发生的过程。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-9/55123824.jpg" alt=""></p><p>首先抛出一个问题：我们在访问 <a href="http://www.jh0904.top/" target="_blank" rel="noopener">www.jh0904.top</a>,会发生什么？</p><p>过程的大概路径应该是这样子的：</p><ol><li>访问DNS域名服务器</li><li>发起连接（TCP的3次握手）</li><li>建立TCP连接后发起http请求</li><li>服务器响应http请求，浏览器得到html代码</li><li>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络基础" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>今天谈谈正则表达式</title>
    <link href="http://yoursite.com/2018/08/08/%E4%BB%8A%E5%A4%A9%E8%B0%88%E8%B0%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/08/今天谈谈正则表达式/</id>
    <published>2018-08-08T14:17:53.000Z</published>
    <updated>2018-08-08T14:45:55.942Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正则表达式的概述"><a href="#正则表达式的概述" class="headerlink" title="正则表达式的概述"></a>正则表达式的概述</h3><p> 编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p><p>就像我们在数据库中的“*”。</p><h3 id="正则表达式的基本语法"><a href="#正则表达式的基本语法" class="headerlink" title="正则表达式的基本语法"></a>正则表达式的基本语法</h3><p> 正则表达式是由 == 原意文本字符 == (a,b,c,1,2,3等)和 == 元字符 == ( . * ? 等)组成来匹配指定内容的表达式。</p><h4 id="原意文本字符"><a href="#原意文本字符" class="headerlink" title="原意文本字符"></a>原意文本字符</h4><p> 原意文本其实很好理解，就是我们平时经常使用的意义。比如说</p><ul><li>a在正则中表示匹配a这个字符</li><li>1在正则中表示匹配1这个字符<br>原意文本就是没有没有特殊的含义。<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4>元字符指在正则表达式中有特殊含义的专用字符，比如：</li></ul><table><thead><tr><th>元字符</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>\</td><td>转义字符，将后一个字符标记为特殊字符或将元字符转为原意字符</td><td>1、\表示匹配原意字符\； 2、.表示匹配英文句号“.” ； 3、\d表示匹配数字。</td></tr><tr><td>.</td><td>匹配除换行(\n)以外的所有字符</td><td>abc.能匹配到“abc”后面的那个字符，比如“abc”后面的空格、字母、数字、汉字等</td></tr><tr><td>^</td><td>匹配字符串的开始位置，在集合([])中表示“非”</td><td>1、^\d\d\d能匹配“123”、“666”等，但不能匹配“a123”、“b123”、“-123”等；<br> 2、^\w+\b表示匹配第一个单词；<br> 3、[^ajl]匹配除了“a”、“j”、“l”以外的任意字符。</td></tr><tr><td>$</td><td>匹配字符串的结束位置</td><td>^\d\d.\d\d$能匹配“12.01”和“00.00”等，但不能匹配“0.00”、“12.0”、“123.00”等</td></tr><tr><td>?</td><td>匹配前面子表达式0次或一次</td><td>good?可以匹配“goo”和“good”等，但是不能匹配“go”等</td></tr><tr><td>+</td><td>匹配1或多个正好在它之前的那个字符。</td><td>正则表达式9+匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。</td></tr><tr><td>*</td><td>匹配前面子表达式0次或多次</td><td>zo*能匹配“zo”、“zoo”、“zooo” </td></tr><tr><td>()</td><td>标记一个子表达式的开始和结束位置，其结束符号“)”是元字符</td><td></td></tr><tr><td>[</td><td>字符组的起始符号，其结束符号“]”不是元字符</td><td></td></tr><tr><td>{</td><td>标记限定符的开始，其结束符号“}”不是元字符</td><td></td></tr><tr><td> \</td><td>表示“或”</td><td>1、(a\b\c)匹配“a”、“b”、“c”之中的一个；</td></tr></tbody></table><p>如果要匹配元字符本身可以用\来取消元字符的特殊含义，比如.匹配英文句号”.”；*匹配“*”本身；+匹配“+”本身……<br><strong>常用表达式举例</strong></p><table><thead><tr><th>表达式</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td> \w</td><td>匹配字母、数字、下划线</td><td>abc\w表示匹配“abc”开头并且后面跟着一个字母或数字或下划线的字符串</td></tr><tr><td> \W</td><td>匹配非字母、非数字、非下划线</td><td>\W相当于[^\w]</td></tr><tr><td>\d</td><td>匹配数字</td><td>\d\d\d表示匹配3个连续的数字</td></tr><tr><td> \D</td><td>匹配非数字</td><td>\D相当于[^\d]</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td><td>\bgo\w*\b表示匹配“go”开头的一个单词</td></tr><tr><td> \B</td><td>匹配非单词的开始或结束</td><td>\B相当于[^\b]</td></tr><tr><td>\s</td><td>匹配任何空白字符，如回车、空格、制表符等</td><td>\s相当于[\f\n\r\t\v]</td></tr><tr><td>\S</td><td>匹配任何非空白字符</td><td>\S相当于[^\s]</td></tr><tr><td>{n}</td><td>匹配前面子表达式n次</td><td>\d{11}表示匹配连续的11个数字</td></tr><tr><td>{n,m}</td><td>匹配前面子表达式n到m次</td><td>\d{7,11}表示匹配连续的7-11个数字</td></tr><tr><td>{n,}</td><td>匹配前面子表达式n次以上</td><td>\d{5,}表示匹配连续的5个以上的数字</td></tr><tr><td> [xyz]</td><td>表示字符集，匹配所包含的任意一个字符</td><td>1、[abc]能匹配“a”或“b”或“c”；<br>2、[!?<em>.]表示匹配“!”、“?”、“</em>”、“.”中的任意一个；<br>3、[^0-9]匹配所有非0到9的字符，相当于\D。</td></tr><tr><td>[a-z]</td><td>表示字符范围，能匹配范围内的任意一个字符</td><td>1、[a-z]能匹配26个小写字母中任意字母；<br>2、[0-9]能匹配0到9的任意数字，和\d一样的效果；<br>3、[1-9]能匹配1到9的任意数字；<br> 4、[\u4e00-\u9fa5]能匹配所有汉字。</td></tr><tr><td>(abc)</td><td>组合，将几个项组合成为一个单元，可以对这个单元使用限定符</td><td>(\.[a-z]+)+$可以匹配“.com”、“.net”、“.com.cn”等结尾的字符</td></tr></tbody></table><p><strong>运算符优先级</strong></p><p>正则表达式是从左向右进行运算的，并遵循优先级顺序。优先级顺序如下表（先高后低）：</p><table><thead><tr><th>运算符</th><th>优先级</th><th>说明</th></tr></thead><tbody><tr><td> \</td><td>最高</td><td>转义字符</td></tr><tr><td>() (?:) (?=) []</td><td>高</td><td>圆括号和方括号</td></tr><tr><td> * + ? {n} {n,} {n,m}</td><td>中</td><td>限定符</td></tr><tr><td>^ $ \任何元字符 任何字符</td><td>低</td><td>定位点和序列（位置和顺序）</td></tr><tr><td>\</td><td>最低</td><td></td><td>选择符“或”</td></tr></tbody></table><h3 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h3><h4 id="汉字"><a href="#汉字" class="headerlink" title="汉字"></a>汉字</h4><blockquote><p> [\u4e00-\u9fa5] </p></blockquote><p> //中文ACALL码的范围</p><h4 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h4><p> 邮箱这个比较重要了，一般都会用到。就比如我们在写表单校验的时候。<br>  邮箱一般为“名称@域名”的格式，由于名称部分格式太多（有些邮箱名称允许有中文）不好限制，所以本文只验证名称和域名有“英文字母”、“数字”、“下划线”、“中划线(-)”、“英文句号(.)”的邮箱。</p><ul><li>\w可以匹配“英文字母、数字、下划线”</li><li>.可以匹配英文句号“ . ”</li><li>-可以匹配原意字符“ - ”本身</li><li>@可以匹配原意字符“ @ ”本身</li><li>([.-]\w+)可以匹配“ photo-google ”中的“ -google ”、“ photo.google ”中的“ .google ”</li><li>(.[a-zA-z0-9-]+)+可以匹配“ .com ”、“ .com.cn ”等</li><li></li></ul><blockquote><p>  表达式：^\w+([.-]\w+)*@[\w-]+(.[a-zA-z0-9-]+)+$ </p></blockquote><h4 id="手机号"><a href="#手机号" class="headerlink" title="手机号"></a>手机号</h4><p> 于号码段在不断更新，本文只验证“13”、“15”、“17”、“18”开头后面有9个数字的号码（如表达式1）</p><blockquote><p> 表达式1：^(13|15|17|18)\d{9}$ </p></blockquote><blockquote><p>表达式2：^(13[0-9]|15[0-9]|17[07]|18[05689])\d{8}$ </p></blockquote><h4 id="座机号"><a href="#座机号" class="headerlink" title="座机号"></a>座机号</h4><p>  座机号一般为“区号[-]号码”的格式，如果区号部分是3位则号码部分为8位，如021-67678989、02167678989；如果区号部分是4位则号码部分是7位，如0765-6767676、02167678989。</p><blockquote><p> 表达式1：^\d{3}-?\d{8}|\d{4}-?\d{7}$ </p></blockquote><blockquote><p>表达式2：^(\d{3}-?\d{8})|(\d{4}-?\d{7})$（由于选择符“|”优先级最低，所以组合符号“()”加与不加都行） </p></blockquote><h4 id="身份证"><a href="#身份证" class="headerlink" title="身份证"></a>身份证</h4><p>  身份证号码是由18个字符组成，前17个必须为数字(\d)，第一位不能为0([1-9])，最后一位可能是数字(\d)也可能是“x/X”([xX])。 </p><blockquote><p> 表达式：^[1-9]\d{16}[\dxX]$ </p></blockquote><h3 id="正则表达式匹配规则"><a href="#正则表达式匹配规则" class="headerlink" title="正则表达式匹配规则"></a>正则表达式匹配规则</h3><p> 　一切从最基本的开始。模式，是正规表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：</p><blockquote><p>^once</p></blockquote><p>　　这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。</p><blockquote><p>bucket$</p></blockquote><p>这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符^和$同时使用时，表示精确匹配（字符串与模式一样）。例如：</p><blockquote><p>　^bucket$</p></blockquote><p>　　只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式</p><blockquote><p>once</p></blockquote><p>与字符串There once was a man from NewYorkWho kept all of his cash in a bucket.是匹配的。</p><p>　　在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些??表符等），要用到转义序列。所有的转义序列都用反斜杠(\)打头。制表符的转义序列是：\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：</p><blockquote><p>　^\t</p></blockquote><p>类似的，用\n表示“新行”，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\表示，句号.用.表示，以此类推。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;正则表达式的概述&quot;&gt;&lt;a href=&quot;#正则表达式的概述&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的概述&quot;&gt;&lt;/a&gt;正则表达式的概述&lt;/h3&gt;&lt;p&gt; 编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之序列化是什么鬼？</title>
    <link href="http://yoursite.com/2018/08/05/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/08/05/Java基础之序列化是什么鬼？/</id>
    <published>2018-08-05T13:29:41.000Z</published>
    <updated>2018-08-05T13:30:30.933Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><p>java的序列化和反序列化是java中很常见的一种。我们其实平时对集合、线程或是反射什么了解比较多，其实序列化在我们编写java程序中也起很大的作用。序列化的主要工作是把一个java对象变成二进制的字节流，反序列化就是把二进制字节流变成java对象。接下来我们来看一下具体的操作。</p><h3 id="序列化和反序列化的概念"><a href="#序列化和反序列化的概念" class="headerlink" title="序列化和反序列化的概念"></a>序列化和反序列化的概念</h3><ul><li><strong>对象的序列化</strong>：把对象转换为字节序列的过程称为对象的序列化。</li><li><strong>对象的反序列化</strong>：把字节序列恢复为对象的过程称为对象的反序列化。</li></ul><p>对象序列化的作用：其实序列化主要有两个用途：</p><ol><li>把对象的字节序列化永久的保存到硬盘上，通常保存在一个文件中。</li><li>在网络上传输对象的字节序列。</li></ol><p>把对象保存到文件中，离开内存，长住物理硬盘。常见的应用就是Web服务器中的Session对象，当10万用户并发访问时，就有可能出现10万个session对象，内存不够，所以先保存一些到硬盘中去。需要的时候，再拿出来还原到内存中。</p><p>当两个进程在进行远程通信的时候，彼此可以传输数据。但是不论什么类型的数据，都以二进制序列的形式在网络上传输。如下图：</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6UJdaLSwqy1mO5WOGibSkJwZbicsDuZMMich29LAeL09SNZwVwickEbjX2dJBP3PsV4IOaDf9XYYnN4ibjw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="序列化"></p><p>从某种意义上来说，可以让java对象跨越时间和空间，获得永生。但是永生也是有代价的，就是必须使用java语言（哈哈，java序列化肯定是java语言）。</p><h3 id="Java中的序列化API"><a href="#Java中的序列化API" class="headerlink" title="Java中的序列化API"></a>Java中的序列化API</h3><p> <strong>java.io.ObjectOutputStream</strong>代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p><p><strong>java.io.ObjectInputStream</strong>代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</p><p>只有实现了Serializable或Externalizable接口的类的对象才能被序列化。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。<br><strong>对象序列化包括如下步骤：</strong></p><ol><li>创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；</li><li>通过对象输出流的writeObject()方法写对象.</li></ol><p><strong>对象反序列化的步骤：</strong></p><ol><li>创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流</li><li>通过对象输入流的readObject()方法读取对象。</li></ol><p>代码实现：<br>定义一个POJO类，实现Serializable接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day02;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ClassName: Person&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description:测试对象序列化和反序列化&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0 V</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2014-6-9 下午02:33:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5809782578272943999L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">package</span> day02;</span><br><span class="line"><span class="keyword">import</span> day02.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.text.MessageFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ClassName: TestObjSerializeAndDeserialize&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description: 测试对象的序列化和反序列&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0 V</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2014-6-9 下午03:17:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjSerializeAndDeserialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">SerializePerson();<span class="comment">//序列化Person对象</span></span><br><span class="line">Person p = DeserializePerson();<span class="comment">//反序列Perons对象</span></span><br><span class="line">System.out.println(MessageFormat.format(<span class="string">"name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;"</span>,</span><br><span class="line">p.getName(), p.getAge(), p.getSex()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MethodName: SerializePerson</span></span><br><span class="line"><span class="comment"> * Description: 序列化Person对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SerializePerson</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException,</span></span><br><span class="line"><span class="function">IOException </span>&#123;</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"gacl"</span>);</span><br><span class="line">person.setAge(<span class="number">25</span>);</span><br><span class="line">person.setSex(<span class="string">"男"</span>);</span><br><span class="line"><span class="comment">// ObjectOutputStream 对象输出流，将Person对象存储到E盘的Person.txt文件中，完成对Person对象的序列化操作</span></span><br><span class="line">ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line"><span class="keyword">new</span> File(<span class="string">"D:/Person.txt"</span>)));</span><br><span class="line">oo.writeObject(person);</span><br><span class="line">System.out.println(<span class="string">"Person对象序列化成功！"</span>);</span><br><span class="line">oo.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MethodName: DeserializePerson</span></span><br><span class="line"><span class="comment"> * Description: 反序列Perons对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Person <span class="title">DeserializePerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception, IOException </span>&#123;</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line"><span class="keyword">new</span> File(<span class="string">"D:/Person.txt"</span>)));</span><br><span class="line">Person person = (Person) ois.readObject();</span><br><span class="line">System.out.println(<span class="string">"Person对象反序列化成功！"</span>);</span><br><span class="line"><span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果的展示：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-5/36273983.jpg" alt=""><br>这个是程序运行的结果，主要是一些字节码的文件。打开看一下，就是这个样子的：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-5/91761324.jpg" alt=""></p><p>大家会发现什么都看不懂，其实很正常，给计算机看的又不是给我们看的。我们可以看反序列化之后，就成为了一个简单的对象。是不是很酷！</p><h3 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h3><p>serialVersionUID表示<strong>：“串行化版本统一标识符”</strong>（serial version universal identifier），简称UID</p><p>serialVersionUID必须定义成下面这种形式：static final long serialVersionUID = xxxL;</p><p>serialVersionUID 用来表明类的不同版本间的兼容性。有两种生成方式： 一个是默认的1L；另一种是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段 。。</p><p>如果你添加了serialVersionUID，在反序列旧有实例时，新添加或更改的字段值将设为初始化值（对象为null，基本类型为相应的初始默认值），字段被删除将不设置。 </p><p>具体的还是代码演示一下具有说服力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerialversionUID</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SerializeCustomer();<span class="comment">// 序列化Customer对象</span></span><br><span class="line">        Customer customer = DeserializeCustomer();<span class="comment">// 反序列Customer对象</span></span><br><span class="line">        System.out.println(customer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MethodName: SerializeCustomer </span></span><br><span class="line"><span class="comment">     * Description: 序列化Customer对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SerializeCustomer</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException,</span></span><br><span class="line"><span class="function">            IOException </span>&#123;</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer(<span class="string">"gacl"</span>,<span class="number">25</span>);</span><br><span class="line">        <span class="comment">// ObjectOutputStream 对象输出流</span></span><br><span class="line">        ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                <span class="keyword">new</span> File(<span class="string">"E:/Customer.txt"</span>)));</span><br><span class="line">        oo.writeObject(customer);</span><br><span class="line">        System.out.println(<span class="string">"Customer对象序列化成功！"</span>);</span><br><span class="line">        oo.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MethodName: DeserializeCustomer </span></span><br><span class="line"><span class="comment">     * Description: 反序列Customer对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Customer <span class="title">DeserializeCustomer</span><span class="params">()</span> <span class="keyword">throws</span> Exception, IOException </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                <span class="keyword">new</span> File(<span class="string">"E:/Customer.txt"</span>)));</span><br><span class="line">        Customer customer = (Customer) ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">"Customer对象反序列化成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ClassName: Customer&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description: Customer实现了Serializable接口，可以被序列化&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0 V</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2014-6-9 下午04:20:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Customer类中没有定义serialVersionUID</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @MethodName toString</span></span><br><span class="line"><span class="comment">     * @Description 重写Object类的toString()方法</span></span><br><span class="line"><span class="comment">     * @author xudp</span></span><br><span class="line"><span class="comment">     * @return string</span></span><br><span class="line"><span class="comment">     * @see java.lang.Object#toString()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name="</span> + name + <span class="string">", age="</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面的Customer类没有定义serialVersionUID，执行序列化操作是没有问题的，但是如果我们对这个类进行一些修改。比如新添加一个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Customer类中没有定义serialVersionUID</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新添加的sex属性</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age,String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @MethodName toString</span></span><br><span class="line"><span class="comment">     * @Description 重写Object类的toString()方法</span></span><br><span class="line"><span class="comment">     * @author xudp</span></span><br><span class="line"><span class="comment">     * @return string</span></span><br><span class="line"><span class="comment">     * @see java.lang.Object#toString()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name="</span> + name + <span class="string">", age="</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们新添加一个属性sex，但是现在序列化的同时出现了错误。</p><blockquote><p> Exception in thread “main” java.io.InvalidClassException: Customer; <br><br>local class incompatible: <br><br> stream classdesc serialVersionUID = -88175599799432325, <br><br>local class serialVersionUID = -5182532647273106745<br></p></blockquote><p>其实出现错误的原因是这样的：就是文件中和classpath中的class，现在不一致了。处于安全的考虑，程序此时就出现了错误。并且拒绝载入。如果想解决这种问题，就去自己指定一个serialVersionUID。只要我们的文件进行了修改，得到的UID就不同，可以保证就算有多个类，我们的UID也一致。显示定义的用途已经在下面写了。希望对大家有一点帮助。</p><h3 id="serialVersionUID的取值"><a href="#serialVersionUID的取值" class="headerlink" title="serialVersionUID的取值"></a>serialVersionUID的取值</h3><p>　serialVersionUID的取值是Java运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。<br>　　类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。</p><p>　　显式地定义serialVersionUID有两种用途：<br>　　　　1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；<br>　　　　2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之IO这个硬骨头（二）</title>
    <link href="http://yoursite.com/2018/08/04/Java%E5%9F%BA%E7%A1%80%E4%B9%8BIO%E8%BF%99%E4%B8%AA%E7%A1%AC%E9%AA%A8%E5%A4%B4%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/04/Java基础之IO这个硬骨头（二）/</id>
    <published>2018-08-04T12:32:19.000Z</published>
    <updated>2018-08-05T00:00:45.998Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><p>上一次基本讲解了一下IO中字节流的一些知识点和操作，总的来说字符流的操作和字节流差不多，关键在于编码集的一些问题。这篇文章就主要讲解java中字符流和字符集。</p><h3 id="字符集的操作"><a href="#字符集的操作" class="headerlink" title="字符集的操作"></a>字符集的操作</h3><h4 id="字符集是什么尼？"><a href="#字符集是什么尼？" class="headerlink" title="字符集是什么尼？"></a>字符集是什么尼？</h4><p>字符集就是是各种文字和符号的总称，简单来说就是由字符和对应的数值组成的一张表。 推荐一篇文章    <a href="https://blog.csdn.net/qq_28098067/article/details/53486032" target="_blank" rel="noopener">字符集详解（一看就懂系列）</a> ，这篇文章详细的介绍了字符集的一些知识，以及字符集的演变。</p><h4 id="常见的字符集："><a href="#常见的字符集：" class="headerlink" title="常见的字符集："></a>常见的字符集：</h4><p>下面用一个图片来解释一下简单的字符集：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-4/87471290.jpg" alt=""><br>这张图介绍了常用的字符集。</p><h4 id="java中的CharSet"><a href="#java中的CharSet" class="headerlink" title="java中的CharSet"></a>java中的CharSet</h4><p>这些知识使我们从网上查到的，我们在代码中如何知道有什么字符集尼？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    SortedMap&lt;String, Charset&gt; stringCharsetSortedMap = Charset.availableCharsets ();  </span><br><span class="line">   Set&lt;Map.Entry&lt;String, Charset&gt;&gt; entries = stringCharsetSortedMap.entrySet ();  </span><br><span class="line"> <span class="keyword">for</span> (Map.Entry&lt;String, Charset&gt; entry : entries) &#123;  </span><br><span class="line">        System.out.println (entry.getKey () + <span class="string">"---"</span> \+ entry.getValue ());  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这样，我们可以查找出所有的字符集。</p><h4 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h4><p>对于大多数程序猿来说，乱码都是经常发生的事情，但是为什么会乱码？<br>其实这个问题很简单，就像上面编码表的那张图片一样，就是因为编码和解码用的码制不一样，大家可以看下面的例子，用GBK进行编码，用GBK解码，就可以解码出数据，但是使用UTF-8进行数据的解码，就出现问题，此时的数据就成了乱码，我们就无法解析了。<br>所以说，只要编码和解码的码制一样，就不会乱码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Test  </span><br><span class="line">public <span class="keyword">void</span> test6() throws CharacterCodingException &#123;  </span><br><span class="line">    Charset gbk = Charset.forName (<span class="string">"GBK"</span>);  </span><br><span class="line">   <span class="comment">//获取编码器  </span></span><br><span class="line">   CharsetEncoder ce = gbk.newEncoder ();  </span><br><span class="line">   <span class="comment">//获取解码器  </span></span><br><span class="line">   CharsetDecoder cd = gbk.newDecoder ();  </span><br><span class="line"></span><br><span class="line">   CharBuffer allocate = CharBuffer.allocate (<span class="number">1024</span>);  </span><br><span class="line">   allocate.put (<span class="string">"爱生活爱java"</span>);  </span><br><span class="line">   allocate.flip ();  </span><br><span class="line">   <span class="comment">//编码  </span></span><br><span class="line">   ByteBuffer encode = ce.encode (allocate);  </span><br><span class="line"> <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;  </span><br><span class="line">        System.out.println (encode.get ());  </span><br><span class="line">   &#125;  </span><br><span class="line">    <span class="comment">//解码  </span></span><br><span class="line">   encode.flip ();  </span><br><span class="line">   CharBuffer decode = cd.decode (encode);  </span><br><span class="line">   System.out.println (decode.toString ());  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   System.out.println (<span class="string">"------------------------"</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   encode.flip ();  </span><br><span class="line">   Charset utf = Charset.forName (<span class="string">"UTF-8"</span>);  </span><br><span class="line">   CharBuffer decode1 = utf.decode (encode);  </span><br><span class="line">   System.out.println (decode1.toString ());  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="字符流的基本操作"><a href="#字符流的基本操作" class="headerlink" title="字符流的基本操作"></a>字符流的基本操作</h3><p>上面介绍了编码的一些知识点，之所以解释这个是因为字符流其实就是编码表加上字节流，下来介绍字符流的操作吧。</p><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>转换流是什么尼？其实因为字节流处理中文不是很方便，有时候需要字符流处理文字，所以出现了转换流。转换流的作用就是把一个字节流转换成一个字符流。</p><p>转换流其实本质上就是一个字节流加上编码表</p><p>InputStreamReader代码展示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InputStreamReader(InputStream is):用默认的编码读取数据</span></span><br><span class="line"><span class="comment"> * InputStreamReader(InputStream is,String charsetName):用指定的编码读取数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="comment">// InputStreamReader isr = new InputStreamReader(new FileInputStream(</span></span><br><span class="line"><span class="comment">// "osw.txt"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InputStreamReader isr = new InputStreamReader(new FileInputStream(</span></span><br><span class="line"><span class="comment">// "osw.txt"), "GBK");</span></span><br><span class="line"></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(</span><br><span class="line"><span class="string">"osw.txt"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 一次读取一个字符</span></span><br><span class="line">int ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((ch = isr.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">System.out.print((char) ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">isr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OutputStreamWriter代码展示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OutputStreamWriter(OutputStream out):根据默认编码把字节流的数据转换为字符流</span></span><br><span class="line"><span class="comment"> * OutputStreamWriter(OutputStream out,String charsetName):根据指定编码把字节流数据转换为字符流</span></span><br><span class="line"><span class="comment"> * 把字节流转换为字符流。</span></span><br><span class="line"><span class="comment"> * 字符流 = 字节流 +编码表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamWriterDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="comment">// OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(</span></span><br><span class="line"><span class="comment">// "osw.txt")); // 默认GBK</span></span><br><span class="line"><span class="comment">// OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(</span></span><br><span class="line"><span class="comment">// "osw.txt"), "GBK"); // 指定GBK</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line"><span class="string">"osw.txt"</span>), <span class="string">"UTF-8"</span>); <span class="comment">// 指定UTF-8</span></span><br><span class="line"><span class="comment">// 写数据</span></span><br><span class="line">osw.write(<span class="string">"中国"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">osw.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>其实我们怎么创建一个字符流尼，其实上面的转换流就可以帮我们完成这个需求。但是，每次创建字符流都要先创建一个字节流，感觉很麻烦，所以就有这个流的出现—&gt;FileWriter/FileReaderd，接下来介绍一下具体的代码实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由于我们常见的操作都是使用本地默认编码，所以，不用指定编码。</span></span><br><span class="line"><span class="comment"> * 而转换流的名称有点长，所以，Java就提供了其子类供我们使用。</span></span><br><span class="line"><span class="comment"> * OutputStreamWriter = FileOutputStream + 编码表(GBK)</span></span><br><span class="line"><span class="comment"> * FileWriter = FileOutputStream + 编码表(GBK)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * InputStreamReader = FileInputStream + 编码表(GBK)</span></span><br><span class="line"><span class="comment"> * FileReader = FileInputStream + 编码表(GBK)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> /*</span></span><br><span class="line"><span class="comment"> * 需求：把当前项目目录下的a.txt内容复制到当前项目目录下的b.txt中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数据源：</span></span><br><span class="line"><span class="comment"> * a.txt -- 读取数据 -- 字符转换流 -- InputStreamReader -- FileReader</span></span><br><span class="line"><span class="comment"> * 目的地：</span></span><br><span class="line"><span class="comment"> * b.txt -- 写出数据 -- 字符转换流 -- OutputStreamWriter -- FileWriter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyFileDemo2</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// 封装数据源</span></span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line"><span class="comment">// 封装目的地</span></span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次一个字符</span></span><br><span class="line"><span class="comment">// int ch = 0;</span></span><br><span class="line"><span class="comment">// while ((ch = fr.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">// fw.write(ch);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次一个字符数组</span></span><br><span class="line">char[] chs = <span class="keyword">new</span> char[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fr.read(chs)) != <span class="number">-1</span>) &#123;</span><br><span class="line">fw.write(chs, <span class="number">0</span>, len);</span><br><span class="line">fw.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">fw.close();</span><br><span class="line">fr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是一个简单的字符流的使用方法，实现了一个文件复制的功能。我们在学习字节流的时候，就有缓冲流（BufferInputStream/BufferOutputStream）来实现数据的高速缓冲传送,其实在字符流中也有这个方法。比如（BufferedReader/BufferedWriter），下面就举一个小例子来 看一下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字符缓冲流的特殊方法：</span></span><br><span class="line"><span class="comment"> * BufferedWriter:</span></span><br><span class="line"><span class="comment"> * public void newLine():根据系统来决定换行符</span></span><br><span class="line"><span class="comment"> * BufferedReader:</span></span><br><span class="line"><span class="comment"> * public String readLine()：一次读取一行数据</span></span><br><span class="line"><span class="comment"> * 包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// write();</span></span><br><span class="line">read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> read() throws IOException &#123;</span><br><span class="line"><span class="comment">// 创建字符缓冲输入流对象</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"bw2.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// public String readLine()：一次读取一行数据</span></span><br><span class="line"><span class="comment">// String line = br.readLine();</span></span><br><span class="line"><span class="comment">// System.out.println(line);</span></span><br><span class="line"><span class="comment">// line = br.readLine();</span></span><br><span class="line"><span class="comment">// System.out.println(line);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终版代码</span></span><br><span class="line"><span class="built_in">String</span> line = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> write() throws IOException &#123;</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流对象</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bw2.txt"</span>));</span><br><span class="line"><span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">bw.write(<span class="string">"hello"</span> + x);</span><br><span class="line"><span class="comment">// bw.write("\r\n");</span></span><br><span class="line">bw.newLine();</span><br><span class="line">bw.flush();</span><br><span class="line">&#125;</span><br><span class="line">bw.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>缓冲流的具体实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * BufferedReader</span></span><br><span class="line"><span class="comment"> * 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。</span></span><br><span class="line"><span class="comment"> * 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BufferedReader(Reader in)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 创建字符缓冲输入流对象</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"bw.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="comment">// int ch = 0;</span></span><br><span class="line"><span class="comment">// while ((ch = br.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">// System.out.print((char) ch);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = br.read(chs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.print(<span class="keyword">new</span> String(chs, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字符流为了高效读写，也提供了对应的字符缓冲流。</span></span><br><span class="line"><span class="comment"> * BufferedWriter:字符缓冲输出流</span></span><br><span class="line"><span class="comment"> * BufferedReader:字符缓冲输入流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BufferedWriter:字符缓冲输出流</span></span><br><span class="line"><span class="comment"> * 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。</span></span><br><span class="line"><span class="comment"> * 可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// BufferedWriter(Writer out)</span></span><br><span class="line"><span class="comment">// BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(</span></span><br><span class="line"><span class="comment">// new FileOutputStream("bw.txt")));</span></span><br><span class="line"></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bw.txt"</span>));</span><br><span class="line"></span><br><span class="line">bw.write(<span class="string">"hello"</span>);</span><br><span class="line">bw.write(<span class="string">"world"</span>);</span><br><span class="line">bw.write(<span class="string">"java"</span>);</span><br><span class="line">bw.flush();</span><br><span class="line"></span><br><span class="line">bw.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="IO的常用的流总结"><a href="#IO的常用的流总结" class="headerlink" title="IO的常用的流总结"></a>IO的常用的流总结</h3><p>其实IO简单的字节流和字符流并不难学，总的来说就是太复杂，其实实际操作不是很困难 。现在来总结一下，我们学过的流。</p><pre><code>IO流|--字节流    |--字节输入流        InputStream            int read():一次读取一个字节            int read(byte[] bys):一次读取一个字节数组            |--FileInputStream            |--BufferedInputStream    |--字节输出流        OutputStream            void write(int by):一次写一个字节            void write(byte[] bys,int index,int len):一次写一个字节数组的一部分            |--FileOutputStream            |--BufferedOutputStream|--字符流    |--字符输入流        Reader            int read():一次读取一个字符            int read(char[] chs):一次读取一个字符数组            |--InputStreamReader                |--FileReader            |--BufferedReader                String readLine():一次读取一个字符串    |--字符输出流        Writer            void write(int ch):一次写一个字符            void write(char[] chs,int index,int len):一次写一个字符数组的一部分            |--OutputStreamWriter                |--FileWriter            |--BufferedWriter                void newLine():写一个换行符                void write(String line):一次写一个字符串</code></pre><p>在插入一个图片有助于理解和帮助。</p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-4/49905583.jpg" alt=""></p><p>从图中我们就可以看到清晰的一个思路，各种流及其常用的实现类，在上面都有。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之IO这个硬骨头（一）</title>
    <link href="http://yoursite.com/2018/08/01/Java%E5%9F%BA%E7%A1%80%E4%B9%8BIO%E8%BF%99%E4%B8%AA%E7%A1%AC%E9%AA%A8%E5%A4%B4%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/01/Java基础之IO这个硬骨头（一）/</id>
    <published>2018-08-01T14:37:44.000Z</published>
    <updated>2018-08-01T14:41:17.116Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><h3 id="IO的概述"><a href="#IO的概述" class="headerlink" title="IO的概述"></a>IO的概述</h3><p>首先，我们要了解一下什么是IO，首先IO就是计算机中指Input/Output,也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。<br>流的概念：Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p><h3 id="IO如何学习？"><a href="#IO如何学习？" class="headerlink" title="IO如何学习？"></a>IO如何学习？</h3><h4 id="IO重点的类"><a href="#IO重点的类" class="headerlink" title="IO重点的类"></a>IO重点的类</h4><p>IO的学习我认为最主要的就是五个类和一个接口，把这些学好，基本就没什么问题：<br>File、OutputStream、InputStream、Writer、Reader和接口Serializable。</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td>File</td><td>文件类</td></tr><tr><td>OutputStream</td><td>字节输出流</td></tr><tr><td>InputStream</td><td>字节输入流</td></tr><tr><td>Writer</td><td>字符输流</td></tr><tr><td>Reader</td><td>字符输入流</td></tr></tbody></table><ol><li>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。</li><li>InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</li><li>OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。</li><li>Reader（文件格式操作）：抽象类，基于字符的输入操作。</li><li>Writer（文件格式操作）：抽象类，基于字符的输出操作。</li></ol><p>上面是对这几个类的简单概述基本就是这几个较为重点，当然还有扩展的FileInputStream等等，但是我认为最基础的还是这几个。</p><h4 id="IO的分类"><a href="#IO的分类" class="headerlink" title="IO的分类"></a>IO的分类</h4><p>从上面我们学习了流的概念；一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。<br>下图是一个描述输入流和输出流的类层次图。<br><img src="http://www.runoob.com/wp-content/uploads/2013/12/iostream2xx.png" alt="IO"></p><p>从图中我们可以看到简单的分类是字符流与字节流，接下来我在解释一下：<br>先来说一下输入、输出流：</p><ul><li>输入流：程序从输入流读取数据源。数据源包括外界(键盘、文件、网络…)，即是将数据源读入到程序的通信通道</li></ul><ul><li><p>输出流程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络…）的通信通道。</p><pre><code>采用数据流的目的就是使得输出输入独立于设备。输入流( Input  Stream )不关心数据源来自何种设备（键盘，文件，网络）。  输出流( Output Stream )不关心数据的目的是何种设备（键盘，文件，网络）。</code></pre></li></ul><p>流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：</p><p>1)  字节流：数据流中最小的数据单元是字节<br>2)  字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</p><p><strong>字符流的由来：</strong> Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。<br>所以说：<strong>字符流=字节流+编码表</strong>。这个编码表我们后来再进行讲解。</p><blockquote><p>注意：<br>a.如果没有明确说按照什么区分，默认按照数据类型进行分。<br>b.除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。</p></blockquote><h3 id="InputStream-OutputStream的代码实现"><a href="#InputStream-OutputStream的代码实现" class="headerlink" title="InputStream/OutputStream的代码实现"></a>InputStream/OutputStream的代码实现</h3><blockquote><p>通过上面的分析后我们知道要使用：OutputStream<br> 但是通过查看API，我们发现该流对象是一个抽象类，不能实例化。<br> 所以，我们要找一个具体的子类。<br> 而我们要找的子类是什么名字的呢?这个时候，很简单，我们回想一下，我们是不是要往文件中写东西。<br> 文件是哪个单词——&gt;File<br> 然后用的是字节输出流，联起来就是：FileOutputStream<br>注意：每种基类的子类都是以父类名作为后缀名。<br>          XxxOutputStream<br>          XxxInputStream<br>          XxxReader<br>          XxxWriter</p></blockquote><p>所以我们从FileInputStream和FileOutputStream来演示对字节流的操作。</p><h4 id="FileOutputStream读取数据"><a href="#FileOutputStream读取数据" class="headerlink" title="FileOutputStream读取数据"></a>FileOutputStream读取数据</h4><h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><ol><li>创建字节输入流对象</li><li>调用read()方法</li><li>释放资源<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">          <span class="comment">// 创建字节输出流对象</span></span><br><span class="line">          FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建字节输出流对象了做了几件事情：</span></span><br><span class="line"><span class="comment"> * A:调用系统功能去创建文件</span></span><br><span class="line"><span class="comment"> * B:创建fos对象</span></span><br><span class="line"><span class="comment"> * C:把fos对象指向这个文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">fos.write(<span class="string">"hello,IO"</span>.getBytes());</span><br><span class="line">fos.write(<span class="string">"java"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="comment">//关闭此文件输出流并释放与此流有关的所有系统资源。</span></span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><h5 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h5><p><strong>1. 创建字节输出流对象做了几件事情?</strong></p><pre><code>FileOutputStream(File file)File file = new File(&quot;fos.txt&quot;);FileOutputStream fos = new FileOutputStream(file);FileOutputStream(String name)</code></pre><p>其实先根据文件名称，使用File把这个文件创建出来，然后再把这个文件传入FileOutputStream(file);<br><strong>2. 为什么要关闭资源？</strong><br>释放资源的目的是要让流对象变成垃圾，这样就可以被垃圾回收器回收了，其次是通知系统去释放跟该文件相关的资源<br><strong>3. 如何实现数据换行？</strong><br>为什么现在没有换行呢?因为你值写了字节数据，并没有写入换行符号。<br>如何实现呢?写入换行符号即可呗。<br>刚才我们看到了有写文本文件打开是可以的，通过windows自带的那个不行，为什么呢?<br>因为不同的系统针对不同的换行符号识别是不一样的?</p><blockquote><p>windows:\r\n<br>linux:\n<br>Mac:\r</p></blockquote><p>而一些常见的个高级记事本，是可以识别任意换行符号的。<br>为了使得同一个java程序的换行符在所有的操作系统中都有一样的表现，使用 <strong><em>%n</em></strong>，就可以做到平台无关的换行。</p><p><strong>4. 如何实现数据的追加写入？</strong></p><p>用构造方法带第二个参数是true的情况即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个向具有指定 name 的文件中写入数据的输出文件流。如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处。</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos3.txt"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><p>这样创建就可以实现数据的追加。</p><h4 id="FileInputStream读取数据"><a href="#FileInputStream读取数据" class="headerlink" title="FileInputStream读取数据"></a>FileInputStream读取数据</h4><h5 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h5><ol><li>创建字节输入流对象</li><li>调用read()方法</li><li>释放资源</li></ol><h5 id="代码体现："><a href="#代码体现：" class="headerlink" title="代码体现："></a>代码体现：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//创建FileInputStream</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">      <span class="comment">//read（）方法读取数据</span></span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line">int by = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((by=fis.read())!=<span class="number">-1</span>) &#123;</span><br><span class="line">System.out.print((char)by);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(bys))!=<span class="number">-1</span>) &#123;</span><br><span class="line">System.out.print(<span class="keyword">new</span> <span class="built_in">String</span>(bys,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="复制文本文件"><a href="#复制文本文件" class="headerlink" title="复制文本文件"></a>复制文本文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 复制文本文件。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 数据源：从哪里来</span></span><br><span class="line"><span class="comment"> * a.txt--读取数据--FileInputStream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 目的地：到哪里去</span></span><br><span class="line"><span class="comment"> * b.txt--写数据--FileOutputStream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * java.io.FileNotFoundException: a.txt (系统找不到指定的文件。)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这一次复制中文没有出现任何问题，为什么呢?</span></span><br><span class="line"><span class="comment"> * 上一次我们出现问题的原因在于我们每次获取到一个字节数据，就把该字节数据转换为了字符数据，然后输出到控制台。</span></span><br><span class="line"><span class="comment"> * 而这一次呢?确实通过IO流读取数据，写到文本文件，你读取一个字节，我就写入一个字节，你没有做任何的转换。</span></span><br><span class="line"><span class="comment"> * 它会自己做转换。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyFileDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// 封装数据源</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line"><span class="comment">// 封装目的地</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br><span class="line"></span><br><span class="line">byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(bys)) != <span class="number">-1</span>) &#123;</span><br><span class="line">fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源(建议先关后创建的)</span></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复制图片"><a href="#复制图片" class="headerlink" title="复制图片"></a>复制图片</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：把e:\\林青霞.jpg内容复制到当前项目目录下的mn.jpg中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 数据源：</span></span><br><span class="line"><span class="comment"> * e:\\林青霞.jpg--读取数据--FileInputStream</span></span><br><span class="line"><span class="comment"> * 目的地：</span></span><br><span class="line"><span class="comment"> * mn.jpg--写出数据--FileOutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyImageDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 封装数据源</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"e:\\林青霞.jpg"</span>);</span><br><span class="line"><span class="comment">// 封装目的地</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"mn.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制数据</span></span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思考问题：计算机如何识别中文"><a href="#思考问题：计算机如何识别中文" class="headerlink" title="思考问题：计算机如何识别中文"></a>思考问题：计算机如何识别中文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算机是如何识别什么时候该把两个字节转换为一个中文呢?</span></span><br><span class="line"><span class="comment"> * 在计算机中中文的存储分两个字节：</span></span><br><span class="line"><span class="comment"> * 第一个字节肯定是负数。</span></span><br><span class="line"><span class="comment"> * 第二个字节常见的是负数，可能有正数。但是没影响。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// String s = "abcde";</span></span><br><span class="line"><span class="comment">// // [97, 98, 99, 100, 101]</span></span><br><span class="line"></span><br><span class="line">String s = <span class="string">"我爱你中国"</span>;</span><br><span class="line"><span class="comment">// [-50, -46, -80, -82, -60, -29, -42, -48, -71, -6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bys = s.getBytes();</span><br><span class="line">System.out.println(Arrays.toString(bys));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符缓冲区流"><a href="#字符缓冲区流" class="headerlink" title="字符缓冲区流"></a>字符缓冲区流</h3><p>BufferedOutputStream（字符缓冲输出流）/BufferedInputStream（字符缓冲输入流）<br>构造方法为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。创建一个内部缓冲区数组并将其存储在 buf 中,该buf的大小默认为8192。   </span></span><br><span class="line">public   BufferedInputStream(InputStream <span class="keyword">in</span>); </span><br><span class="line"><span class="comment">//创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。创建一个长度为 size 的内部缓冲区数组并将其存储在 buf 中。   </span></span><br><span class="line">public   BufferedInputStream(InputStream <span class="keyword">in</span>,int size);</span><br></pre></td></tr></table></figure></p><p>BufferedOutputStream的思想进行简单说明：<em>BufferedOutputStream通过字节数组来缓冲数据，当缓冲区满或者用户调用flush()函数时，它就会将缓冲区的数据写入到输出流中。</em><br>话不多说，上代码——–&gt;</p><h4 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：把e:\\哥有老婆.mp4复制到当前项目目录下的copy.mp4中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 字节流四种方式复制文件：</span></span><br><span class="line"><span class="comment"> * 基本字节流一次读写一个字节：共耗时：117235毫秒</span></span><br><span class="line"><span class="comment"> * 基本字节流一次读写一个字节数组： 共耗时：156毫秒</span></span><br><span class="line"><span class="comment"> * 高效字节流一次读写一个字节： 共耗时：1141毫秒</span></span><br><span class="line"><span class="comment"> * 高效字节流一次读写一个字节数组： 共耗时：47毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyMp4Demo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// method1("e:\\哥有老婆.mp4", "copy1.mp4");</span></span><br><span class="line"><span class="comment">// method2("e:\\哥有老婆.mp4", "copy2.mp4");</span></span><br><span class="line"><span class="comment">// method3("e:\\哥有老婆.mp4", "copy3.mp4");</span></span><br><span class="line">method4(<span class="string">"e:\\哥有老婆.mp4"</span>, <span class="string">"copy4.mp4"</span>);</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"共耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效字节流一次读写一个字节数组：</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> method4(<span class="built_in">String</span> srcString, <span class="built_in">String</span> destString)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">srcString));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line"><span class="keyword">new</span> FileOutputStream(destString));</span><br><span class="line"></span><br><span class="line">byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = bis.read(bys)) != <span class="number">-1</span>) &#123;</span><br><span class="line">bos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效字节流一次读写一个字节：</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> method3(<span class="built_in">String</span> srcString, <span class="built_in">String</span> destString)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">srcString));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line"><span class="keyword">new</span> FileOutputStream(destString));</span><br><span class="line"></span><br><span class="line">int by = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((by = bis.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">bos.write(by);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本字节流一次读写一个字节数组</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> method2(<span class="built_in">String</span> srcString, <span class="built_in">String</span> destString)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcString);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destString);</span><br><span class="line"></span><br><span class="line">byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(bys)) != <span class="number">-1</span>) &#123;</span><br><span class="line">fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本字节流一次读写一个字节</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> method1(<span class="built_in">String</span> srcString, <span class="built_in">String</span> destString)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcString);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destString);</span><br><span class="line"></span><br><span class="line">int by = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((by = fis.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">fos.write(by);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出，经过BufferedxxxputStream修饰的字节流，速度快了很多，其实这也是一种设计模式的体现，装饰者设计模式。<br>今天就到这里，明天再来讲解字符流和其他流的知识。谢谢！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>java基础之异常</title>
    <link href="http://yoursite.com/2018/07/31/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2018/07/31/java基础之异常/</id>
    <published>2018-07-31T13:44:51.000Z</published>
    <updated>2018-07-31T13:45:48.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><p>本来今天是准备写一点IO的东西，但是想了一下，想之前先说一下File类，但是File的时候还会出现很多错误，所以先写一篇异常的文章。就从异常开始说吧！</p><h3 id="异常的概述"><a href="#异常的概述" class="headerlink" title="异常的概述"></a>异常的概述</h3><p>异常：异常就是Java程序在运行过程中出现的错误。<br>异常由来：问题也是现实生活中一个具体事务，也可以通过java 的类的形式进行描述，并封装成对象。其实就是Java对不正常情况进行描述后的对象体现。</p><h3 id="异常的体系"><a href="#异常的体系" class="headerlink" title="异常的体系"></a>异常的体系</h3><p>下面是异常的大概分类：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-31/73011655.jpg" alt=""></p><p>我们可以看到Throwable类是 Java 语言中所有错误或异常的超类。下面具体有两个异常类：Error、Exception。</p><pre><code>Error：用于指示合理的应用程序不应该试图捕获的严重问题。（不需要我们处理）Exception：合理的应用程序想要获取的条件。        |---RuntimeException    运行期异常，我们需要修正代码        |---非RuntimeException 编译期异常，必须处理的，否则程序编译不通过 RuntimeException有以下一些例子：        NullPointerException - 空指针引用异常          ClassCastException - 类型强制转换异常。          IllegalArgumentException - 传递非法参数异常。          ArithmeticException - 算术运算异常          IndexOutOfBoundsException - 下标越界异常          NumberFormatException - 数字格式异常          UnsupportedOperationException - 不支持的操作异常</code></pre><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><ol><li>JVM默认的处理<br> 把异常的名称，原因，位置打印在控制台，但是不处理，程序停止，不在执行。</li><li>自己处理<pre><code>1.  try...catch...finally           自己编写处理代码,后面的程序可以继续执行    2.throws        把自己处理不了的，在方法上声明，告诉调用者，这里有问题。</code></pre><h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3></li><li><p>finally用于释放资源（JDBC、流操作），它的代码永远会执行。特殊情况：在执行到finally之前jvm退出。下面的打印是不会执行的，因为JVM已经退出了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;   </span><br><span class="line"><span class="comment">// do something Syst...   </span></span><br><span class="line"> System.exit(<span class="number">1</span>);  </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line"> System.out.println(<span class="string">"Hello,World!"</span>);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>异常处理的变形</p><pre><code>   try...catch...finallytry...catch...try...catch...catch...try...catch...catch...fianllytry...finally</code></pre><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可。<br>这个不是考察的重点，不做多的赘述。</p><h3 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h3></li><li>父类方法有异常抛出，子类方法的重写方法在抛出异常时必须小于等于父类的异常。</li><li>父类的方法没有异常抛出，子类的重写方法不能有异常抛出。</li><li>父类的方法抛出多个异常，子类的重写方法必须必父类少或者小。</li></ol><h3 id="异常的面试题"><a href="#异常的面试题" class="headerlink" title="异常的面试题"></a>异常的面试题</h3><h4 id="编译期异常和运行期异常的区别"><a href="#编译期异常和运行期异常的区别" class="headerlink" title="编译期异常和运行期异常的区别?"></a>编译期异常和运行期异常的区别?</h4><p>答：编译期异常，必须要处理的，否则无法通过编译，程序不能运行。<br>   运行期异常不一定会发生，不一定处理，也可以处理，比如空指针异常，这就不一定会发生。</p><h4 id="throw和throws是的区别？"><a href="#throw和throws是的区别？" class="headerlink" title="throw和throws是的区别？"></a>throw和throws是的区别？</h4><p>答：throw：</p><blockquote><p>在方法体中,后面跟的是异常对象名,并且只能是一个<br>    throw抛出的是一个异常对象，说明这里肯定有一个异常产生了.</p></blockquote><p>throws：</p><blockquote><p>在方法声明上,后面跟的是异常的类名,可以是多个<br>throws是声明方法有异常，是一种可能性，这个异常并不一定会产生.</p></blockquote><h4 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final,finally,finalize的区别?"></a>final,finally,finalize的区别?</h4><p>这个问题我之前做过深入的解析，可以查看我的博文    <a href="https://blog.jh0904.top/2018/07/09/final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">final、finally、finalize的区别</a>    </p><h4 id="如果在catch里面有return-请问finally还执行吗-如果执行-在return前还是后"><a href="#如果在catch里面有return-请问finally还执行吗-如果执行-在return前还是后" class="headerlink" title="如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后"></a>如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后</h4><p>答：会，前。<br>finally和return<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String\[\] args)</span> </span>&#123;  </span><br><span class="line">   System.out.println(getInt());  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">      System.out.println(a / <span class="number">0</span>);  </span><br><span class="line">   a = <span class="number">20</span>;  </span><br><span class="line">   &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;  </span><br><span class="line">      a = <span class="number">30</span>;  </span><br><span class="line"> <span class="keyword">return</span> a;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">      System.out.println (<span class="string">"hello"</span>);  </span><br><span class="line">   <span class="comment">//return a;  </span></span><br><span class="line">   &#125;  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行结果</p><pre><code>hello30</code></pre><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>这个是JDK1.7新加入的一个异常的新特性。<br>try-with-resources语句是一个声明一个或多个资源的try语句。一个资源作为一个对象，必须在程序结束之后关闭。try-with-resources语句确保在语句的最后每个资源都被关闭，任何实现了java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resource来实现异常处理和关闭资源。<br>具体使用见下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;  </span><br><span class="line"> <span class="keyword">return</span> br.readLine();  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>把需要关闭的对象写在括号中，其中要关闭的对象必须实现java.lang.AutoCloseable和java.io.Closeable。</p><h3 id="finally和return这些事"><a href="#finally和return这些事" class="headerlink" title="finally和return这些事"></a>finally和return这些事</h3><h4 id="在finally中return数值？"><a href="#在finally中return数值？" class="headerlink" title="在finally中return数值？"></a>在finally中return数值？</h4><p>在finally中return数值，最后的返回值是finally中的值。可以参考代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String\[\] args)</span> </span>&#123;  </span><br><span class="line">      System.out.println(getInt());  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">         System.out.println(a / <span class="number">0</span>);  </span><br><span class="line">   a = <span class="number">20</span>;  </span><br><span class="line">   &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;  </span><br><span class="line">         a = <span class="number">30</span>;  </span><br><span class="line"> <span class="keyword">return</span> a;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">         a=<span class="number">40</span>;</span><br><span class="line">         <span class="keyword">return</span> a;  </span><br><span class="line">   &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的运行结果是40,并且其中有提示说：</p><pre><code>不能在finally块中使用return，finally块中的return返回后方法结束执行，不会再执行try块中的return语句。 Negative example:    public static Long readFileLength(String fileName) {        try {            File file = new File(fileName);            RandomAccessFile randomAccessFile = new RandomAccessFile(file, &quot;r&quot;);            return randomAccessFile.length();        } catch (Exception e) {            logger.error(e.getMessage(), e);        } finally {            countDownLatch.countDown();            return 0L;        }    }</code></pre><h4 id="catch捕获异常时，finally改变返回值"><a href="#catch捕获异常时，finally改变返回值" class="headerlink" title="catch捕获异常时，finally改变返回值"></a>catch捕获异常时，finally改变返回值</h4><p>我们可以从上面看出来，当finally块中有return语句时，将会覆盖函数中其他的return语句。</p><blockquote><p>此外，由于一个方法内部定义的变量都存储子在栈中，当这个函数结束后，其对应的栈就被回收，此时方法中的变量就不存在了。因此return在返回时不是直接返回变量的值，而是复制一份，然后返回。<br>因此，对于基本数据类型的数据，在finally块中改变return的值，不会有影响，对于引用数据类型会有影响。</p></blockquote><p>可以参考下面代码理解<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package Exception;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> \* Exception * \* @author jh  </span></span><br><span class="line"><span class="comment"> \* @date 2018/7/31 20:26  </span></span><br><span class="line"><span class="comment"> \* description: */</span>public <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;  </span><br><span class="line">   public <span class="keyword">static</span> int testFinally1()&#123;  </span><br><span class="line">      int result=<span class="number">1</span>;  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">         result=<span class="number">2</span>;  </span><br><span class="line"> <span class="keyword">return</span> result;  </span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">         result=<span class="number">3</span>;  </span><br><span class="line">   System.out.println (<span class="string">"testFinally1"</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   public <span class="keyword">static</span> StringBuffer testFinally2()&#123;  </span><br><span class="line">      StringBuffer s=<span class="keyword">new</span> StringBuffer (<span class="string">"hello"</span>);  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> s;  </span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">         s.append (<span class="string">"world"</span>);  </span><br><span class="line">   System.out.println (<span class="string">"testFinally2"</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>\[\] args) &#123;  </span><br><span class="line">      int i = testFinally1 ();  </span><br><span class="line">   System.out.println (i);  </span><br><span class="line">   StringBuffer finally2 = testFinally2 ();  </span><br><span class="line">   System.out.println (finally2);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码我们可以看出程序在执行return时会首先将返回值存储在一个指定的位置，其次去执行finally块，最后再返回。在方法testFinally1中调用return前，先把return的值存储在一个指定的位置，然后再去执行finally块中的代码，此时修改result的值不会影响程序的返回结果。<br>testFinally2中，在调用return之前把s保存在一个指定的位置，但是因为s为引用类型，因此在finally块中修改s的值会发生变化。会影响程序的返回结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机（一）</title>
    <link href="http://yoursite.com/2018/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/28/深入理解java虚拟机（一）/</id>
    <published>2018-07-28T04:14:26.000Z</published>
    <updated>2018-07-28T04:21:20.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>今天主要学习了《深入理解java虚拟机》的前两章节，第一章主要讲解了java语法的一些特性，及java发展的历史，还有java虚拟机的一些知识。<br>第二章主要讲了java内存区域与内存溢出异常。主要的内容我都总结了思维导图，如果需要导图，可以从百度云下载<a href="https://pan.baidu.com/s/1esP5YDPv_5UZ_neUvGo2BQ" target="_blank" rel="noopener">java虚拟机导图</a>  ，密码是0n73</p><p>好了，废话不说，直接上图。有不正确的地方，欢迎大家指正。</p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-28/92420488.jpg" alt="java"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天主要学习了《深入理解java虚拟机》的前两章节，第一章主要讲解了java语法的一些特性，及java发展的历史，还有java虚
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>阶段性总结</title>
    <link href="http://yoursite.com/2018/07/24/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/07/24/阶段性总结/</id>
    <published>2018-07-24T15:44:43.000Z</published>
    <updated>2018-07-24T15:45:42.276Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="实训总结"><a href="#实训总结" class="headerlink" title="实训总结"></a>实训总结</h3><p>今天是实训结束，实训期间主要还是自己状态不是很好，主要学习了Mybatis和Spring MVC的一些东西。其次实训单位让做一个简单的项目。我们小组做了一个简单的易买网项目.具体项目我已经上传到服务器，大家可以去访问。链接放在这里：<a href="http://www.jh0904.top/MStorage" target="_blank" rel="noopener">易买网</a>。时间短，任务比较重，所以就大概这个样子啦，其中还有很多缺陷，还要继续完善，希望大家指正。</p><h3 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h3><p>现在在学校东门租了房子，准备利用这个时间，好好的去复习一下之前的知识，并且去加深印象。去备战9月的秋招。<br>大概学习计划如下：</p><h4 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h4><ul><li>反射的总结、集合的总结、IO的总结、NIO的总结。（博客）</li><li>对于基础部分，还有笔试题的任务，每天规定做20-30道牛客的题目。编程题1道。（习题）</li><li>每日的博客（主要是面试题）</li><li>其次，还有对高并发的学习。java8的了解，java9暂时不考虑。</li><li>还有对java虚拟机的学习。</li><li>对之前几本武林秘籍的复习。</li></ul><h4 id="框架和web开发"><a href="#框架和web开发" class="headerlink" title="框架和web开发"></a>框架和web开发</h4><ul><li>学习《web开发指南》了解web开发的基本业务逻辑。</li><li>首先前段时间学习了Mybatis和Spring MVC,但是基础不牢靠，需要总结。（博客）</li><li>学习SSM的整合项目，并且根据尚硅谷的视频搭载一个简单的项目。</li><li>复习Spring的开发，复习方法有：1.学习spring的注解开发（视频）2.阅读spring实战（书籍）<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4></li><li>复习数据库的知识，简单的操作，并且还有高级的开发（索引的一些东西）</li><li>学习NoSQL数据库（Redis），主要以视频为主，书籍为辅导资料。</li><li>练习简单的sql语句练习题（牛客网）</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>熟悉简单的排序方法，了解基本思想，每周写一遍。</li><li>练习编程题，每日一道。</li><li>学习java视频（主要是简单的算法和letcood的视频）</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>以上是我对假期的一些安排和期望，希望我能在接下来的一个月中，砥砺前行，不忘初心。加油！！！</p><p>我对我的寄语：</p><h1 id="加油，相信自己。想要改变世界，先改变自己。"><a href="#加油，相信自己。想要改变世界，先改变自己。" class="headerlink" title=" 加油，相信自己。想要改变世界，先改变自己。 "></a><font style="color:red"> 加油，相信自己。想要改变世界，先改变自己。 </font></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实训总结&quot;&gt;&lt;a href=&quot;#实训总结&quot; class=&quot;headerlink&quot; title=&quot;实训总结&quot;&gt;&lt;/a&gt;实
      
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="自我总结" scheme="http://yoursite.com/tags/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93/"/>
    
      <category term="学习计划" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>纪念一次json解析错误！！！</title>
    <link href="http://yoursite.com/2018/07/23/%E7%BA%AA%E5%BF%B5%E4%B8%80%E6%AC%A1json%E8%A7%A3%E6%9E%90%E9%94%99%E8%AF%AF%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://yoursite.com/2018/07/23/纪念一次json解析错误！！！/</id>
    <published>2018-07-23T14:38:38.000Z</published>
    <updated>2018-07-23T14:41:09.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>今天做了一个简单的ssm项目，在用spring mvc解析json数据时，网页一直返回数据显示406错误。对于这个错误，头疼了一天。首先介绍一下我的小项目。</p><h3 id="项目代码与思路"><a href="#项目代码与思路" class="headerlink" title="项目代码与思路"></a>项目代码与思路</h3><p>首先先创建一个jsp页面，json数据的传输有两种：</p><ul><li>一、请求json，输出是json </li><li>二、请求key/value，输出是json</li></ul><p>接下来首先分析一下请求json返回也是json的形式（第二种不做简述，照猫画虎，思想一致，只提供代码）<br>使用jquery的ajax提交json串，对输出的json结果进行解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        //请求json，输出是json</span><br><span class="line">        function requestJson() &#123;</span><br><span class="line">            alert(&quot;requestJson&quot;);</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type: &apos;post&apos;,</span><br><span class="line">                url: &apos;$&#123;pageContext.request.contextPath &#125;/requestJson&apos;,</span><br><span class="line">                contentType: &apos;application/json;charset=utf-8&apos;,</span><br><span class="line">                //数据格式是json串,商品信息</span><br><span class="line">                data: &apos;&#123;&quot;name&quot;:&quot;手机&quot;,&quot;price&quot;:999&#125;&apos;,</span><br><span class="line">                success: function (data) &#123;//返回json结果</span><br><span class="line">                    alert(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;input type=&quot;button&quot; onclick=&quot;requestJson()&quot; value=&quot;请求json，输出是json&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>然后在controller中写一个JsonTest类存储方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.how2java.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.ItemsCustom;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JsonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求json串(商品信息)，输出json(商品信息)</span></span><br><span class="line"><span class="comment">//@RequestBody将请求的商品信息的json串转成itemsCustom对象</span></span><br><span class="line"><span class="comment">//@ResponseBody将itemsCustom转成json输出</span></span><br><span class="line">@RequestMapping(<span class="string">"/requestJson"</span>)</span><br><span class="line">public @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom)&#123;</span><br><span class="line"><span class="comment">//@ResponseBody将itemsCustom转成json输出</span></span><br><span class="line"><span class="keyword">return</span> itemsCustom;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个代码的意思就是从jsp发送到controller中，然后其中的@RequestBody标明传输json数据，最后在返回数据到页面上。</p><h3 id="错误问题"><a href="#错误问题" class="headerlink" title="错误问题"></a>错误问题</h3><p>在写完上述代码之后，出现了网页无法解析json数据的状况，检查头文件发现后端传数据过来到前端了，但是显示406错误。总共出现了两个问题：</p><h4 id="问题一：jar问题"><a href="#问题一：jar问题" class="headerlink" title="问题一：jar问题"></a>问题一：jar问题</h4><p>导入的jar包不正确，之前一直使用的是1.9.2版本的下面三个jar包，在网上查询了之后发现，spring3.* 支持1.9.2 ,在spring4.0之后已经不支持了，所以把jar全部更新到2.4.1的jar包。我使用的是maven工程，具体的依赖可以看下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">             &lt;!--jackson--&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;jackson-core&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;jackson-annotations&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;jackson-databind&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-23/91348004.jpg" alt=""></p><h4 id="问题二：spring-MVC-xml配置文件出现问题"><a href="#问题二：spring-MVC-xml配置文件出现问题" class="headerlink" title="问题二：spring MVC.xml配置文件出现问题"></a>问题二：spring MVC.xml配置文件出现问题</h4><p>在需要解析json1的时候需要在spring MVC.xml添加如下配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 避免IE执行AJAX时,返回<span class="built_in">JSON</span>出现下载文件 --&gt;</span><br><span class="line">   &lt;bean id=<span class="string">"mappingJacksonHttpMessageConverter"</span></span><br><span class="line">         <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"supportedMediaTypes"</span>&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">               &lt;value&gt;text/html;charset=UTF<span class="number">-8</span>&lt;<span class="regexp">/value&gt;</span></span><br><span class="line"><span class="regexp">           &lt;/</span>list&gt;</span><br><span class="line">       &lt;<span class="regexp">/property&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 启动Spring MVC的注解功能，完成请求和注解POJO的映射 --&gt;</span><br><span class="line">   &lt;bean</span><br><span class="line">           <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"messageConverters"</span>&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">               &lt;ref bean=<span class="string">"mappingJacksonHttpMessageConverter"</span> /&gt;&lt;!-- json转换器 --&gt;</span><br><span class="line">           &lt;/list&gt;</span><br><span class="line">       &lt;<span class="regexp">/property&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>bean&gt;</span><br></pre></td></tr></table></figure></p><p>但是加入之后依然报错，显示无法加载<font style="color : red">org.springframework.http.converter.json.MappingJacksonHttpMessageConverter</font></p><p>网上查询之后发现，在导入jackson2.0版本以上的时候，其中的配置文件已经更换了<br>更换为</p><blockquote><p>org.springframework.http.converter.json.MappingJackson2HttpMessageConverter</p></blockquote><p>配置完成之后，重新启动项目，发现项目没有问题了，成功运行。<br>这次再配置的过程中浪费太多时间，为了避免下次还是出现此类问题，故此写了这篇文章，以便以后查阅和修改代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天做了一个简单的ssm项目，在用spring mvc解析json数据时，网页一直返回数据显示406错误。对于这个错误，头疼了一
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
      <category term="java项目" scheme="http://yoursite.com/tags/java%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>java提供了那些IO方式？NIO如何实现多路复用？</title>
    <link href="http://yoursite.com/2018/07/21/java%E6%8F%90%E4%BE%9B%E4%BA%86%E9%82%A3%E4%BA%9BIO%E6%96%B9%E5%BC%8F%EF%BC%9FNIO%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/21/java提供了那些IO方式？NIO如何实现多路复用？/</id>
    <published>2018-07-21T00:57:55.000Z</published>
    <updated>2018-07-21T00:58:30.708Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。</p><p>首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p><p>java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p><p>很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p><p>第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p><p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>上面所列出的回答是一种常见的分类方式，即所谓的BIO、NIO、AIO。</p><p>主要考察的点有：</p><ul><li>基础的API设计与功能<br>InputStream/OutputStream和Reader/Writer的区别和使用。</li><li>NIO、NIO2的基本组成。</li><li>不同场景下，分析BIO和NIO的设计和实现原理。</li><li>NIO提供高性能的原理</li><li><p>NIO还存在那些问题？改进的想法？</p><h3 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4></li><li>区分同步或异步（synchronous/asynchronous）<blockquote><p>所谓同步是指一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成，这是一个可靠的任务序列。要成功都成功，要失败都失败，两个任务的状态可以保持一致。<br>异步不需要等待依赖的任务完成。只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了，至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p></blockquote></li><li>区分阻塞与非阻塞（blocking/non-blocking）<blockquote><p>在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</p></blockquote></li></ul><p>对于IO，做一下总结：</p><ul><li>IO不仅仅是对文件的操作，在网络编程中，比如socket通信，都是典型的IO操作目标。</li><li>输入流、输出流（InputStream/OutputStream）适用于读取或者写入字节，例如图片操作文件。</li><li>Reader/Writer则是用于操作字符的，增加字符编解码的功能，适用于从文件中读取或者写入文本信息2，本质上计算机操作的都是字节，不管是从网络通信还是文件读取，Reader/Writer相当于构建了应用逻辑与原始数据之间的桥梁。</li><li>BufferedOutputStream等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。</li><li>参考下面这张类图，很多 IO工具类都实现了 Closeable接口，因为需要进行资源的释放。比如，打开 FileInputStream，它就会获取相应的文件描述符（ FileDescriptor），需要利用 try- with- resources、 try- finally等机制保证 FileInputStream被明确关闭，进而相应文件描述符也会失效，否则将导致资源无法被释放。利用专栏前面的内容提到的 Cleaner或 finalize机制作为资源释放的最后把关，也是必要的。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-21/67006062.jpg" alt=""></li></ul><h4 id="NIO的概览"><a href="#NIO的概览" class="headerlink" title="NIO的概览"></a>NIO的概览</h4><ol><li>首先了解一下NIO的基本组成部分：</li></ol><ul><li><p>Chnnel</p><blockquote><p>由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。<br>Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。<br>类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。<br>File 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过 Socket 获取 Channel，反之亦然。</p></blockquote></li><li><p>Buffer</p><blockquote><p>一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p></blockquote></li><li>Selector<blockquote><p>是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在 Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理。<br>Selector 同样是基于底层操作系统机制，不同模式、不同版本都存在区别，例如，在最新的代码库里，相关实现如下：<br>在Linux中依赖于epoll<br>在Windows中依赖于iocp模型</p></blockquote></li><li>Chartset<blockquote><p>提供 Unicode 字符串定义，NIO 也提供了相应的编解码器等，例如，通过下面的方式进行字符串到 ByteBuffer 的转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharSet.defaultCharSet().encode(<span class="string">"Hello,World"</span>)</span><br></pre></td></tr></table></figure></blockquote></li></ul><ol start="2"><li>NIO的具体作用</li></ol><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>对比HashMap、HashTable、TreeMap之间的区别</title>
    <link href="http://yoursite.com/2018/07/18/%E5%AF%B9%E6%AF%94HashMap%E3%80%81HashTable%E3%80%81TreeMap%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/07/18/对比HashMap、HashTable、TreeMap之间的区别/</id>
    <published>2018-07-18T13:41:46.000Z</published>
    <updated>2018-07-18T13:42:57.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。</p><p>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</p><p>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</p><p>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>我感觉这三个Map中最重要的肯定是HashMap，首先看一下我之前的文章了解一下：<a href="https://blog.jh0904.top/2018/06/08/hashmap/" target="_blank" rel="noopener">HashMap的源码解析</a>，我认为学习集合框架，首先要了解基本的操作用法，这个应该去读API。其次，应当去学习源码，去了解怎么实现的具体代码。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-18/32923831.jpg" alt=""></p><p>对于三者的区别，我主要从三方面来说：</p><h4 id="1-语法上面的区别："><a href="#1-语法上面的区别：" class="headerlink" title="1.语法上面的区别："></a>1.语法上面的区别：</h4><p>1）HashMap允许键值为空，Hashtable不允许。</p><p>2）HashMap包含了containsvalue和containsKey，不包含有contains。</p><h4 id="2-安全方面的区别"><a href="#2-安全方面的区别" class="headerlink" title="2.安全方面的区别"></a>2.安全方面的区别</h4><p>HashTable支持线程安全的，而HashMap不支持线程同步，是非线程安全的。因此，HashMap相对来说效率可能会高于Hashtable。</p><h4 id="3-源码级别的区别"><a href="#3-源码级别的区别" class="headerlink" title="3.源码级别的区别"></a>3.源码级别的区别</h4><p>Hashtable，hash数组默认的大小是11，增加的方式是old*2+1,而HashMap中，hash数组的默认大小是16，而且一定是2的指数。</p><p>相较于HashMap和HashTable，TreeMap是利用红黑树来实现的，实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap来进行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多线程（二）</title>
    <link href="http://yoursite.com/2018/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/17/多线程（二）/</id>
    <published>2018-07-17T14:30:53.000Z</published>
    <updated>2018-07-17T14:31:26.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>这是多线程的第二篇文章，主要介绍一写java多线程的简单锁机制和死锁、线程池等一些概念，多线程的高级部分过一段时间加上。</p><h3 id="1-JDK5以后的针对线程的锁定操作和释放操作"><a href="#1-JDK5以后的针对线程的锁定操作和释放操作" class="headerlink" title="(1)JDK5以后的针对线程的锁定操作和释放操作"></a>(1)JDK5以后的针对线程的锁定操作和释放操作</h3><p>之前的同步方法，我们学习了简单的synchronized同步代码块，还有用synchronized修饰方法，形成同步方法。还有静态同步方法。<br>现在我们要了解简单的锁机制。<br>Lock锁是JDK5之后加入的，为了更清晰的表达如何加锁和释放锁。具体的使用方法参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义锁对象</span></span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的Main方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，</span></span><br><span class="line"><span class="comment"> * 为了更清晰的表达如何加锁和释放锁,JDK5以后提供了一个新的锁对象Lock。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Lock：</span></span><br><span class="line"><span class="comment"> * void lock()： 获取锁。</span></span><br><span class="line"><span class="comment"> * void unlock():释放锁。  </span></span><br><span class="line"><span class="comment"> * ReentrantLock是Lock的实现类.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个窗口</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>Lock的主要方法还是<br>Lock<br>    &nbsp;&nbsp;&nbsp;&nbsp;  void lock()<br>    &nbsp;&nbsp;&nbsp;&nbsp;  void unlock()<br>   &nbsp;&nbsp;&nbsp;&nbsp; <font style="color:red"> ReentrantLock</font></p></blockquote><h3 id="死锁问题的描述和代码体现"><a href="#死锁问题的描述和代码体现" class="headerlink" title="死锁问题的描述和代码体现"></a>死锁问题的描述和代码体现</h3><p>死锁问题是java中一个比较重要的问题。一般面试经常会问，这个需要牢记。</p><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><blockquote><p>我们先看看这样一个生活中的例子：在一条河上有一座桥，桥面较窄，只能容纳一辆汽车通过，无法让两辆汽车并行。如果有两辆汽车A和B分别由桥的两端驶上该桥，则对于A车来说，它走过桥面左面的一段路（即占有了桥的一部分资源），要想过桥还须等待B车让出右边的桥面，此时A车不能前进；对于B车来说，它走过桥面右边的一段路（即占有了桥的一部分资源），要想过桥还须等待A车让出左边的桥面，此时B车也不能前进。两边的车都不倒车，结果造成互相等待对方让出桥面，但是谁也不让路，就会无休止地等下去。这种现象就是死锁。如果把汽车比做进程，桥面作为资源，那麽上述问题就描述为：进程A占有资源R1，等待进程B占有的资源Rr；进程B占有资源Rr，等待进程A占有的资源R1。而且资源R1和Rr只允许一个进程占用，即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。  </p></blockquote><h4 id="死锁的原因"><a href="#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h4><p>主要有以下四个必要条件。总的来说死锁的原因还是资源的相互占有，无法释放。</p><blockquote><ol><li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li><li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，⋯⋯，Pn正在等待已被P0占用的资源。即肯定存在相互等待的死循环。</li></ol></blockquote><h4 id="死锁的代码"><a href="#死锁的代码" class="headerlink" title="死锁的代码"></a>死锁的代码</h4><p>DieLock的实现（zhonmgdi）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_02;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DieLock</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">private boolean flag;</span><br><span class="line"></span><br><span class="line">public DieLock(boolean flag) &#123;</span><br><span class="line"><span class="keyword">this</span>.flag = flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">synchronized (MyLock.objA) &#123;</span><br><span class="line">System.out.println(<span class="string">"if objA"</span>);</span><br><span class="line">synchronized (MyLock.objB) &#123;</span><br><span class="line">System.out.println(<span class="string">"if objB"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">synchronized (MyLock.objB) &#123;</span><br><span class="line">System.out.println(<span class="string">"else objB"</span>);</span><br><span class="line">synchronized (MyLock.objA) &#123;</span><br><span class="line">System.out.println(<span class="string">"else objA"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MyLock—-&gt;创建锁对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_02;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建两把锁对象</span></span><br><span class="line">public <span class="keyword">static</span> final <span class="built_in">Object</span> objA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">public <span class="keyword">static</span> final <span class="built_in">Object</span> objB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Demo类，开启线程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 同步的弊端：</span></span><br><span class="line"><span class="comment"> * A:效率低</span></span><br><span class="line"><span class="comment"> * B:容易产生死锁</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 死锁：</span></span><br><span class="line"><span class="comment"> * 两个或两个以上的线程在争夺资源的过程中，发生的一种相互等待的现象。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 举例：</span></span><br><span class="line"><span class="comment"> * 中国人，美国人吃饭案例。</span></span><br><span class="line"><span class="comment"> * 正常情况：</span></span><br><span class="line"><span class="comment"> * 中国人:筷子两支</span></span><br><span class="line"><span class="comment"> * 美国人:刀和叉</span></span><br><span class="line"><span class="comment"> * 现在：</span></span><br><span class="line"><span class="comment"> * 中国人：筷子1支，刀一把</span></span><br><span class="line"><span class="comment"> * 美国人：筷子1支，叉一把</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DieLockDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">DieLock dl1 = <span class="keyword">new</span> DieLock(<span class="literal">true</span>);</span><br><span class="line">DieLock dl2 = <span class="keyword">new</span> DieLock(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">dl1.start();</span><br><span class="line">dl2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="生产者和消费者多线程体现-线程间通信问题"><a href="#生产者和消费者多线程体现-线程间通信问题" class="headerlink" title="生产者和消费者多线程体现(线程间通信问题)"></a>生产者和消费者多线程体现(线程间通信问题)</h3><p>具体的生产者消费者的模式如下图：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-17/63313147.jpg" alt=""><br>以学生作为资源来实现的</p><pre><code>资源类：Student设置数据类：SetThread(生产者)获取数据类：GetThread(消费者)测试类：StudentDemo</code></pre><p><img src="https://images2015.cnblogs.com/blog/868641/201703/868641-20170303152707641-1755807475.png" alt=""><br>上图就是对生产者消费者的解释。<br>具体的代码实现：<br>Student<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="built_in">String</span> name;</span><br><span class="line">int age;</span><br><span class="line">boolean flag; <span class="comment">// 默认情况是没有数据，如果是true，说明有数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SetThread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SetThread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">private Student s;</span><br><span class="line">private int x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">public SetThread(Student s) &#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">synchronized (s) &#123;</span><br><span class="line"><span class="comment">//判断有没有</span></span><br><span class="line"><span class="keyword">if</span>(s.flag)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.wait(); <span class="comment">//t1等着，释放锁</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">s.name = <span class="string">"林青霞"</span>;</span><br><span class="line">s.age = <span class="number">27</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s.name = <span class="string">"刘意"</span>;</span><br><span class="line">s.age = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line">x++; <span class="comment">//x=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改标记</span></span><br><span class="line">s.flag = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//唤醒线程</span></span><br><span class="line">s.notify(); <span class="comment">//唤醒t2,唤醒并不表示你立马可以执行，必须还得抢CPU的执行权。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//t1有，或者t2有</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetThread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">private Student s;</span><br><span class="line"></span><br><span class="line">public GetThread(Student s) &#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">synchronized (s) &#123;</span><br><span class="line"><span class="keyword">if</span>(!s.flag)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.wait(); <span class="comment">//t2就等待了。立即释放锁。将来醒过来的时候，是从这里醒过来的时候</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(s.name + <span class="string">"---"</span> + s.age);</span><br><span class="line"><span class="comment">//林青霞---27</span></span><br><span class="line"><span class="comment">//刘意---30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改标记</span></span><br><span class="line">s.flag = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//唤醒线程</span></span><br><span class="line">s.notify(); <span class="comment">//唤醒t1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StudentDemo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> * 资源类：Student</span></span><br><span class="line"><span class="comment"> * 设置学生数据:SetThread(生产者)</span></span><br><span class="line"><span class="comment"> * 获取学生数据：GetThread(消费者)</span></span><br><span class="line"><span class="comment"> * 测试类:StudentDemo</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题1：按照思路写代码，发现数据每次都是:null---0</span></span><br><span class="line"><span class="comment"> * 原因：我们在每个线程中都创建了新的资源,而我们要求的时候设置和获取线程的资源应该是同一个</span></span><br><span class="line"><span class="comment"> * 如何实现呢?</span></span><br><span class="line"><span class="comment"> * 在外界把这个数据创建出来，通过构造方法传递给其他的类。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题2：为了数据的效果好一些，我加入了循环和判断，给出不同的值,这个时候产生了新的问题</span></span><br><span class="line"><span class="comment"> * A:同一个数据出现多次</span></span><br><span class="line"><span class="comment"> * B:姓名和年龄不匹配</span></span><br><span class="line"><span class="comment"> * 原因：</span></span><br><span class="line"><span class="comment"> * A:同一个数据出现多次</span></span><br><span class="line"><span class="comment"> * CPU的一点点时间片的执行权，就足够你执行很多次。</span></span><br><span class="line"><span class="comment"> * B:姓名和年龄不匹配</span></span><br><span class="line"><span class="comment"> * 线程运行的随机性</span></span><br><span class="line"><span class="comment"> * 线程安全问题：</span></span><br><span class="line"><span class="comment"> * A:是否是多线程环境是</span></span><br><span class="line"><span class="comment"> * B:是否有共享数据是</span></span><br><span class="line"><span class="comment"> * C:是否有多条语句操作共享数据是</span></span><br><span class="line"><span class="comment"> * 解决方案：</span></span><br><span class="line"><span class="comment"> * 加锁。</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * A:不同种类的线程都要加锁。</span></span><br><span class="line"><span class="comment"> * B:不同种类的线程加的锁必须是同一把。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题3:虽然数据安全了，但是呢，一次一大片不好看，我就想依次的一次一个输出。</span></span><br><span class="line"><span class="comment"> * 如何实现呢?</span></span><br><span class="line"><span class="comment"> * 通过Java提供的等待唤醒机制解决。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 等待唤醒：</span></span><br><span class="line"><span class="comment"> * Object类中提供了三个方法：</span></span><br><span class="line"><span class="comment"> * wait():等待</span></span><br><span class="line"><span class="comment"> * notify():唤醒单个线程</span></span><br><span class="line"><span class="comment"> * notifyAll():唤醒所有线程</span></span><br><span class="line"><span class="comment"> * 为什么这些方法不定义在Thread类中呢?</span></span><br><span class="line"><span class="comment"> * 这些方法的调用必须通过锁对象调用，而我们刚才使用的锁对象是任意锁对象。</span></span><br><span class="line"><span class="comment"> * 所以，这些方法必须定义在Object类中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">//创建资源</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取的类</span></span><br><span class="line">SetThread st = <span class="keyword">new</span> SetThread(s);</span><br><span class="line">GetThread gt = <span class="keyword">new</span> GetThread(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程类</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(gt);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是具体的实现方法和操作，其中的注释可以参考着观看，有助于理解程序代码。</p><h3 id="线程的转化状态"><a href="#线程的转化状态" class="headerlink" title="线程的转化状态"></a>线程的转化状态</h3><p>主要参考下图<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-17/99854255.jpg" alt=""></p><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>线程组（ThreadGroup）就是由线程组成的管理线程的类，这个类是java.lang.ThreadGroup类。</p><blockquote><p>在Java中每一个线程都归属于某个线程组管理的一员，例如在主函数main()主工作流程中产生一个线程，则产生的线程属于main这个线程组管理的一员。<br>定义一个线程组，通过以下代码可以实现。<br>ThreadGroup group=new ThreadGroup(“group”);<br>Thread thread=new Thread(group,”the first thread of group”);<br>具体的java例子代码可以见下：</p></blockquote><p>MyRunnable—–&gt;实现线程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_06;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadGroupDemo—–&gt;首先先构建一个线程组，然后在线程构造的时候指定线程组，设置好线程可以通过tg.getThreadGroup().getName()获取当前的线程组名称。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_06;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程组： 把多个线程组合到一起。</span></span><br><span class="line"><span class="comment"> * 它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// method1();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们如何修改线程所在的组呢?</span></span><br><span class="line"><span class="comment">// 创建一个线程组</span></span><br><span class="line"><span class="comment">// 创建其他线程的时候，把其他线程的组指定为我们自己新建线程组</span></span><br><span class="line">method2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// t1.start();</span></span><br><span class="line"><span class="comment">// t2.start();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> method2() &#123;</span><br><span class="line"><span class="comment">// ThreadGroup(String name)</span></span><br><span class="line">ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">"这是一个新的组"</span>);</span><br><span class="line"></span><br><span class="line">MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"><span class="comment">// Thread(ThreadGroup group, Runnable target, String name)</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(tg, my, <span class="string">"林青霞"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(tg, my, <span class="string">"刘意"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(t1.getThreadGroup().getName());</span><br><span class="line">System.out.println(t2.getThreadGroup().getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过组名称设置后台线程，表示该组的线程都是后台线程</span></span><br><span class="line">tg.setDaemon(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> method1() &#123;</span><br><span class="line">MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(my, <span class="string">"林青霞"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(my, <span class="string">"刘意"</span>);</span><br><span class="line"><span class="comment">// 我不知道他们属于那个线程组,我想知道，怎么办</span></span><br><span class="line"><span class="comment">// 线程类里面的方法：public final ThreadGroup getThreadGroup()</span></span><br><span class="line">ThreadGroup tg1 = t1.getThreadGroup();</span><br><span class="line">ThreadGroup tg2 = t2.getThreadGroup();</span><br><span class="line"><span class="comment">// 线程组里面的方法：public final String getName()</span></span><br><span class="line"><span class="built_in">String</span> name1 = tg1.getName();</span><br><span class="line"><span class="built_in">String</span> name2 = tg2.getName();</span><br><span class="line">System.out.println(name1);</span><br><span class="line">System.out.println(name2);</span><br><span class="line"><span class="comment">// 通过结果我们知道了：线程默认情况下属于main线程组</span></span><br><span class="line"><span class="comment">// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组</span></span><br><span class="line">System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。</p><h4 id="线程池的实现方法"><a href="#线程池的实现方法" class="headerlink" title="线程池的实现方法"></a>线程池的实现方法</h4><blockquote><p>线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。<br>在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池</p></blockquote><h5 id="线程池具体方法"><a href="#线程池具体方法" class="headerlink" title="线程池具体方法"></a>线程池具体方法</h5><p>JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法</p><pre><code>public static ExecutorService newCachedThreadPool()创建一个具有缓存功能的线程池缓存：百度浏览过的信息再次访问public static ExecutorService newFixedThreadPool(int nThreads)创建一个可重用的，具有固定线程数的线程池public static ExecutorService newSingleThreadExecutor()创建一个只有单线程的线程池，相当于上个方法的参数是1    </code></pre><p>这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法</p><pre><code>Future&lt;?&gt; submit(Runnable task)&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></pre><h5 id="线程池的代码实现"><a href="#线程池的代码实现" class="headerlink" title="线程池的代码实现"></a>线程池的代码实现</h5><p>MyRunnable接口实现线程。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ExecutorsDemo<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程池的好处：线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如何实现线程的代码呢?</span></span><br><span class="line"><span class="comment"> * A:创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line"><span class="comment"> * public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment"> * B:这种线程池的线程可以执行：</span></span><br><span class="line"><span class="comment"> * 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line"><span class="comment"> * 做一个类实现Runnable接口。</span></span><br><span class="line"><span class="comment"> * C:调用如下方法即可</span></span><br><span class="line"><span class="comment"> * Future&lt;?&gt; submit(Runnable task)</span></span><br><span class="line"><span class="comment"> *&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</span></span><br><span class="line"><span class="comment"> *D:我就要结束，可以吗?</span></span><br><span class="line"><span class="comment"> *可以。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// 创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line"><span class="comment">// public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多线程的面试题"><a href="#多线程的面试题" class="headerlink" title="多线程的面试题"></a>多线程的面试题</h3><p>具体的面试题可以参考我的往期文章：<a href="https://blog.jh0904.top/2018/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" rel="noopener">多线程面试题</a></p><p>在看面试题的时候，要注意，自己是否是自己真的理解了透彻了。先去思考问题，再去想自己的语言如何回答，自己如果面试遇到这种问题了应该如何处理。之后再去看答案和解析，这样更有收获，一起加油ヾ(◍°∇°◍)ﾉﾞ。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是多线程的第二篇文章，主要介绍一写java多线程的简单锁机制和死锁、线程池等一些概念，多线程的高级部分过一段时间加上。&lt;/p&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程（一）</title>
    <link href="http://yoursite.com/2018/07/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/16/多线程（一）/</id>
    <published>2018-07-16T15:55:35.000Z</published>
    <updated>2018-07-16T15:57:02.647Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h2 id="多线程-一"><a href="#多线程-一" class="headerlink" title="多线程(一)"></a>多线程(一)</h2><h3 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h3><p>多线程：一个应用程序有多条执行路径<br>        进程：正在执行的应用程序<br>        线程：进程的执行单元，执行路径<br>        单线程：一个应用程序只有一条执行路径<br>        多线程：一个应用程序有多条执行路径</p><blockquote><p>并发和并行的区别：简单的说，并行是指同一时刻同时做多件事情，而并发是指同一时间间隔内做多件事情。</p><font style="color:red;font-size:12px">  并发是两个任务可以在重叠的时间段内启动，运行和完成。并行是任务在同一时间运行，例如，在多核处理器上。<br>并发是独立执行过程的组合，而并行是同时执行（可能相关的）计算。<br>并发是一次处理很多事情，并行是同时做很多事情。<br>应用程序可以是并发的，但不是并行的，这意味着它可以同时处理多个任务，但是没有两个任务在同一时刻执行。<br>应用程序可以是并行的，但不是并发的，这意味着它同时处理多核CPU中的任务的多个子任务。<br>一个应用程序可以即不是并行的，也不是并发的，这意味着它一次一个地处理所有任务。<br>应用程序可以即是并行的也是并发的，这意味着它同时在多核CPU中同时处理多个任务。</font></blockquote><h4 id="多进程的意义"><a href="#多进程的意义" class="headerlink" title="多进程的意义?"></a>多进程的意义?</h4><p>单进程的计算机只能做一件事情,而我们现在的计算机都可以做多件事情。<br>    举例:一边玩游戏(游戏进程),一边听音乐(音乐进程)。<br>    也就是说现在的计算机都是支持多进程的,可以在一个时间段内执行多个任务。<br>    并且呢,可以提高CPU的使用率。</p><h4 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义?"></a>多线程的意义?</h4><p>多线程的存在,不是提高程序的执行速度。其实是为了提高应用程序的使用率。<br>    程序的执行其实都是在抢CUP的资源,CPU的执行权。<br>    多个进程是在抢这个资源,而其中的某一个进程如果执行路径比较多,就会有更高的几率抢到CPU的执行权。<br>    我们是不敢保证哪一个线程在哪个时刻抢到,所以线程的执行有随机性。<br>    举例:一个美女抛绣球(CPU执行权),A,B,C…等,ABC(进程)三个人抢绣球(CPU执行权),但是由于B(进程)使用分身术(多条执行路径),而他抢到绣球的机率将会很高,但是不一定能抢到</p><h3 id="Java程序的运行原理及JVM的启动是多线程的吗"><a href="#Java程序的运行原理及JVM的启动是多线程的吗" class="headerlink" title="Java程序的运行原理及JVM的启动是多线程的吗?"></a>Java程序的运行原理及JVM的启动是多线程的吗?</h3><ol><li>Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。</li><li>JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。<h3 id="多线程的实现方案"><a href="#多线程的实现方案" class="headerlink" title="多线程的实现方案"></a>多线程的实现方案</h3></li><li><p>继承Thread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cn.thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/2 18:18</span></span><br><span class="line"><span class="comment"> * description:实现Thread方法，继承Thread类，然后再去重写run（）方法。</span></span><br><span class="line"><span class="comment"> * 不是所有类需要被多线程执行，run（）方法里面是被线程执行的代码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            System.out.println (getName ()+<span class="string">"------&gt;"</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep (<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace ();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* getName ()源码</span></span><br><span class="line"><span class="comment">public Thread() &#123;</span></span><br><span class="line"><span class="comment">         init(null, null, "Thread-" + nextThreadNum(), 0);</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest1 t = <span class="keyword">new</span> ThreadTest1 ();</span><br><span class="line">        ThreadTest1 t1 = <span class="keyword">new</span> ThreadTest1 ();</span><br><span class="line"></span><br><span class="line">        t.setName (<span class="string">"magic"</span>);</span><br><span class="line">        t1.setName (<span class="string">"jh"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        启动线程</span></span><br><span class="line"><span class="comment">        t.run ();</span></span><br><span class="line"><span class="comment">        t.run ();*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// java.lang.IllegalThreadStateException(非法的状态异常，相当于main线程启动了两次)</span></span><br><span class="line">       <span class="comment">/* t.start ();</span></span><br><span class="line"><span class="comment">        t.start ();*/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//如何获取线程的名称  public String getName()</span></span><br><span class="line">        t.start ();</span><br><span class="line">        t1.start ();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * run方法调用就相当于普通方法的调用，单线程的执行</span></span><br><span class="line"><span class="comment">         * 面试题：start和run的区别：</span></span><br><span class="line"><span class="comment">         * run：仅仅是封装被线程执行的代码，直接是调用是普通方法。</span></span><br><span class="line"><span class="comment">         * start：首先启动线程，然后再由JVM虚拟机调用该线程的run（）方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口<br>首先先实现一个线程，其次重写run()方法；下面这是一个卖票的多线程程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cn.thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/3 8:22</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj=<span class="keyword">new</span> Object ();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println (Thread.currentThread ().getName ()+<span class="string">"正在售票---&gt;"</span>+(count--));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>接下来是Main的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread1 my = <span class="keyword">new</span> MyThread1 ();</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread (my, <span class="string">"一号窗口"</span>);</span><br><span class="line">        Thread tt = <span class="keyword">new</span> Thread (my, <span class="string">"二号窗口"</span>);</span><br><span class="line">        Thread ttt = <span class="keyword">new</span> Thread (my, <span class="string">"三号窗口"</span>);</span><br><span class="line"></span><br><span class="line">        t.start ();</span><br><span class="line">        tt.start ();</span><br><span class="line">        ttt.start ();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>实现Callable接口<br>实现Callable接口，重写call（）方法；<br>具体代码见下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程求和案例(实现Callable接口，重写了call()方法)</span></span><br><span class="line"><span class="comment"> * Callable:是带泛型的接口。</span></span><br><span class="line"><span class="comment"> * 这里指定的泛型其实是call()方法的返回值类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= number; x++) &#123;</span><br><span class="line">sum += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多线程实现的方式3：</span></span><br><span class="line"><span class="comment"> *  A:创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line"><span class="comment"> * public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment"> * B:这种线程池的线程可以执行：</span></span><br><span class="line"><span class="comment"> * 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line"><span class="comment"> * 做一个类实现Runnable接口。</span></span><br><span class="line"><span class="comment"> * C:调用如下方法即可</span></span><br><span class="line"><span class="comment"> * Future&lt;?&gt; submit(Runnable task)</span></span><br><span class="line"><span class="comment"> *&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</span></span><br><span class="line"><span class="comment"> *D:我就要结束，可以吗?</span></span><br><span class="line"><span class="comment"> *可以。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"><span class="comment">// 创建线程池对象</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">Future&lt;Integer&gt; f1 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">100</span>));</span><br><span class="line">Future&lt;Integer&gt; f2 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// V get()</span></span><br><span class="line">Integer i1 = f1.get();</span><br><span class="line">Integer i2 = f2.get();</span><br><span class="line"></span><br><span class="line">System.out.println(i1);</span><br><span class="line">System.out.println(i2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line">pool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结：总的来说，虽然实现多线程有两种方式，但是还是推荐使用实现Runable接口的方式，让程序具有可扩展性。</p><h3 id="线程的调度和优先级问题"><a href="#线程的调度和优先级问题" class="headerlink" title="线程的调度和优先级问题"></a>线程的调度和优先级问题</h3><ol><li>线程的调度</li></ol><ul><li>分时调度，所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</li><li>抢占式调度 (Java采用的是该调度方式)，优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 </li></ul><ol start="2"><li>获取和设置线程优先级</li></ol><ul><li>默认是5</li><li>范围是1-10<br>在Java中，线程的优先级用setPriority()方法就行，线程的优先级分为1-10这10个等级，如果小于1或大于10，则抛出异常throw new IllegalArgumentException()，默认是5。<br>主要的方法是：<blockquote><p>public final int getPriority()      获取线程优先级<br>public final void setPriority(int newPriority)设置线程优先级（1-10）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriority</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>Main方法示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们的线程没有设置优先级,肯定有默认优先级。</span></span><br><span class="line"><span class="comment"> * 那么，默认优先级是多少呢?</span></span><br><span class="line"><span class="comment"> * 如何获取线程对象的优先级?</span></span><br><span class="line"><span class="comment"> * public final int getPriority():返回线程对象的优先级</span></span><br><span class="line"><span class="comment"> * 如何设置线程对象的优先级呢?</span></span><br><span class="line"><span class="comment"> * public final void setPriority(int newPriority)：更改线程的优先级。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 线程默认优先级是5。</span></span><br><span class="line"><span class="comment"> * 线程优先级的范围是：1-10。</span></span><br><span class="line"><span class="comment"> * 线程优先级高仅仅表示线程获取的 CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到比较好的效果。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * IllegalArgumentException:非法参数异常。</span></span><br><span class="line"><span class="comment"> * 抛出的异常表明向方法传递了一个不合法或不正确的参数。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriorityDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadPriority tp1 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line">ThreadPriority tp2 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line">ThreadPriority tp3 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line"></span><br><span class="line">tp1.setName(<span class="string">"东方不败"</span>);</span><br><span class="line">tp2.setName(<span class="string">"岳不群"</span>);</span><br><span class="line">tp3.setName(<span class="string">"林平之"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取默认优先级</span></span><br><span class="line"><span class="comment">// System.out.println(tp1.getPriority());</span></span><br><span class="line"><span class="comment">// System.out.println(tp2.getPriority());</span></span><br><span class="line"><span class="comment">// System.out.println(tp3.getPriority());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程优先级</span></span><br><span class="line"><span class="comment">// tp1.setPriority(100000);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置正确的线程优先级</span></span><br><span class="line">tp1.setPriority(<span class="number">10</span>);</span><br><span class="line">tp2.setPriority(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">tp1.start();</span><br><span class="line">tp2.start();</span><br><span class="line">tp3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="线程的控制-常见方法"><a href="#线程的控制-常见方法" class="headerlink" title="线程的控制(常见方法)"></a>线程的控制(常见方法)</h4><p>A:休眠线程  (public static void sleep(long millis))<br>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x + <span class="string">",日期："</span> + <span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">// 睡眠</span></span><br><span class="line"><span class="comment">// 困了，我稍微休息1秒钟</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程休眠</span></span><br><span class="line"><span class="comment"> *public static void sleep(long millis)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleepDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadSleep ts1 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">ThreadSleep ts2 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">ThreadSleep ts3 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line"></span><br><span class="line">ts1.setName(<span class="string">"林青霞"</span>);</span><br><span class="line">ts2.setName(<span class="string">"林志玲"</span>);</span><br><span class="line">ts3.setName(<span class="string">"林志颖"</span>);</span><br><span class="line"></span><br><span class="line">ts1.start();</span><br><span class="line">ts2.start();</span><br><span class="line">ts3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>B:加入线程  (public final void join())<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public final void join():等待该线程终止。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadJoin tj1 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">ThreadJoin tj2 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">ThreadJoin tj3 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line"></span><br><span class="line">tj1.setName(<span class="string">"李渊"</span>);</span><br><span class="line">tj2.setName(<span class="string">"李世民"</span>);</span><br><span class="line">tj3.setName(<span class="string">"李元霸"</span>);</span><br><span class="line"></span><br><span class="line">tj1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">tj1.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tj2.start();</span><br><span class="line">tj3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C:礼让线程  (public static void yield())<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYield</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">Thread.yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public static void yield():暂停当前正在执行的线程对象，并执行其他线程。 </span></span><br><span class="line"><span class="comment"> * 让多个线程的执行更和谐，但是不能靠它保证一人一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYieldDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadYield ty1 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line">ThreadYield ty2 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line"></span><br><span class="line">ty1.setName(<span class="string">"林青霞"</span>);</span><br><span class="line">ty2.setName(<span class="string">"刘意"</span>);</span><br><span class="line"></span><br><span class="line">ty1.start();</span><br><span class="line">ty2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>D:后台线程  (public final void setDaemon(boolean on))<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemon</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public final void setDaemon(boolean on):将该线程标记为守护线程或用户线程。</span></span><br><span class="line"><span class="comment"> * 当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 游戏：坦克大战。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemonDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadDaemon td1 = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line">ThreadDaemon td2 = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line"></span><br><span class="line">td1.setName(<span class="string">"关羽"</span>);</span><br><span class="line">td2.setName(<span class="string">"张飞"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置收获线程</span></span><br><span class="line">td1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">td2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">td1.start();</span><br><span class="line">td2.start();</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setName(<span class="string">"刘备"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>E:终止线程  (public final void stop()/public void interrupt())<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStop</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始执行："</span> + <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我要休息10秒钟，亲，不要打扰我哦</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// e.printStackTrace();</span></span><br><span class="line">System.out.println(<span class="string">"线程被终止了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"结束执行："</span> + <span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public final void stop():让线程停止，过时了，但是还可以使用。</span></span><br><span class="line"><span class="comment"> * public void interrupt():中断线程。 把线程的状态终止，并抛出一个InterruptedException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadStop ts = <span class="keyword">new</span> ThreadStop();</span><br><span class="line">ts.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你超过三秒不醒过来，我就干死你</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// ts.stop();</span></span><br><span class="line">ts.interrupt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程的生命周期-参照-线程生命周期图解-bmp"><a href="#线程的生命周期-参照-线程生命周期图解-bmp" class="headerlink" title="线程的生命周期(参照    线程生命周期图解.bmp)"></a>线程的生命周期(参照    线程生命周期图解.bmp)</h3><p>A:新建<br>B:就绪<br>C:运行<br>D:阻塞<br>E:死亡<br><strong>如图所示：</strong><br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-16/99895317.jpg" alt=""></p><h3 id="电影院卖票程序的实现"><a href="#电影院卖票程序的实现" class="headerlink" title="电影院卖票程序的实现"></a>电影院卖票程序的实现</h3><p>A:继承Thread类<br>B:实现Runnable接口</p><h3 id="电影院卖票程序出问题"><a href="#电影院卖票程序出问题" class="headerlink" title="电影院卖票程序出问题"></a>电影院卖票程序出问题</h3><ol><li>为了更符合真实的场景，加入了休眠100毫秒。</li><li>卖票问题</li></ol><ul><li>同票多次</li><li>负数票<h3 id="多线程安全问题的原因"><a href="#多线程安全问题的原因" class="headerlink" title="多线程安全问题的原因"></a>多线程安全问题的原因</h3></li><li>是否有多线程环境</li><li>是否有共享数据</li><li>是否有多条语句操作共享数据<h3 id="同步解决线程安全问题"><a href="#同步解决线程安全问题" class="headerlink" title="同步解决线程安全问题"></a>同步解决线程安全问题</h3></li></ul><ol><li><p>同步代码块</p><pre><code>synchronized(对象) {    需要被同步的代码;}</code></pre><p> 这里的锁对象可以是任意对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//创建锁对象</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//while (true) &#123;</span></span><br><span class="line"><span class="comment">//synchronized(new Object())&#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100); </span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName() + "正在出售第"</span></span><br><span class="line"><span class="comment">//+ (tickets--) + "张票");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_09;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何解决线程安全问题呢?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 要想解决问题，就要知道哪些原因会导致出问题:(而且这些原因也是以后我们判断一个程序是否会有线程安全问题的标准)</span></span><br><span class="line"><span class="comment"> * A:是否是多线程环境</span></span><br><span class="line"><span class="comment"> * B:是否有共享数据</span></span><br><span class="line"><span class="comment"> * C:是否有多条语句操作共享数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 我们来回想一下我们的程序有没有上面的问题呢?</span></span><br><span class="line"><span class="comment"> * A:是否是多线程环境是</span></span><br><span class="line"><span class="comment"> * B:是否有共享数据是</span></span><br><span class="line"><span class="comment"> * C:是否有多条语句操作共享数据是</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 由此可见我们的程序出现问题是正常的，因为它满足出问题的条件。</span></span><br><span class="line"><span class="comment"> * 接下来才是我们要想想如何解决问题呢?</span></span><br><span class="line"><span class="comment"> * A和B的问题我们改变不了，我们只能想办法去把C改变一下。</span></span><br><span class="line"><span class="comment"> * 思想：</span></span><br><span class="line"><span class="comment"> * 把多条语句操作共享数据的代码给包成一个整体，让某个线程在执行的时候，别人不能来执行。</span></span><br><span class="line"><span class="comment"> * 问题是我们不知道怎么包啊?其实我也不知道，但是Java给我们提供了：同步机制。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步代码块：</span></span><br><span class="line"><span class="comment"> * synchronized(对象)&#123;</span></span><br><span class="line"><span class="comment"> * 需要同步的代码;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * A:对象是什么呢?</span></span><br><span class="line"><span class="comment"> * 我们可以随便创建一个对象试试。</span></span><br><span class="line"><span class="comment"> * B:需要同步的代码是哪些呢?</span></span><br><span class="line"><span class="comment"> * 把多条语句操作共享数据的代码的部分给包起来</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。</span></span><br><span class="line"><span class="comment"> * 多个线程必须是同一把锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个线程对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>同步方法</p><pre><code>把同步加在方法上。</code></pre><p> 这里的锁对象是this</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义同一把锁</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// t1,t2,t3都能走到这里</span></span><br><span class="line"><span class="comment">// 假设t1抢到CPU的执行权，t1就要进来</span></span><br><span class="line"><span class="comment">// 假设t2抢到CPU的执行权，t2就要进来,发现门是关着的，进不去。所以就等着。</span></span><br><span class="line"><span class="comment">// 门(开,关)</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123; <span class="comment">// 发现这里的代码将来是会被锁上的，所以t1进来后，就锁了。(关)</span></span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>); <span class="comment">// t1就睡眠了</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line"><span class="comment">//窗口1正在出售第100张票</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//t1就出来可，然后就开门。(开)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_10;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 举例：</span></span><br><span class="line"><span class="comment"> * 火车上厕所。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步的特点：</span></span><br><span class="line"><span class="comment"> * 前提：</span></span><br><span class="line"><span class="comment"> * 多个线程</span></span><br><span class="line"><span class="comment"> *解决问题的时候要注意：</span></span><br><span class="line"><span class="comment"> *多个线程使用的是同一个锁对象</span></span><br><span class="line"><span class="comment"> * 同步的好处 </span></span><br><span class="line"><span class="comment"> *同步的出现解决了多线程的安全问题。</span></span><br><span class="line"><span class="comment"> * 同步的弊端</span></span><br><span class="line"><span class="comment"> *当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个线程对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>静态同步方法</p><pre><code>把同步加在方法上。</code></pre><p> 这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义同一把锁</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步代码块用obj做锁</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//while (true) &#123;</span></span><br><span class="line"><span class="comment">//synchronized (obj) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同步代码块用任意对象做锁</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//while (true) &#123;</span></span><br><span class="line"><span class="comment">//synchronized (d) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SellTicket.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//synchronized (d) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">sellTicket();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private void sellTicket() &#123;</span></span><br><span class="line"><span class="comment">//synchronized (d) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果一个方法一进去就看到了代码被同步了，那么我就再想能不能把这个同步加在方法上呢?</span></span><br><span class="line"><span class="comment">// private synchronized void sellTicket() &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_11;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A:同步代码块的锁对象是谁呢?</span></span><br><span class="line"><span class="comment"> * 任意对象。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * B:同步方法的格式及锁对象问题?</span></span><br><span class="line"><span class="comment"> * 把同步关键字加在方法上。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步方法是谁呢?</span></span><br><span class="line"><span class="comment"> * this</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * C:静态方法及锁对象问题?</span></span><br><span class="line"><span class="comment"> * 静态方法的锁对象是谁呢?</span></span><br><span class="line"><span class="comment"> * 类的字节码文件对象。(反射会讲)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个线程对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="回顾以前的线程安全的类"><a href="#回顾以前的线程安全的类" class="headerlink" title="回顾以前的线程安全的类"></a>回顾以前的线程安全的类</h3><blockquote><p> StringBuffer<br>Vector<br>Hashtable</p></blockquote><p>如何把一个线程不安全的集合类变成一个线程安全的集合类<br>有两种方法，首先寻找原本就线程安全的类：CopyOnWriteArrayList、ConcurrentHashMap等方法来实现。<br>用Collections工具类的方法即可。比如synchronizedSet(Set<t> s)的静态方法，具体见下图。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-16/80203006.jpg" alt=""></t></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;多线程-一&quot;&gt;&lt;a href=&quot;#多线程-一&quot; class=&quot;headerlink&quot; title=&quot;多线程(一)&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Vector、ArrayList、LinkedList之间的区别？</title>
    <link href="http://yoursite.com/2018/07/14/Vector%E3%80%81ArrayList%E3%80%81LinkedList/"/>
    <id>http://yoursite.com/2018/07/14/Vector、ArrayList、LinkedList/</id>
    <published>2018-07-14T15:11:26.000Z</published>
    <updated>2018-07-14T15:12:11.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><p><strong>Vector</strong> 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</p><p><strong>ArrayList</strong> 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。</p><p><strong>LinkedList</strong> 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>一般来说，不同容器适合不同的场景。</p><ul><li>Vector和ArrayList都是动态数组，其内部元素以数组的顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会比较差，比如我们在元素中间插入一个元素，需要移动后续所有元素。</li><li>而LinkedList进行节点插入、删除效率很高，但是随机访问性能则要比动态数组慢很多。<br>对于Vector的分析可以看我之前的文章<a href="https://blog.jh0904.top/2018/06/06/Vector%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Vector的源码解析</a>，还有我在CSDN上面写的关于ArrayList的文章：<a href="https://blog.csdn.net/qq_34123742/article/details/80137160" target="_blank" rel="noopener">ArrayList源码分析</a><br>有什么不对请大家指正，感谢❤<br><strong>集合框架的整体设计</strong><br>可以如下图所示（并没有Map。虽然通常概念上它作为集合 框架的一部分，但是本本身并不是真正的集合）：</li></ul><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-14/77561179.jpg" alt="集合框架"></p><p>我们可以看到java的集合框架，Collection接口是所有的根，然后主要扩展了三大类集合：</p><ol><li><p>List,也就是我们前面介绍最多的有序集合，它提供了方便的访问、插入、删除等操作。</p></li><li><p>SetSet 是不允许重复元素的，这是和 List 最明显的区别，也就是不存在两个对象 equals 返回 true。我们在日常开发中有很多需要保证元素唯一性的场合。</p></li></ol><ol start="3"><li>Queue则是 Java 提供的标准队列结构的实现，除了集合的基本功能，它还支持类似先入先出（FIFO， First-in-First-Out）或者后入先出（LIFO，Last-In-First-Out）等特定行为。这里不包括 BlockingQueue，因为通常是并发编程场合，所以被放置在并发包里。</li></ol><p>其实总的来说，集合框架的学习还是重在源码的学习，里面有很多优秀的设计思路，也封装了很多数据结构，并且在并发编程的时候，还要注意使用不同的集合或是使用Collections的同步方法。<br>下面我放一些我对源码解析的文章（未完待续…大家一起学习，一起进步）</p><ul><li><a href="https://blog.csdn.net/qq_34123742/article/details/80077732" target="_blank" rel="noopener">Collection概述</a></li><li><a href="https://blog.csdn.net/qq_34123742/article/details/80137160" target="_blank" rel="noopener">ArrayList源码分析</a></li><li><a href="https://blog.csdn.net/qq_34123742/article/details/80261319" target="_blank" rel="noopener">Vector源码解析</a></li><li><a href="https://blog.jh0904.top/2018/06/08/hashmap/" target="_blank" rel="noopener">HashMap的源码解析</a></li><li>未完待续</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;基本概述&quot;&gt;&lt;a href=&quot;#基本概述&quot; class=&quot;headerlink&quot; title=&quot;基本概述&quot;&gt;&lt;/a&gt;基
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>int和Integer的区别？Integer的值缓存范围？</title>
    <link href="http://yoursite.com/2018/07/13/int%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FInteger%E7%9A%84%E5%80%BC%E7%BC%93%E5%AD%98%E8%8C%83%E5%9B%B4%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/13/int和Integer的区别？Integer的值缓存范围？/</id>
    <published>2018-07-13T12:45:33.000Z</published>
    <updated>2018-07-13T12:46:38.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>int 是我们常说的整形数字，是 Java 的 8 个原始数据类型（Primitive Types），boolean、byte 、short、char、int、float、double、long之一。Java 语言虽然号称一切都是对象，但原始数据类型是例外。</p><p>Integer 是 int 对应的包装类，它有一个 int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间转换等。在 Java 5 中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。</p><p>关于 Integer 的值缓存，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，这个值默认缓存是 -128 到 127 之间。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><h4 id="理解自动拆箱，自动装箱。"><a href="#理解自动拆箱，自动装箱。" class="headerlink" title="理解自动拆箱，自动装箱。"></a>理解自动拆箱，自动装箱。</h4><p>自动装箱实际是一种语法糖，语法糖是指java平台为我们自动进行了一些转换，保证不同写法在运行时等价，它们发生在编译阶段，而且生成的字节码是一致的。<br>就像之前说的int整数，javac会替我们自动装箱为Integer.valueOf()，把拆箱自动转换成Integer.valueOf()。我们可以看一下java的class文件反编译后的结果。<br>大致的包装类有：</p><blockquote><p>int——Integer<br>float——Float<br>double——Double<br>byte——Byte<br>long——Long<br>char——Character<br>boolean——Boolean<br>short——Short</p></blockquote><p>这是一个简单的自动拆/装箱的程序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Integer i=<span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> totalprim = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反编译输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Integer i = Integer.valueOf(<span class="number">99</span>);</span><br><span class="line">i.intValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仔细观察，其实就是通过Integer.valueOf(99)实现自动装箱。i.intValue()实现自动拆箱。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1=<span class="number">100</span>;</span><br><span class="line">      Integer i2=<span class="number">100</span>;</span><br><span class="line">      Integer i3=<span class="number">300</span>;</span><br><span class="line">      Integer i4=<span class="number">300</span>;</span><br><span class="line">      System.out.println(i1==i2);<span class="comment">//true</span></span><br><span class="line">      System.out.println(i3==i4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>在源码中，Integer.valueOf(int i)的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)  </span><br><span class="line">          <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];  </span><br><span class="line">      <span class="keyword">else</span>  </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到当i&gt;=-128且i&lt;=IntegerCache.high时，直接返回IntegerCache.cache[i + 128]。其中，IntegerCache为Integer的内部静态类。我们可以清楚地看到，IntegerCache有静态成员变量cache，为一个拥有256个元素的数组。在IntegerCache中也对cache进行了初始化，即第i个元素是值为i-128的Integer对象。而-128至127是最常用的Integer对象，这样的做法也在很大程度上提高了性能。也正因为如此，“Integeri1=100;Integer i2=100;”，i1与i2得到是相同的对象。</p><p><font style="color:red"><b>也就是说在-128—127的范围内为自动拆装箱。超过范围则不会自动转换，应该注意！！！<br></b><br></font><br>其实在阿里巴巴Java开发手册中，已经有介绍：</p><blockquote><p>所有的包装类对象之间值的比较，全部使用equals方法比较。<br>说明：对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 235;</span><br><span class="line">    Integer b = 235;</span><br><span class="line">    if (a.equals(b)) &#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>整体看一下Integer的职责，主要包括各种基础的常量，比如最大值、最小值、位数等。<br>首先，java默认大小是-128-127之间，其实这个值是可以修改的，可以通过JVM参数修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-xx:AutoBoxCacheMax=N</span><br></pre></td></tr></table></figure></p><p>这些实现都体现在java.lang.Integer中，并且实现在IntegerCache的静态初始化块中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =                VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>第二，我们在分析字符串的设计实现时，提到过字符串是不可变的，保证了基本的信息安全和并发编程中的线程安全。如果你去看包装类里存储数值的成员变量“ value”，你会发现，不管是 Integer还 Boolean等，都被声明为“ private final”，所以，它们同样是不可变类型！<br>这种设计是可以理解的，或者说是必须的选择。想象一下这个应用场景，比如 Integer提供了 getInteger()方法，用于方便地读取系统属性，我们可以用属性来设置服务器某个服务的端口，如果我可以轻易地把获取到的 Integer对象改变为其他数值，这会带来产品可靠性方面的严重问题。<br>第三， Integer等包装类，定义了类似 SIZE或者 BYTES这样的常量，这反映了什么样的设计考虑呢？如果你使用过其他语言，比如 C、 C++，类似整数的位数，其实是不确定的，可能在不同的平台，比如32位或者64位平台，存在非常大的不同。那么，在32位 JDK或者64。<br>其实，这种移植对于 Java来说相对要简单些，因为原始数据类型是不存在差异的，这些明确定义在 Java语言规范里面，不管是32位还是64位环境，开发者无需担心数据的位数差异。</p><h4 id="原始类线程安全"><a href="#原始类线程安全" class="headerlink" title="原始类线程安全"></a>原始类线程安全</h4><p>原始数据类型是不是线程安全？</p><ul><li>原始数据类型的变量，显然要通过使用并发相关手段，才能保证线程安全。如果需要线程安全这样的需求，可以直接考虑使用线程安全的类，比如：AtomicInteger/AtomicLong.</li><li>特别是一些比较宽的数据类型，比如float、do，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半的数据位。</li></ul><h4 id="java原始数据类型和应用类型的局限性"><a href="#java原始数据类型和应用类型的局限性" class="headerlink" title="java原始数据类型和应用类型的局限性"></a>java原始数据类型和应用类型的局限性</h4><p>原始数据类型的一些局限性：</p><ul><li><p><strong>原始数据类型不能和java泛型配合使用。</strong><br>这是因为 Java 的泛型某种程度上可以算作伪泛型，它完全是一种编译期的技巧，Java 编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为 Object。</p></li><li><p><strong>无法高效地表达数据，也不能表达复杂的数据结构，不如vector和tuple。</strong><br>我们知道 Java 的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。<br>Java 为对象内建了各种多态、线程安全等方面的支持，但这不是所有场合的需求，尤其是数据处理重要性日益提高，更加高密度的值类型是非常现实的需求。<br>目前，针对这些方面的增强，OpenJDK也在开发中，估计之后会有更好的发展。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>动态代理基于什么原理？</title>
    <link href="http://yoursite.com/2018/07/12/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/12/动态代理基于什么原理？/</id>
    <published>2018-07-12T03:08:48.000Z</published>
    <updated>2018-07-12T03:12:02.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p><p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>这道题会让人下意识的感觉是在考反射，但是实现动态代理的方式有很多，不止是反射一种。功能才是目的，实现的方法有很多。<br>主要的考察点：</p><ul><li>考察对反射的了解程度。</li><li>动态代理解决了什么问题，应用场景是什么？</li><li>JDK的动态代理的设计和实现和cgilb的方式有什么不同，如何选择两者？</li></ul><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.<br>通过反射可以动态获取Constructors、Method、Class、Field。这些只能获取公共的方法，要想获取私有的方法，需要加上getDeclared+…，。<br>其中还有反射提供的AccessibleObject.setAccessible(boolean flag),<br>这里的Accessible可以理解为修改成修饰成员public、protected、private。可以修改为false，取消java语法检查。这意味着可以在运行时修改成员变量的访问限制。<br>setAccessible 的应用场景非常普遍，遍布我们的日常开发、测试、依赖注入等各种框架中。比如，在 O/R Mapping 框架中，我们为一个 Java 实体对象，运行时自动生成 setter、getter 的逻辑，这是加载或者持久化数据非常必要的，框架通常可以利用反射做这个事情，而不需要开发者手动写类似的重复代码。</p><blockquote><p> <font style="color:red">需要注意的是在java9以后，这个方法有一些改变，因为新增的模块化系统，处于对系统封装性的考虑，对反射进行了一些限制,Jigsaw引入了所谓的open的概念，只有当被反射对象操作的模块和指定的包对反射调用者模块open，才能使用setAccessible，否则被认为不合法（illegal）。<br> </font><br>具体的操作可以参考我写的Demo：<a href="https://https://github.com/jh0904/GitTest/tree/master/GitTest1/src/cn/reflect" target="_blank" rel="noopener">reflect</a></p></blockquote><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>代理可以看做对调用目标的一个包装，这样我们可以对目标代码的调用不是直接发生的，而是通过代理完成的。<br>动态代理的作用可以用来做AOP。可以去做一些重复的工作（比如权限呢检验，日志记录），用动态代理去抽取出来。增强代码的易用性。</p><p>具体介绍一下java里面内置的Proxy类的一些简单操作：<br>在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib。</p><p>Proxy类中的方法创建动态代理类对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure></p><p>最终会调用InvocationHandler的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler Object invoke(Object proxy,Method method,Object[] args)</span><br></pre></td></tr></table></figure></p><p>动态代理的具体实现可以参考我的GitHub：<a href="https://github.com/jh0904/GitTest/tree/master/GitTest1/src/cn/reflect/proxy" target="_blank" rel="noopener">Proxy</a>。</p><p>cgilb实现动态代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待续...</span><br></pre></td></tr></table></figure></p><p>动态代理的使用场景：<br>AOP 通过（动态）代理机制可以让开发者从这些繁琐事项中抽身出来，大幅度提高了代码的抽象程度和复用度。从逻辑上来说，我们在软件设计和实现中的类似代理，如 Facade、Observer 等很多设计目的，都可以通过动态代理优雅地实现。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-12/37239512.jpg" alt=""></p><h4 id="JDK的动态代理的设计和实现和cgilb的方式有什么不同"><a href="#JDK的动态代理的设计和实现和cgilb的方式有什么不同" class="headerlink" title="JDK的动态代理的设计和实现和cgilb的方式有什么不同?"></a>JDK的动态代理的设计和实现和cgilb的方式有什么不同?</h4><p>我大概简单介绍一下：<br><strong>对于JDK Proxy的优势：</strong></p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li><li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li><li>代码实现简单。</li></ul><p><strong>cglib框架的优势：</strong></p><ul><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder的区别？</title>
    <link href="http://yoursite.com/2018/07/11/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/11/String、StringBuffer、StringBuilder的区别？/</id>
    <published>2018-07-11T06:18:26.000Z</published>
    <updated>2018-07-11T06:19:08.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p><h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><table><thead><tr><th></th><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>对象类型</td><td>字符串常量</td><td>字符串变量</td><td>字符串变量</td></tr><tr><td>线程安全</td><td>不安全</td><td>不安全</td><td>安全</td></tr><tr><td>执行效率</td><td>低</td><td>高</td><td>中</td></tr><tr><td>使用场景</td><td>操作少，数据少</td><td>单线程，操作多，数据多</td><td>多线程，操作多，数据多</td></tr></tbody></table><h3 id="String为什么设计成final？"><a href="#String为什么设计成final？" class="headerlink" title="String为什么设计成final？"></a>String为什么设计成final？</h3><p>原因无非就是下面几点：</p><ul><li>为了实现字符串池</li><li>为了线程安全</li><li>为了实现String可以创建HashCode不可变性</li></ul><p>首先要了解final关键字的含义，在之前的文章已经介绍过什么是fina具体可以查看之前的文章：<a href="https://blog.jh0904.top/2018/07/09/final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">final、finally、finalize的区别</a><br>我大概简述一下：final可以修饰类，方法和变量，并且被修饰的类或方法，被final修饰的类不能被继承，即它不能拥有自己的子类，被final修饰的方法不能被重写， final修饰的变量，无论是类属性、对象属性、形参还是局部变量，都需要进行初始化操作。<br>字符串在内存存储的样子如下图：<br><img src="http://i.imgur.com/3zlNPQJ.png" alt=""></p><p><strong>实现字符串池</strong><br>所以只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。<br><strong>线程安全</strong><br>如果字符串是可变的，那么会引起很严重的安全问题。因为字符串是不可变的，所以它的值是不可改变的，否则改变字符串指向的对象的值，造成安全漏洞。<br>因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。<br>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。<br><strong>HashCode不可变性</strong><br>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>强引用、软引用、弱引用、幻象引用有什么区别？</title>
    <link href="http://yoursite.com/2018/07/10/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/10/强引用、软引用、弱引用、幻象引用有什么区别？/</id>
    <published>2018-07-10T03:29:45.000Z</published>
    <updated>2018-07-10T03:31:56.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h3><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o=<span class="keyword">new</span> Object();   <span class="comment">//  强引用</span></span><br></pre></td></tr></table></figure></p><p>通过关键字new创建对象，所关联的引用就是强引用。当JVM内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。<br>如果不使用时，要通过如下方式来弱化引用，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o=<span class="keyword">null</span>;     <span class="comment">// 帮助垃圾收集器回收此对象</span></span><br></pre></td></tr></table></figure></p><p>显式的将o设置为null；或者超出对象的生命周期范围，则gc认为该对象不存在引用。这样就可以被垃圾收集了，具体回收时机还是要看垃圾回收机制。<br><strong>例子：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Object o=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于上述代码，可以看出方法的内部有一个强引用，这个引用保存在栈中，真正的引用内容（Object）保存在堆中。当这个方法运行完成之后就会退出方法栈，则引用内容的引用就不存在了，这个Object会被回收。<br>但是当这个o是全局变量时，就需要在不使用这个对象时要赋值为null，因为强引用不会被垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment">   * be empty after this call returns.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">          elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个就是在java源码中的体现。就是在需要清除的时候，需要把elementData里面全部置为空，因为elementData是全局变量。</p><h3 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h3><p>是一种相对强引用的弱化一些的引用，可以让豁免一些垃圾收集，只有当JVM尝试内存不足时。才会尝试回收软引用指定的对象。JVM会确保在抛出OutOfMemoryError之前，会先清理软引用指定的对象。软引用通常用于内存敏感的高速缓存，如果还有空内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"abc"</span>);                     </span><br><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;String&gt; softRef=<span class="keyword">new</span> SoftReference&lt;String&gt;(str);</span><br><span class="line"><span class="comment">// 软引用</span></span><br></pre></td></tr></table></figure></p><p>当内存不足时，等价于：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">If(JVM.内存不足()) &#123;</span><br><span class="line">   str = <span class="keyword">null</span>;  <span class="comment">// 转换为软引用</span></span><br><span class="line">   System.gc(); <span class="comment">// 垃圾回收器进行回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h3 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h3><p>弱引用并不能对对象实现豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系。比如，维护一种非强制性的映射关系，如果试图获取时对象还存在，就使用它，否则重现实例化。它同样是对缓存实现的选择。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"abc"</span>);    </span><br><span class="line">WeakReference&lt;String&gt; abcWeakRef = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br><span class="line">str=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>当垃圾回收器进行扫描时,等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = null;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure></p><p><strong>弱引用和软引用之间的去区别</strong>：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 </p><h3 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h3><p> “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  Java4种引用的级别由高到低依次为：<br> <font style="color:red"></font></p><blockquote><p>强引用  &gt;  软引用  &gt;  弱引用  &gt;  虚引用<br></p></blockquote><p>可以看一下在垃圾回收时候的图解：</p><center><br><br><img src="https://images2015.cnblogs.com/blog/647994/201702/647994-20170215235400691-2090269215.png" alt=""><br></center><p>当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章：</p><p>通过表格来说明一下，如下：</p><table><thead><tr><th>引用类型</th><th>被垃圾回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVN停止运行时终止</td></tr><tr><td>软引用</td><td>在内存不足时</td><td>对象缓存</td><td>内存不足时终止</td></tr><tr><td>弱引用</td><td>在垃圾回收时</td><td>对象缓存</td><td>GC运行后终止</td></tr><tr><td>虚引用</td><td>Unknow</td><td>Unknow</td><td>Unknow</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;强引用（StrongReference）&quot;&gt;&lt;a href=&quot;#强引用（StrongReference）&quot; class
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>final、finally、finalize的区别</title>
    <link href="http://yoursite.com/2018/07/09/final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/07/09/final、finally、finalize的区别/</id>
    <published>2018-07-09T13:03:35.000Z</published>
    <updated>2018-07-09T13:10:37.512Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，要我说，这个面试题，其中是三个其实没有什么联系，只不过是因为长的比较像，就拉出来考…但是从另一个方面看的话，这三个关键字还是很重要的。接下来简单介绍一下。</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final可以用来修饰类、方法、变量，分别有不同的意义，final修饰的类不可以继承的扩展。final修饰的方法不可以被重写（overrride），final修饰的变量则为常量（即不可修改的量）。</p><h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3><p>finally则是java保证重点代码一定要被执行的一种机制，我们可以使用try-catch-fianlly或者try-finally来进行关闭JDBC连接、或者用于关闭一些流对象（现在也有新方法，就是try-with-catch可以不使用fianlly）。</p><h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h3><p>finalize是基础类java.lang.Object的一个方法。它的设计目的是保证对象在垃圾收集前完成特定资源的回收。JDK9中已不推荐使用。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><h3 id="深入理解final关键字"><a href="#深入理解final关键字" class="headerlink" title="深入理解final关键字"></a>深入理解final关键字</h3><p>在java类库中的定义和源码中，在java.lang包下，相当一部分被声明成final class ？因为这可以有效避免API使用者更改基础功能，某种程度上，这是保证平台安全性的必要手段。</p><ul><li>使用fianl修饰变量或者参数，也可以清楚地避免意外赋值导致的编程错误。甚至有人明确推荐将所有的方法参数、本地变量、成员变量都声明成final。</li><li>final变量产生了某种程度上的不可变（immutable）的效果,所以，可以用来保护只读数据，尤其在并发编程中，因为明确地不能再赋值fianl变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。</li></ul><p>final还有性能上的好处<br>下面这段话摘自<i>《Java编程思想》</i>第四版第143页：</p><blockquote><p>“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。</p></blockquote><font style="color:red">注：类的private方法会隐式地被指定为final方法。</font><h3 id="深入理解finally关键字"><a href="#深入理解finally关键字" class="headerlink" title="深入理解finally关键字"></a>深入理解finally关键字</h3><p>对于finally来说，最常见的还是在try-catch-finally中。在Java语言的异常处理中，finally块的作用就是为了保证无论出现什么情况，finally块里的代码一定会被执行。但是其中有一些特殊情况。比如说出现java虚拟机退出的时候。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"><span class="comment">// do something Syst... </span></span><br><span class="line">System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello,World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就像出现上面的代码的时候，finally中并不会有任何反应。<br>对于finally还有其他的问题，比如，finally中return值到底会返回谁？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(getInt());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(a / <span class="number">0</span>);</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">a = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * return a在程序执行到这一步的时候，这里不是return a而是return 30;这个返回路径就形成了。</span></span><br><span class="line"><span class="comment"> * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span></span><br><span class="line"><span class="comment"> * 再次回到以前的返回路径，继续走return 30;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">a = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//如果这样结果就是40了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// return a;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大家仔细观察，其实最后的返回值是30，并没有返回其中的40，这就是说明返回值时，还是返回的是当时的值，和finally中的值并没有关系。这个是比较重要的一点。</p><p>其中在JDK1.7中有一个新特性：try-with-resources<br>try-with-resources语句是一个声明一个或多个资源的try语句。一个资源作为一个对象，必须在程序结束之后关闭。try-with-resources语句确保在语句的最后每个资源都被关闭，任何实现了java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resource来实现异常处理和关闭资源。<br>具体使用见下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line"><span class="keyword">return</span> br.readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把需要关闭的对象写在括号中，其中要关闭的对象必须实现java.lang.AutoCloseable和java.io.Closeable。</p><h3 id="深入理解finalize方法"><a href="#深入理解finalize方法" class="headerlink" title="深入理解finalize方法"></a>深入理解finalize方法</h3><p>finalize方法是比较难理解的一个方法，其中涉及了java垃圾回收机制的一些知识。<br>java提供finalize()方法，垃圾回收器准备释放内存的时候，会先调用finalize()。</p><ul><li>对象不一定会被回收。</li><li>垃圾回收不是析构函数。</li><li>垃圾回收只与内存有关。</li><li>垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。<br>上面的解释来自《java编程思想》，本人对其了解也不是很多。有待提升。</li></ul><blockquote><p>这就是今天的内容，来自于杨晓峰老师的讲解和一些自己的理解和认识。有能力的同学可以支持一下，共同进步，共同努力。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-8/91450487.jpg" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
