<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>magic</title>
  
  <subtitle>jh</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-01T15:04:47.973Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>magic_jh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GC算法</title>
    <link href="http://yoursite.com/2018/09/01/GC%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/01/GC算法/</id>
    <published>2018-09-01T14:59:23.000Z</published>
    <updated>2018-09-01T15:04:47.973Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><p>GC算法就是Java虚拟机的内存回收算法。总体的大纲已经上传，需要学习的其实这个大纲已经足够，其他的更加深入的内容，可以去看《深入理解java虚拟机》。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-9-1/14884419.jpg" alt=""></p><p>这个就是整个学习的大纲，具体的xmind文件上传到百度云。<br>链接：<a href="https://pan.baidu.com/s/1C3smD1fyN2v-FlZgkNOwlA" target="_blank" rel="noopener">https://pan.baidu.com/s/1C3smD1fyN2v-FlZgkNOwlA</a> 密码：<strong>ll8o</strong><br>欢迎下载</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JUC</title>
    <link href="http://yoursite.com/2018/08/28/JUC/"/>
    <id>http://yoursite.com/2018/08/28/JUC/</id>
    <published>2018-08-28T13:28:05.000Z</published>
    <updated>2018-08-28T13:33:40.121Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><p>这次主要写的是关于JUC的一些知识点，其实就是高并发的一些内容，多线程的深入理解。脑图有限，就先放一张图片，需要的请下载，里面有代码和图片的示例。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-28/83402134.jpg" alt=""></p><p>链接：<a href="https://pan.baidu.com/s/19rkwxlc2R6NKx3xjE8CCUw" target="_blank" rel="noopener">https://pan.baidu.com/s/19rkwxlc2R6NKx3xjE8CCUw</a> 密码：f44x</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Redis(三)</title>
    <link href="http://yoursite.com/2018/08/20/Redis-%E4%B8%89/"/>
    <id>http://yoursite.com/2018/08/20/Redis-三/</id>
    <published>2018-08-20T00:45:43.000Z</published>
    <updated>2018-08-20T00:46:17.940Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><h3 id="redis的事务"><a href="#redis的事务" class="headerlink" title="redis的事务"></a>redis的事务</h3><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><h4 id="Redis事务的操作"><a href="#Redis事务的操作" class="headerlink" title="Redis事务的操作"></a>Redis事务的操作</h4><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-19/27327504.jpg" alt=""></p><p>这是事务的简单操作。<br>具体的过程主要为下面的几种</p><ul><li>Case1：正常执行</li></ul><pre><code>MULTI 开启事务。。。执行操作EXEC 执行事务</code></pre><ul><li>Case2：放弃事务</li></ul><pre><code>    MULTI 开启事务。。。执行操作DISCARD 放弃执行</code></pre><ul><li>Case3：全体连坐</li></ul><pre><code>    MULTI 开启事务。。。执行操作。。。出现错误（注意，是在开启事务之后，代码中直接报错）EXEC 执行事务程序报错，全部未执行</code></pre><ul><li>Case4：冤头债主</li></ul><pre><code>   MULTI 开启事务。。。执行操作。。。出现错误代码（注意，是在开启事务之后，代码思路有错，就像运行时异常，程序并没有报错）EXEC 执行事务程序报错，出现错误的一行未执行</code></pre><ul><li>Case5：watch监控</li></ul><pre><code>WATCH balance    监视balance这一列set balance 300  加塞篡改MULTI            开启事务增加balance 减少deptEXEC             执行事务未修改成功，因为监控了key，如果key被修改了，后面一个事务的执行失效UNWATCH          取消监控一旦执行了exec之前加的监控锁都会被取消掉了总结：    Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变，    比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行    通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生    了变化， EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用    者事务执行失败</code></pre><h4 id="Redis事务的三阶段"><a href="#Redis事务的三阶段" class="headerlink" title="Redis事务的三阶段"></a>Redis事务的三阶段</h4><ol><li>开启：以MULTI开始一个事务</li><li>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</li><li>执行：由EXEC命令触发事务</li></ol><h4 id="Redis事务的三特性"><a href="#Redis事务的三特性" class="headerlink" title="Redis事务的三特性"></a>Redis事务的三特性</h4><ol><li>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行， 也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题。</li><li>不保证原子性(部分支持事务)：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</li></ol><h3 id="redis的订阅发布"><a href="#redis的订阅发布" class="headerlink" title="redis的订阅发布"></a>redis的订阅发布</h3><p>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-17/92203242.jpg" alt=""></p><p><strong>命令及案例：</strong></p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-19/51497566.jpg" alt=""></p><p>++案例：++</p><p>先订阅后发布后才能收到消息，</p><p>1 可以一次性订阅多个，SUBSCRIBE c1 c2 c3</p><p>2 消息发布，PUBLISH c2 hello-redis</p><p>3 订阅多个，通配符<em>， PSUBSCRIBE new</em><br>4 收取消息， PUBLISH new1 redis2015</p><h3 id="redis的主从复制"><a href="#redis的主从复制" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h3><p>主从复制我们经常听到，用行话讲就是：主机数据更新后根据配置和策略，<br>自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主</p><p>主要是用来做读写分离和容灾恢复。</p><h4 id="主要的操作步骤："><a href="#主要的操作步骤：" class="headerlink" title="主要的操作步骤："></a>主要的操作步骤：</h4><ul><li>配从(库)不配主(库)</li><li>从库配置：slaveof 主库IP 主库端口</li></ul><ol><li>每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件</li><li>Info replication</li></ol><ul><li><p>修改配置文件细节操作</p><pre><code>拷贝多个redis.conf文件开启daemonize yesPid文件名字指定端口Log文件名字Dump.rdb名字</code></pre></li><li>常用3招<br>（详细的记录请查询脑图）</li></ul><ol><li>一主二仆</li></ol><p>一个Master两个Slave</p><ol start="2"><li>薪火相传</li></ol><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力</p><ol start="3"><li>反客为主</li></ol><p>使当前数据库停止与其他数据库的同步，转成主数据库</p><h4 id="主从复制的具体原理"><a href="#主从复制的具体原理" class="headerlink" title="主从复制的具体原理"></a>主从复制的具体原理</h4><pre><code>Slave启动成功连接到master后会发送一个sync命令Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</code></pre><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>其实我们观察了上面三种的主从模型，可以发现都有弊端。我们需要一个理想的模型：在主服务器坏了之后，立刻可以选出一个主服务器。并在主服务器恢复之后还可以加入到这个服务器集群中。反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p><ul><li>调整结构，6379带着80、81</li><li>自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</li><li>配置哨兵,填写内容</li></ul><pre><code> sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机</code></pre><ul><li>启动哨兵</li></ul><pre><code>Redis-sentinel /myredis/sentinel.conf 上述目录依照各自的实际情况配置，可能目录不同</code></pre><ul><li>正常主从演示</li><li>原有的master挂了</li><li>投票新选</li><li>重新主从继续开工,info replication查查看</li></ul><p>问题：如果之前的master重启回来，会不会双master冲突？<br>答：大家可以看下图，就是具体的操作演示，我们可以看到最后6379节点在恢复之后加入了6380节点的下面。所以说哨兵模式可以自己去调节<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-20/93687617.jpg" alt=""></p><p><strong>复制的缺点：</strong></p><p>++复制延时++：由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><h3 id="Jedis的使用"><a href="#Jedis的使用" class="headerlink" title="Jedis的使用"></a>Jedis的使用</h3><p>首先要使用Jedis，需要导入jar或者maven配置</p><p>Commons-pool-1.6.jar</p><p>Jedis-2.1.0.jar</p><h4 id="连接Redis数据库"><a href="#连接Redis数据库" class="headerlink" title="连接Redis数据库"></a>连接Redis数据库</h4><p>测试连通性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">Jedis jedis = new Jedis (&quot;119.23.xx.xxx&quot;);//默认端口是6379,如果不是记得再加一个参数。</span><br><span class="line">if (jedis.ping ().equals (&quot;PONG&quot;)) &#123;</span><br><span class="line">System.out.println (&quot;连接成功&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println (&quot;连接失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/jh0904/Learn_More/tree/master/src/main/java/redis下面的操作和在linux里面的操作没有什么区别，大家可以去参考一下，我的GIT里面把简单的都实现了，大家可以看看。" target="_blank" rel="noopener">https://github.com/jh0904/Learn_More/tree/master/src/main/java/redis下面的操作和在linux里面的操作没有什么区别，大家可以去参考一下，我的GIT里面把简单的都实现了，大家可以看看。</a></p><h4 id="操作基本的数据类型和键操作"><a href="#操作基本的数据类型和键操作" class="headerlink" title="操作基本的数据类型和键操作"></a>操作基本的数据类型和键操作</h4><h4 id="Jedis的事务操作"><a href="#Jedis的事务操作" class="headerlink" title="Jedis的事务操作"></a>Jedis的事务操作</h4><h4 id="Jedis的主从复制"><a href="#Jedis的主从复制" class="headerlink" title="Jedis的主从复制"></a>Jedis的主从复制</h4><h4 id="Jedis的连接池（单服务器的连接池，多服务器使用哨兵池）"><a href="#Jedis的连接池（单服务器的连接池，多服务器使用哨兵池）" class="headerlink" title="Jedis的连接池（单服务器的连接池，多服务器使用哨兵池）"></a>Jedis的连接池（单服务器的连接池，多服务器使用哨兵池）</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="NoSQL" scheme="http://yoursite.com/categories/NoSQL/"/>
    
    
      <category term="NoSQL" scheme="http://yoursite.com/tags/NoSQL/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis（二）</title>
    <link href="http://yoursite.com/2018/08/19/Redis2/"/>
    <id>http://yoursite.com/2018/08/19/Redis2/</id>
    <published>2018-08-19T12:25:54.000Z</published>
    <updated>2018-08-19T12:28:51.302Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><h3 id="redis的基本数据类型"><a href="#redis的基本数据类型" class="headerlink" title="redis的基本数据类型"></a>redis的基本数据类型</h3><p>Redis主要有五种数据类型</p><ul><li>String（字符串）</li></ul><pre><code>  String（字符串）string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M.</code></pre><ul><li>Hash（哈希，类似java里的Map）</li></ul><pre><code>Hash（哈希）Redis hash 是一个键值对集合。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map&lt;String,Object&gt;</code></pre><ul><li>List（列表）</li></ul><pre><code>List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个链表</code></pre><ul><li>Set（集合）</li></ul><pre><code>Set（集合）Redis的Set是string类型的无序集合。它是通过HashTable实现实现的，</code></pre><ul><li>Zset(sorted set：有序集合)</li></ul><pre><code>zset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</code></pre><h4 id="Redis键的操作"><a href="#Redis键的操作" class="headerlink" title="Redis键的操作"></a>Redis键的操作</h4><p><strong>哪里去获得redis常见数据类型操作命令<br>  Http://redisdoc.com/</strong></p><ul><li>keys * 查询所有的键</li><li>exists key的名字，判断某个key是否存在</li><li>move key db   —&gt;当前库就没有了，被移除了</li><li>expire key 秒钟：为给定的key设置过期时间</li><li>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li><li>type key 查看你的key是什么类型</li></ul><h4 id="Redis五大数据结构"><a href="#Redis五大数据结构" class="headerlink" title="Redis五大数据结构"></a>Redis五大数据结构</h4><p>对于五大基本数据结构，增加，删除，遍历。Jedis代码和Redis操作基本无差异，已将代码上传到GIT，大家可以参考。</p><p><a href="https://github.com/jh0904/Learn_More/blob/master/src/main/java/Redis1/RedisTest.java" target="_blank" rel="noopener">https://github.com/jh0904/Learn_More/blob/master/src/main/java/Redis1/RedisTest.java</a></p><h3 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h3><h4 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h4><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里<br>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方 式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><p>Rdb 保存的是dump.rdb文件</p><p><strong>如何触发RDB</strong></p><ol><li>配置文件中默认的快照配置</li></ol><blockquote><p>冷拷贝后重新使用 可以cp dump.rdb dump_new.rdb<br>需要牢记的一点是三种情况—&gt;<br><br>save 900 1 <br><br>save 300 10 <br><br>save 60 10000   <br><br>就是说保存的机制是900秒改动一次就保存。依次类比。</p><ol start="2"><li>命令save或者是bgsave</li></ol></blockquote><ul><li>Save：save时只管保存，其它不管，全部阻塞</li><li>BGSAVE：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间</li></ul><ol start="3"><li>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</li></ol><p><strong>如何恢复</strong></p><ul><li>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</li><li>CONFIG GET dir获取目录</li></ul><p><strong>优势</strong></p><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高</li></ul><p><strong>缺点</strong></p><ul><li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就 会丢失最后一次快照后的所有修改</li><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li></ul><p><strong>停止</strong></p><p>动态所有停止RDB保存规则的方法：redis-cli config set save “”</p><p>具体的分析大家可以参考下图：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-18/61284435.jpg" alt=""></p><h4 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h4><p>Aof保存的是appendonly.aof文件</p><p>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><p><strong>AOF启动/修复/恢复</strong></p><ul><li>正常恢复</li></ul><pre><code>启动：设置Yes  修改默认的appendonly no，改为yes将有数据的aof文件复制一份保存到对应目录(config get dir)恢复：重启redis然后重新加载</code></pre><ul><li>异常恢复</li></ul><pre><code>启动：设置Yes  修改默认的appendonly no，改为yes备份被写坏的AOF文件修复：  Redis-check-aof --fix进行修复恢复：重启redis然后重新加载</code></pre><p><strong>Rewrite</strong><br>  是什么：</p><blockquote><p>  AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p></blockquote><p>  重写原理</p><blockquote><p>  AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)， 遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件， 而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</p></blockquote><p> 触发机制</p><blockquote><p>  Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p></blockquote><p><strong>优势</strong></p><ul><li>每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好</li><li>每秒同步：appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失</li><li>不同步：appendfsync no   从不同步</li></ul><p><strong>劣势</strong></p><ul><li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li><li>Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</li></ul><p>具体的分析大家可以参考下图：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-19/45047422.jpg" alt=""></p><h4 id="两者的对比和总结"><a href="#两者的对比和总结" class="headerlink" title="两者的对比和总结"></a>两者的对比和总结</h4><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</p><p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些 命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</p><p>++同时开启两种持久化方式++</p><p>  在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.<br>  RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ 作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="NoSQL" scheme="http://yoursite.com/categories/NoSQL/"/>
    
    
      <category term="NoSQL" scheme="http://yoursite.com/tags/NoSQL/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL简述</title>
    <link href="http://yoursite.com/2018/08/17/NoSQL/"/>
    <id>http://yoursite.com/2018/08/17/NoSQL/</id>
    <published>2018-08-17T15:12:05.000Z</published>
    <updated>2018-08-17T15:18:05.122Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><h3 id="什么是nosql"><a href="#什么是nosql" class="headerlink" title="什么是nosql"></a>什么是nosql</h3><h4 id="NoSQL数据库概述"><a href="#NoSQL数据库概述" class="headerlink" title="NoSQL数据库概述"></a>NoSQL数据库概述</h4><p>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。 <br><br>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。<br>特点是：</p><ul><li>不遵守SQL标准</li><li>不支持ACID（事务）</li><li>远超过SQL的性能</li></ul><p><strong>NoSQL使用场景</strong></p><ul><li>对数据高并发的读写</li><li>海量数据的读写</li><li>对数据高可扩展性的</li></ul><p><strong>NoSQL不适用场景</strong></p><ul><li>需要事务支持</li><li>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</li></ul><p><strong>主要的NoSQL数据库的介绍</strong></p><ol><li>Memcached</li></ol><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-17/83937861.jpg" alt=""></p><ul><li>很早出现的NoSql数据库</li><li>数据都在内存中，一般不持久化</li><li>支持简单的key-value模式</li><li>一般是作为++缓存数据库++辅助持久化的数据库</li></ul><ol start="2"><li>Redis</li></ol><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-17/86280857.jpg" alt=""></p><ul><li>几乎覆盖了Memcached的绝大部分功能</li><li>数据都在内存中，支持持久化，主要用作备份恢复</li><li>除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。</li><li>一般是作为++缓存数据库++辅助持久化的数据库</li></ul><ol start="3"><li>mongoDB</li></ol><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-17/49011758.jpg" alt=""></p><ul><li>高性能、开源、模式自由(schema  free)的++文档型数据库++</li><li>数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘</li><li>虽然是key-value模式，但是对value（尤其是json）提供了丰富的查询功能</li><li>支持二进制数据及大型对象</li><li>可以根据数据的特点替代RDBMS ，成为独立的数据库。或者配合RDBMS，存储特定的数据。</li></ul><h4 id="CAP原理和BASE"><a href="#CAP原理和BASE" class="headerlink" title="CAP原理和BASE"></a>CAP原理和BASE</h4><p><strong>关系型数据库遵循ACID规则</strong></p><p>事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</p><p>1、A (Atomicity) 原子性<br>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</p><p>2、C (Consistency) 一致性<br>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。</p><p>3、I (Isolation) 独立性<br>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的</p><p>4、D (Durability) 持久性</p><h2 id="持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。"><a href="#持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。" class="headerlink" title="持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。"></a>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</h2><p>但是现在我们使用了NoSQL数据库，它遵守的是CAP原理。</p><p>CAP原理是指：</p><blockquote><p>C : Consistency（强一致性） <br><br>A : Availability（可用性）<br><br>P : Partition tolerance（分区容错性）</p></blockquote><p>CAP理论虽然说很好，但是实际上最多只可以实现两个。<br>分区容忍性是我们必须要实现的，所以我们要在强一致性和可用性做选择。</p><p><em>没有NoSQL数据库能同时保证这三点</em></p><pre><code>CA 传统Oracle数据库（单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。）AP 大多数网站架构的选择（满足一致性，分区容忍必的系统，通常性能不是特别高。）CP Redis、Mongodb  （满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。）</code></pre><p> 注意：分布式架构的时候必须做出取舍。<br>一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。<br>因此牺牲C换取P，这是目前分布式数据库产品的方向。</p><blockquote><p>CAP理论的核心：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，<br>最多只能同时较好的满足两个。</p></blockquote><p>有一个CAP的图片很形象，很清晰的说明了三个的分类和区别：</p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-17/42527718.jpg" alt=""></p><p><strong>BASE原理</strong><br>BASE其实是下面三个术语的缩写：</p><pre><code>    基本可用（Basically Available）软状态（Soft state）最终一致（Eventually consistent）</code></pre><p>BASE就是为了解决数据库强一致性引起的问题而引起的可用性降低的解决方案。<br><br>具体的思想就是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</p><p>简单的了解一下分布式和集群</p><ol><li>分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。</li><li>集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="NoSQL" scheme="http://yoursite.com/categories/NoSQL/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="NoSQL" scheme="http://yoursite.com/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis(一)</title>
    <link href="http://yoursite.com/2018/08/17/Redis%E4%B8%80/"/>
    <id>http://yoursite.com/2018/08/17/Redis一/</id>
    <published>2018-08-17T15:11:53.000Z</published>
    <updated>2018-08-17T15:14:48.136Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><h3 id="初识redis"><a href="#初识redis" class="headerlink" title="初识redis"></a>初识redis</h3><h4 id="Redis的简单介绍"><a href="#Redis的简单介绍" class="headerlink" title="Redis的简单介绍"></a>Redis的简单介绍</h4><p>Redis是一个开源的key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><h4 id="Redis的安装（Linux安装）"><a href="#Redis的安装（Linux安装）" class="headerlink" title="Redis的安装（Linux安装）"></a>Redis的安装（Linux安装）</h4><p>Windows安装比较简单，所以不做概述。<br>安装具体过程：</p><ol><li>下载获得redis-3.0.4.tar.gz后将它放入我们的Linux目录/opt</li><li>/opt目录下，解压命令:tar -zxvf redis-3.0.4.tar.gz</li><li>解压完成后出现文件夹：redis-3.0.4</li><li>进入目录:cd redis-3.0.4</li><li>在redis-3.0.4目录下执行make命令</li><li>如果make完成后继续执行make </li></ol><p>安装完成后的界面：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-17/47697874.jpg" alt=""></p><p>文件的简单介绍</p><table><thead><tr><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>Redis-benchmark</td><td>性能测试工具，可以在自己本子运行，看看自己本子性能如何 </td></tr><tr><td>Redis-check-aof</td><td>修复有问题的AOF文件，rdb和aof后面讲</td></tr><tr><td>Redis-check-dump</td><td>修复有问题的dump.rdb文件</td></tr><tr><td>Redis-cli</td><td>客户端，操作入口</td></tr><tr><td>Redis-sentinel</td><td>redis集群使用</td></tr><tr><td>Redis-server 1</td><td>Redis服务器启动命令</td></tr></tbody></table><p>注意事项：修改redis.conf文件将里面的daemonize no 改成 yes，让服务在后台启动；将默认的redis.conf拷贝到自己定义好的一个路径下，比如/myconf（保护Redis的安全）</p><h4 id="Redis的启动及杂项"><a href="#Redis的启动及杂项" class="headerlink" title="Redis的启动及杂项"></a>Redis的启动及杂项</h4><p><strong>启动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server /myredis/redis.conf</span><br><span class="line">redis-cli -p 6379</span><br></pre></td></tr></table></figure><p>测试连通</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ping</span><br><span class="line"></span><br><span class="line">--&gt;PONG   (出现这个表示连接成功)</span><br></pre></td></tr></table></figure><p><strong>关闭</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单实例关闭：redis-cli shutdown</span><br><span class="line">多实例关闭，指定端口关闭:redis-cli -p 6379 shutdown</span><br></pre></td></tr></table></figure><p><strong>杂项知识讲解</strong></p><ol><li>单进程模型来处理客户端的请求。对读写等事件的响应<br>是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率</li><li>默认16个数据库，类似数组下表从零开始，初始默认使用零号库</li><li>Select命令切换数据库</li><li>Dbsize查看当前数据库的key的数量</li><li>Flushdb：清空当前库</li><li>Flushall；通杀全部库</li><li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上</li><li>Redis索引都是从零开始</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="NoSQL" scheme="http://yoursite.com/categories/NoSQL/"/>
    
    
      <category term="NoSQL" scheme="http://yoursite.com/tags/NoSQL/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>学习TCP/UDP</title>
    <link href="http://yoursite.com/2018/08/09/TCP%E7%9A%84%E7%9F%A5%E8%AF%86%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/08/09/TCP的知识讲解/</id>
    <published>2018-08-09T09:39:20.000Z</published>
    <updated>2018-08-09T09:41:04.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol><li>UDP是无连接的</li><li>UDP使用尽最大努力支付</li><li>UDP是面向报文</li><li>UDP是没有拥塞控制的</li><li>UDP支持一对一、一对多、多对一和多对多的交互通信</li><li>UDP首部开销小</li></ol><h4 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h4><blockquote><p>(1)  源端口      源端口号。在需要对方回信时选用。不需要时可用全0。</p></blockquote><blockquote><p>(2)  目的端口    目的端口号。 这在终点交付报文时必须要使用到。</p></blockquote><blockquote><p>(3)  长度        UDP用户数据报的长度，其最小值是8（仅有首部）</p></blockquote><blockquote><p>(4)  检验和      检测UDP用户数据报在传输中是否有错。有错就丢弃。 </p></blockquote><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-8/40408471.jpg" alt=""></p><h3 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h3><p>(1).TCP是面向连接的传输层协议。</p><p>(2).TCP连接只能有两个端点，TCP是点到点的。</p><p>(3).TCP提供可靠的交付服务，保证 传输的数据无差错，不可重，有序，不丢失。</p><p>(4).TCP提供全双工通信，TCP允许通信双 方任何时间都能发送数据，因此TCP两端都设有发送和接收缓存。</p><p>(5).TCP是面向字节流的。</p><p>TCP连接的端点是Socket。Socket=（ip地址:端口号）<br>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确认</p><blockquote><p>TCP连接 ::={socket1,socket2}={(IP1:port1),(IP2,port2)}</p></blockquote><h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><h5 id="无差错等待"><a href="#无差错等待" class="headerlink" title="无差错等待"></a>无差错等待</h5><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-9/31372188.jpg" alt=""></p><h5 id="出现差错"><a href="#出现差错" class="headerlink" title="出现差错"></a>出现差错</h5><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-9/4362718.jpg" alt=""></p><p>出现差错至少等待一轮发送时间，在重新发送请求。只有在收到确认之后才会删除之前的数据包缓存。</p><h5 id="确认丢失或确认迟到"><a href="#确认丢失或确认迟到" class="headerlink" title="确认丢失或确认迟到"></a>确认丢失或确认迟到</h5><p><img src="https://pic002.cnblogs.com/images/2012/387401/2012071009004976.png" alt="image"></p><p><strong>确认和重传机制就可以在不可靠的网路上实现可靠通信</strong></p><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>在说连续ARQ协议之前，先说一下信道利用率。<br>之前我们的传输是这样子的<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-9/56973725.jpg" alt=""><br>信道利用率的公式为 信道利用率U = TD / (TD + RTT + TA)</p><p>这样的信道利用率太低，很多时间都在等待确认的时候。所以出现了流水线传输（高信道利用率）。<br>就类似于这样子<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=410391870,930934059&amp;fm=27&amp;gp=0.jpg" alt="image"><br>一次性发送很多，再去等待确认。一般采用累计确认的方法，就是对到达的最后一个分组进行确认。<br>连续ARQ指的就是发送方维持的发送窗口，把位于窗口内的5个分组都发送出去，而不需要等待对方的确认。<br><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916130460.png" alt="image"></p><h3 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h3><p><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916030558.png" alt="image"></p><ul><li>源端口和目的端口:各占 2 字节.端口是传输层与应用层的服务接口.传输层的复用和分用功能都要通过端口才能实现</li><li>序号:　　占 4 字节.TCP 连接中传送的数据流中的每一个字节都编上一个序号.序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</li><li>确认号:　　占 4 字节,是期望收到对方的下一个报文段的数据的第一个字节的序号</li><li>数据偏移/首部长度:　　占 4 位,它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远.“数据偏移”的单位是 32 位字(以 4 字节为计算单位)</li><li>保留:　　占 6 位,保留为今后使用,但目前应置为 0</li><li>紧急URG:　　当 URG=1 时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)</li><li>确认ACK:　　只有当 ACK=1 时确认号字段才有效.当 ACK=0 时,确认号无效</li><li>PSH(PuSH):　　接收 TCP 收到 PSH = 1 的报文段,就尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付</li><li>RST (ReSeT):　　当 RST=1 时,表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）,必须释放连接,然后再重新建立运输连接</li><li>同步 SYN:　　同步 SYN = 1 表示这是一个连接请求或连接接受报文</li><li>终止 FIN:　　用来释放一个连接.FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接</li><li>检验和:　　占 2 字节.检验和字段检验的范围包括首部和数据这两部分.在计算检验和时,要在 TCP 报文段的前面加上 12 字节的伪首部</li><li>紧急指针:　　占 16 位,指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）</li><li>选项:　　长度可变.TCP 最初只规定了一种选项,即最大报文段长度 MSS.MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节.” [MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度.数据字段加上 TCP 首部才等于整个的 TCP 报文段]</li><li>填充:　　这是为了使整个首部长度是 4 字节的整数倍</li><li>在其中ACK应该和SYN放在一起学习<blockquote><p>ACK：确认 当ACK=1时，字段有效，ACK=0时，字段无效。<br>SYN：同步。<br>当SYN=1而ACK=0时，请求连接。当SYN=1，ACK=1时同意连接</p></blockquote></li></ul><h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><p>主要使用的是滑动窗口，主要实现如下：</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916135320.png" alt="image"></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916140463.png" alt="image"></h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916141121.png" alt="image"></h2><p><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916144958.png" alt="image"></p><p>特点:</p><ul><li>以字节为单位的滑动窗口</li><li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）</li></ul><p>要求:</p><ul><li>TCP 标准没有规定对不按序到达的数据应如何处理.通常是先临时存放在接收窗口中,等到字节流中所缺少的字节收到后,再按序交付上层的应用进程</li><li>TCP 要求接收方必须有累积确认的功能,这样可以减小传输开销</li></ul><p>还有一个就是选择确认SACK，就是说比如之前发送了这样的数据包</p><blockquote><p>[1,2,3][4,5,6]…[10,11,12]</p></blockquote><p>从上图我们可以看出丢失了[7,8,9]这几个数据包，下次应该从6开始重新发，但是[10,11,12]都已经接收了，需要把这些已经接收了的数据告诉发送法，不用在发送这些数据包了。</p><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>流量控制就是让发送方的数据不要太快，要让接收方来得及接收<br>在A向B发送数据，建立连接的时候。B就告诉了A。它的接收窗口（rwnd）的大小。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>拥塞控制的原理：就是网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这就是拥塞。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533786273784&amp;di=3c295c623aa38e1c1af1f0a705e500b4&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.elecfans.com%2Fbaike%2FUploadPic%2F2010-3%2F2010318145847583.JPG" alt="image"></p><p>拥塞控制的几个方法：发送方维持一个拥塞窗口，拥塞窗口取决于网络的拥塞程度，一直在动态变化着。发送方让自己的发送窗口等于拥塞窗口。<br>网络没有出现拥塞，拥塞窗口就大一点。出现就小一点。</p><p>慢开始就是由小到大逐渐增大发送窗口。每次加倍。</p><p>拥塞避免就是让拥塞窗口cwnd缓慢的增大，每经过一个往返时间RTT就把发送方的拥塞窗口加一，而不是加倍。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533786273784&amp;di=c24f0037bdc4a58b1abdec5415a424a2&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo2%2F98782a32beaf43c58acb22460859a38e.gif" alt="image"></p><p>快重传和快恢复：</p><p>快重传：一连收到三个重复确认的请求之后，就立即重传未被确认的报文段<br><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3472718141,1456460351&amp;fm=27&amp;gp=0.jpg" alt="image"></p><p>快恢复：当发送方接收到了三个重复请求之后，就执行“乘法减小”算法，把慢开始门限减半，而不是像慢开始降为1。</p><p>发送方窗口的上限值=Min[rend,cwnd]；发送方的发送窗口一定不能超过对方给出的接收窗口值。</p><h3 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h3><p>这个问题就比较经典了。主要就是连接时候的三次握手和断开连接的四次挥手协议。</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916204517.jpg" alt="image"></p><p>步骤:</p><ul><li>A 的 TCP 向 B 发出连接请求报文段,其首部中的同步位 SYN = 1,并选择序号 seq = x,表明传送数据时的第一个数据字节的序号是 x</li><li>B 的 TCP 收到连接请求报文段后,如同意,则发回确认(B 在确认报文段中应使 SYN = 1,使 ACK = 1,其确认号ack = x﹢1,自己选择的序号 seq = y)</li><li>A 收到此报文段后向 B 给出确认,其 ACK = 1,确认号 ack = y﹢1(A 的 TCP 通知上层应用进程,连接已经建立,B 的 TCP 收到主机 A 的确认后,也通知其上层应用进程：TCP 连接已经建立)<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4></li></ul><p><img src="https://pic002.cnblogs.com/images/2012/387401/2012070916205749.jpg" alt="image"></p><p>步骤:</p><ul><li>数据传输结束后,通信的双方都可释放连接.现在 A 的应用进程先向其 TCP 发出连接释放报文段,并停止再发送数据,主动关闭 TCP 连接(A 把连接释放报文段首部的 FIN = 1,其序号seq = u,等待 B 的确认)</li><li>B 发出确认,确认号 ack = u＋1,而这个报文段自己的序号 seq = v(TCP 服务器进程通知高层应用进程.从 A 到 B 这个方向的连接就释放了,TCP 连接处于半关闭状态.B 若发送数据,A 仍要接收)</li><li>若 B 已经没有要向 A 发送的数据,其应用进程就通知 TCP 释放连接</li><li>A 收到连接释放报文段后,必须发出确认,在确认报文段中 ACK = 1,确认号 ack=w﹢1,自己的序号 seq = u + 1</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用户数据报协议UDP&quot;&gt;&lt;a href=&quot;#用户数据报协议UDP&quot; class=&quot;headerlink&quot; title=&quot;用户数据报协议UDP&quot;&gt;&lt;/a&gt;用户数据报协议UDP&lt;/h3&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络基础" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTTP面试考点</title>
    <link href="http://yoursite.com/2018/08/09/HTTP%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/"/>
    <id>http://yoursite.com/2018/08/09/HTTP面试考点/</id>
    <published>2018-08-09T09:39:01.000Z</published>
    <updated>2018-08-09T09:40:26.264Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><h3 id="Http与Https的区别"><a href="#Http与Https的区别" class="headerlink" title="Http与Https的区别"></a>Http与Https的区别</h3><ul><li>HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头</li><li>HTTP 是不安全的，而 HTTPS 是安全的</li><li>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</li><li>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</li><li>HTTP 无法加密，而HTTPS 对传输的数据进行加密</li><li>HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书<h3 id="什么是Http协议无状态协议-怎么解决Http协议无状态协议"><a href="#什么是Http协议无状态协议-怎么解决Http协议无状态协议" class="headerlink" title="什么是Http协议无状态协议?怎么解决Http协议无状态协议?"></a>什么是Http协议无状态协议?怎么解决Http协议无状态协议?</h3></li></ul><p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息</p><ul><li>也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。</li><li>可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。</li></ul><h3 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h3><p>上面这个图片具体解析了HTTPS的一个传输过程<br>具体的步骤如下：</p><ul><li>一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；</li><li>二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；</li><li>三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；</li><li>四、发送给服务端，此时只有服务端（RSA私钥）能解密。</li><li>五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-9/43312410.jpg" alt=""><h3 id="URI、URL、URN"><a href="#URI、URL、URN" class="headerlink" title="URI、URL、URN"></a>URI、URL、URN</h3></li></ul><h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。<br>URI一般由三部组成：</p><ul><li>①访问资源的命名机制</li><li>②存放资源的主机名</li><li>③资源自身的名称，由路径表示，着重强调于资源。<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：</li><li>①协议(或称为服务方式)</li><li>②存有该资源的主机IP地址(有时也包括端口号)</li><li>③主机资源的具体地址。如目录和文件名等</li></ul><h4 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h4><p>RN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:<a href="mailto:java-net@java.sun.com" target="_blank" rel="noopener">java-net@java.sun.com</a>。</p><h4 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h4><p>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</p><h4 id="在java中的区别"><a href="#在java中的区别" class="headerlink" title="在java中的区别"></a>在java中的区别</h4><p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。</p><p>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。</p><p>相反的是，URL类可以打开一个到达资源的流。</p><h3 id="常见的HTTP方法有哪些"><a href="#常见的HTTP方法有哪些" class="headerlink" title="常见的HTTP方法有哪些"></a>常见的HTTP方法有哪些</h3><blockquote><p>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</p></blockquote><blockquote><p>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</p></blockquote><blockquote><p>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</p></blockquote><blockquote><p>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</p></blockquote><blockquote><p>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</p></blockquote><blockquote><p>OPTIONS：查询相应URI支持的HTTP方法。</p></blockquote><h3 id="HTTP请求报文与响应报文格式"><a href="#HTTP请求报文与响应报文格式" class="headerlink" title="HTTP请求报文与响应报文格式"></a>HTTP请求报文与响应报文格式</h3><p><img src="https://segmentfault.com/img/remote/1460000013229039?w=735&amp;h=272" alt="image"><br>a、请求行：包含请求方法、URI、HTTP版本信息</p><p>b、请求首部字段</p><p>c、请求内容实体</p><p>d、空行<br><img src="https://segmentfault.com/img/remote/1460000013229040?w=724&amp;h=260" alt="image"><br>a、状态行：包含HTTP版本、状态码、状态码的原因短语</p><p>b、响应首部字段</p><p>c、响应内容实体</p><p>d、空行</p><h3 id="常见的HTTP相应状态码"><a href="#常见的HTTP相应状态码" class="headerlink" title="常见的HTTP相应状态码"></a>常见的HTTP相应状态码</h3><h4 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h4><pre><code>200：请求被正常处理204：请求被受理但没有资源可以返回206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</code></pre><h4 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h4><pre><code>301：永久性重定向302：临时重定向303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上304：发送附带条件的请求时，条件不满足时返回，与重定向无关307：临时重定向，与302类似，只是强制要求使用POST方法</code></pre><h4 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h4><pre><code>400：请求报文语法有误，服务器无法识别401：请求需要认证403：请求的对应资源禁止被访问404：服务器无法找到对应资源</code></pre><h4 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h4><pre><code>500：服务器内部错误503：服务器正忙</code></pre><h3 id="HTTP优化方案"><a href="#HTTP优化方案" class="headerlink" title="HTTP优化方案"></a>HTTP优化方案</h3><ul><li>TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。</li><li>内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。<br>压缩：将文本数据进行压缩，减少带宽</li><li>SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速</li><li>TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。</li><li><h3 id="为什么TCP需要第三次握手？"><a href="#为什么TCP需要第三次握手？" class="headerlink" title="为什么TCP需要第三次握手？"></a>为什么TCP需要第三次握手？</h3>三次握手是建立连接的过程，主要第一次是客户端请求服务端通信，第二次是服务端相应请求，接收通信。第三次就开始传输数据。<br>第三次的意义就在于，为了防止之前的连接请求报文段突然又传送到了服务器，因而发生错误。所以第三次请求。<blockquote><p>这是服务器的一种异常状况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才能到达B。 本来这是一个早已失效的报文段。   但B收到此失效的连接请求报文段后，就误认为A又发出了一次新的连接请求。    于是又向A发出确认报文段，同意建立连接。    假定不采用三次握手，那么只要B发出确认，新的连接就建立了。  由于现在A并没有发出建立连接的请求，因此不会理财B的确认，也不会向B发送数据。 但B却以为新的运输连接已经建立了，并一直等待A发来数据。 B的许多资源就这样浪费了。</p></blockquote></li></ul><h3 id="访问一个URl会发生什么？"><a href="#访问一个URl会发生什么？" class="headerlink" title="访问一个URl会发生什么？"></a>访问一个URl会发生什么？</h3><p>这个图是我在阅读深入分析Java Web技术内幕时候的一张图片，其实很好。这个其实比较像我们日常生活中经常使用的网页访问发生的过程。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-9/55123824.jpg" alt=""></p><p>首先抛出一个问题：我们在访问 <a href="http://www.jh0904.top/" target="_blank" rel="noopener">www.jh0904.top</a>,会发生什么？</p><p>过程的大概路径应该是这样子的：</p><ol><li>访问DNS域名服务器</li><li>发起连接（TCP的3次握手）</li><li>建立TCP连接后发起http请求</li><li>服务器响应http请求，浏览器得到html代码</li><li>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络基础" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>今天谈谈正则表达式</title>
    <link href="http://yoursite.com/2018/08/08/%E4%BB%8A%E5%A4%A9%E8%B0%88%E8%B0%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/08/今天谈谈正则表达式/</id>
    <published>2018-08-08T14:17:53.000Z</published>
    <updated>2018-08-08T14:45:55.942Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正则表达式的概述"><a href="#正则表达式的概述" class="headerlink" title="正则表达式的概述"></a>正则表达式的概述</h3><p> 编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p><p>就像我们在数据库中的“*”。</p><h3 id="正则表达式的基本语法"><a href="#正则表达式的基本语法" class="headerlink" title="正则表达式的基本语法"></a>正则表达式的基本语法</h3><p> 正则表达式是由 == 原意文本字符 == (a,b,c,1,2,3等)和 == 元字符 == ( . * ? 等)组成来匹配指定内容的表达式。</p><h4 id="原意文本字符"><a href="#原意文本字符" class="headerlink" title="原意文本字符"></a>原意文本字符</h4><p> 原意文本其实很好理解，就是我们平时经常使用的意义。比如说</p><ul><li>a在正则中表示匹配a这个字符</li><li>1在正则中表示匹配1这个字符<br>原意文本就是没有没有特殊的含义。<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4>元字符指在正则表达式中有特殊含义的专用字符，比如：</li></ul><table><thead><tr><th>元字符</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>\</td><td>转义字符，将后一个字符标记为特殊字符或将元字符转为原意字符</td><td>1、\表示匹配原意字符\； 2、.表示匹配英文句号“.” ； 3、\d表示匹配数字。</td></tr><tr><td>.</td><td>匹配除换行(\n)以外的所有字符</td><td>abc.能匹配到“abc”后面的那个字符，比如“abc”后面的空格、字母、数字、汉字等</td></tr><tr><td>^</td><td>匹配字符串的开始位置，在集合([])中表示“非”</td><td>1、^\d\d\d能匹配“123”、“666”等，但不能匹配“a123”、“b123”、“-123”等；<br> 2、^\w+\b表示匹配第一个单词；<br> 3、[^ajl]匹配除了“a”、“j”、“l”以外的任意字符。</td></tr><tr><td>$</td><td>匹配字符串的结束位置</td><td>^\d\d.\d\d$能匹配“12.01”和“00.00”等，但不能匹配“0.00”、“12.0”、“123.00”等</td></tr><tr><td>?</td><td>匹配前面子表达式0次或一次</td><td>good?可以匹配“goo”和“good”等，但是不能匹配“go”等</td></tr><tr><td>+</td><td>匹配1或多个正好在它之前的那个字符。</td><td>正则表达式9+匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。</td></tr><tr><td>*</td><td>匹配前面子表达式0次或多次</td><td>zo*能匹配“zo”、“zoo”、“zooo” </td></tr><tr><td>()</td><td>标记一个子表达式的开始和结束位置，其结束符号“)”是元字符</td><td></td></tr><tr><td>[</td><td>字符组的起始符号，其结束符号“]”不是元字符</td><td></td></tr><tr><td>{</td><td>标记限定符的开始，其结束符号“}”不是元字符</td><td></td></tr><tr><td> \</td><td>表示“或”</td><td>1、(a\b\c)匹配“a”、“b”、“c”之中的一个；</td></tr></tbody></table><p>如果要匹配元字符本身可以用\来取消元字符的特殊含义，比如.匹配英文句号”.”；*匹配“*”本身；+匹配“+”本身……<br><strong>常用表达式举例</strong></p><table><thead><tr><th>表达式</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td> \w</td><td>匹配字母、数字、下划线</td><td>abc\w表示匹配“abc”开头并且后面跟着一个字母或数字或下划线的字符串</td></tr><tr><td> \W</td><td>匹配非字母、非数字、非下划线</td><td>\W相当于[^\w]</td></tr><tr><td>\d</td><td>匹配数字</td><td>\d\d\d表示匹配3个连续的数字</td></tr><tr><td> \D</td><td>匹配非数字</td><td>\D相当于[^\d]</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td><td>\bgo\w*\b表示匹配“go”开头的一个单词</td></tr><tr><td> \B</td><td>匹配非单词的开始或结束</td><td>\B相当于[^\b]</td></tr><tr><td>\s</td><td>匹配任何空白字符，如回车、空格、制表符等</td><td>\s相当于[\f\n\r\t\v]</td></tr><tr><td>\S</td><td>匹配任何非空白字符</td><td>\S相当于[^\s]</td></tr><tr><td>{n}</td><td>匹配前面子表达式n次</td><td>\d{11}表示匹配连续的11个数字</td></tr><tr><td>{n,m}</td><td>匹配前面子表达式n到m次</td><td>\d{7,11}表示匹配连续的7-11个数字</td></tr><tr><td>{n,}</td><td>匹配前面子表达式n次以上</td><td>\d{5,}表示匹配连续的5个以上的数字</td></tr><tr><td> [xyz]</td><td>表示字符集，匹配所包含的任意一个字符</td><td>1、[abc]能匹配“a”或“b”或“c”；<br>2、[!?<em>.]表示匹配“!”、“?”、“</em>”、“.”中的任意一个；<br>3、[^0-9]匹配所有非0到9的字符，相当于\D。</td></tr><tr><td>[a-z]</td><td>表示字符范围，能匹配范围内的任意一个字符</td><td>1、[a-z]能匹配26个小写字母中任意字母；<br>2、[0-9]能匹配0到9的任意数字，和\d一样的效果；<br>3、[1-9]能匹配1到9的任意数字；<br> 4、[\u4e00-\u9fa5]能匹配所有汉字。</td></tr><tr><td>(abc)</td><td>组合，将几个项组合成为一个单元，可以对这个单元使用限定符</td><td>(\.[a-z]+)+$可以匹配“.com”、“.net”、“.com.cn”等结尾的字符</td></tr></tbody></table><p><strong>运算符优先级</strong></p><p>正则表达式是从左向右进行运算的，并遵循优先级顺序。优先级顺序如下表（先高后低）：</p><table><thead><tr><th>运算符</th><th>优先级</th><th>说明</th></tr></thead><tbody><tr><td> \</td><td>最高</td><td>转义字符</td></tr><tr><td>() (?:) (?=) []</td><td>高</td><td>圆括号和方括号</td></tr><tr><td> * + ? {n} {n,} {n,m}</td><td>中</td><td>限定符</td></tr><tr><td>^ $ \任何元字符 任何字符</td><td>低</td><td>定位点和序列（位置和顺序）</td></tr><tr><td>\</td><td>最低</td><td></td><td>选择符“或”</td></tr></tbody></table><h3 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h3><h4 id="汉字"><a href="#汉字" class="headerlink" title="汉字"></a>汉字</h4><blockquote><p> [\u4e00-\u9fa5] </p></blockquote><p> //中文ACALL码的范围</p><h4 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h4><p> 邮箱这个比较重要了，一般都会用到。就比如我们在写表单校验的时候。<br>  邮箱一般为“名称@域名”的格式，由于名称部分格式太多（有些邮箱名称允许有中文）不好限制，所以本文只验证名称和域名有“英文字母”、“数字”、“下划线”、“中划线(-)”、“英文句号(.)”的邮箱。</p><ul><li>\w可以匹配“英文字母、数字、下划线”</li><li>.可以匹配英文句号“ . ”</li><li>-可以匹配原意字符“ - ”本身</li><li>@可以匹配原意字符“ @ ”本身</li><li>([.-]\w+)可以匹配“ photo-google ”中的“ -google ”、“ photo.google ”中的“ .google ”</li><li>(.[a-zA-z0-9-]+)+可以匹配“ .com ”、“ .com.cn ”等</li><li></li></ul><blockquote><p>  表达式：^\w+([.-]\w+)*@[\w-]+(.[a-zA-z0-9-]+)+$ </p></blockquote><h4 id="手机号"><a href="#手机号" class="headerlink" title="手机号"></a>手机号</h4><p> 于号码段在不断更新，本文只验证“13”、“15”、“17”、“18”开头后面有9个数字的号码（如表达式1）</p><blockquote><p> 表达式1：^(13|15|17|18)\d{9}$ </p></blockquote><blockquote><p>表达式2：^(13[0-9]|15[0-9]|17[07]|18[05689])\d{8}$ </p></blockquote><h4 id="座机号"><a href="#座机号" class="headerlink" title="座机号"></a>座机号</h4><p>  座机号一般为“区号[-]号码”的格式，如果区号部分是3位则号码部分为8位，如021-67678989、02167678989；如果区号部分是4位则号码部分是7位，如0765-6767676、02167678989。</p><blockquote><p> 表达式1：^\d{3}-?\d{8}|\d{4}-?\d{7}$ </p></blockquote><blockquote><p>表达式2：^(\d{3}-?\d{8})|(\d{4}-?\d{7})$（由于选择符“|”优先级最低，所以组合符号“()”加与不加都行） </p></blockquote><h4 id="身份证"><a href="#身份证" class="headerlink" title="身份证"></a>身份证</h4><p>  身份证号码是由18个字符组成，前17个必须为数字(\d)，第一位不能为0([1-9])，最后一位可能是数字(\d)也可能是“x/X”([xX])。 </p><blockquote><p> 表达式：^[1-9]\d{16}[\dxX]$ </p></blockquote><h3 id="正则表达式匹配规则"><a href="#正则表达式匹配规则" class="headerlink" title="正则表达式匹配规则"></a>正则表达式匹配规则</h3><p> 　一切从最基本的开始。模式，是正规表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：</p><blockquote><p>^once</p></blockquote><p>　　这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。</p><blockquote><p>bucket$</p></blockquote><p>这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符^和$同时使用时，表示精确匹配（字符串与模式一样）。例如：</p><blockquote><p>　^bucket$</p></blockquote><p>　　只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式</p><blockquote><p>once</p></blockquote><p>与字符串There once was a man from NewYorkWho kept all of his cash in a bucket.是匹配的。</p><p>　　在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些??表符等），要用到转义序列。所有的转义序列都用反斜杠(\)打头。制表符的转义序列是：\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：</p><blockquote><p>　^\t</p></blockquote><p>类似的，用\n表示“新行”，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\表示，句号.用.表示，以此类推。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;正则表达式的概述&quot;&gt;&lt;a href=&quot;#正则表达式的概述&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的概述&quot;&gt;&lt;/a&gt;正则表达式的概述&lt;/h3&gt;&lt;p&gt; 编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之序列化是什么鬼？</title>
    <link href="http://yoursite.com/2018/08/05/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/08/05/Java基础之序列化是什么鬼？/</id>
    <published>2018-08-05T13:29:41.000Z</published>
    <updated>2018-08-05T13:30:30.933Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><p>java的序列化和反序列化是java中很常见的一种。我们其实平时对集合、线程或是反射什么了解比较多，其实序列化在我们编写java程序中也起很大的作用。序列化的主要工作是把一个java对象变成二进制的字节流，反序列化就是把二进制字节流变成java对象。接下来我们来看一下具体的操作。</p><h3 id="序列化和反序列化的概念"><a href="#序列化和反序列化的概念" class="headerlink" title="序列化和反序列化的概念"></a>序列化和反序列化的概念</h3><ul><li><strong>对象的序列化</strong>：把对象转换为字节序列的过程称为对象的序列化。</li><li><strong>对象的反序列化</strong>：把字节序列恢复为对象的过程称为对象的反序列化。</li></ul><p>对象序列化的作用：其实序列化主要有两个用途：</p><ol><li>把对象的字节序列化永久的保存到硬盘上，通常保存在一个文件中。</li><li>在网络上传输对象的字节序列。</li></ol><p>把对象保存到文件中，离开内存，长住物理硬盘。常见的应用就是Web服务器中的Session对象，当10万用户并发访问时，就有可能出现10万个session对象，内存不够，所以先保存一些到硬盘中去。需要的时候，再拿出来还原到内存中。</p><p>当两个进程在进行远程通信的时候，彼此可以传输数据。但是不论什么类型的数据，都以二进制序列的形式在网络上传输。如下图：</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6UJdaLSwqy1mO5WOGibSkJwZbicsDuZMMich29LAeL09SNZwVwickEbjX2dJBP3PsV4IOaDf9XYYnN4ibjw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="序列化"></p><p>从某种意义上来说，可以让java对象跨越时间和空间，获得永生。但是永生也是有代价的，就是必须使用java语言（哈哈，java序列化肯定是java语言）。</p><h3 id="Java中的序列化API"><a href="#Java中的序列化API" class="headerlink" title="Java中的序列化API"></a>Java中的序列化API</h3><p> <strong>java.io.ObjectOutputStream</strong>代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p><p><strong>java.io.ObjectInputStream</strong>代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</p><p>只有实现了Serializable或Externalizable接口的类的对象才能被序列化。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。<br><strong>对象序列化包括如下步骤：</strong></p><ol><li>创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；</li><li>通过对象输出流的writeObject()方法写对象.</li></ol><p><strong>对象反序列化的步骤：</strong></p><ol><li>创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流</li><li>通过对象输入流的readObject()方法读取对象。</li></ol><p>代码实现：<br>定义一个POJO类，实现Serializable接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day02;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ClassName: Person&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description:测试对象序列化和反序列化&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0 V</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2014-6-9 下午02:33:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5809782578272943999L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">package</span> day02;</span><br><span class="line"><span class="keyword">import</span> day02.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.text.MessageFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ClassName: TestObjSerializeAndDeserialize&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description: 测试对象的序列化和反序列&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0 V</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2014-6-9 下午03:17:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjSerializeAndDeserialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">SerializePerson();<span class="comment">//序列化Person对象</span></span><br><span class="line">Person p = DeserializePerson();<span class="comment">//反序列Perons对象</span></span><br><span class="line">System.out.println(MessageFormat.format(<span class="string">"name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;"</span>,</span><br><span class="line">p.getName(), p.getAge(), p.getSex()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MethodName: SerializePerson</span></span><br><span class="line"><span class="comment"> * Description: 序列化Person对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SerializePerson</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException,</span></span><br><span class="line"><span class="function">IOException </span>&#123;</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"gacl"</span>);</span><br><span class="line">person.setAge(<span class="number">25</span>);</span><br><span class="line">person.setSex(<span class="string">"男"</span>);</span><br><span class="line"><span class="comment">// ObjectOutputStream 对象输出流，将Person对象存储到E盘的Person.txt文件中，完成对Person对象的序列化操作</span></span><br><span class="line">ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line"><span class="keyword">new</span> File(<span class="string">"D:/Person.txt"</span>)));</span><br><span class="line">oo.writeObject(person);</span><br><span class="line">System.out.println(<span class="string">"Person对象序列化成功！"</span>);</span><br><span class="line">oo.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MethodName: DeserializePerson</span></span><br><span class="line"><span class="comment"> * Description: 反序列Perons对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Person <span class="title">DeserializePerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception, IOException </span>&#123;</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line"><span class="keyword">new</span> File(<span class="string">"D:/Person.txt"</span>)));</span><br><span class="line">Person person = (Person) ois.readObject();</span><br><span class="line">System.out.println(<span class="string">"Person对象反序列化成功！"</span>);</span><br><span class="line"><span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果的展示：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-5/36273983.jpg" alt=""><br>这个是程序运行的结果，主要是一些字节码的文件。打开看一下，就是这个样子的：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-5/91761324.jpg" alt=""></p><p>大家会发现什么都看不懂，其实很正常，给计算机看的又不是给我们看的。我们可以看反序列化之后，就成为了一个简单的对象。是不是很酷！</p><h3 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h3><p>serialVersionUID表示<strong>：“串行化版本统一标识符”</strong>（serial version universal identifier），简称UID</p><p>serialVersionUID必须定义成下面这种形式：static final long serialVersionUID = xxxL;</p><p>serialVersionUID 用来表明类的不同版本间的兼容性。有两种生成方式： 一个是默认的1L；另一种是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段 。。</p><p>如果你添加了serialVersionUID，在反序列旧有实例时，新添加或更改的字段值将设为初始化值（对象为null，基本类型为相应的初始默认值），字段被删除将不设置。 </p><p>具体的还是代码演示一下具有说服力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerialversionUID</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SerializeCustomer();<span class="comment">// 序列化Customer对象</span></span><br><span class="line">        Customer customer = DeserializeCustomer();<span class="comment">// 反序列Customer对象</span></span><br><span class="line">        System.out.println(customer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MethodName: SerializeCustomer </span></span><br><span class="line"><span class="comment">     * Description: 序列化Customer对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SerializeCustomer</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException,</span></span><br><span class="line"><span class="function">            IOException </span>&#123;</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer(<span class="string">"gacl"</span>,<span class="number">25</span>);</span><br><span class="line">        <span class="comment">// ObjectOutputStream 对象输出流</span></span><br><span class="line">        ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                <span class="keyword">new</span> File(<span class="string">"E:/Customer.txt"</span>)));</span><br><span class="line">        oo.writeObject(customer);</span><br><span class="line">        System.out.println(<span class="string">"Customer对象序列化成功！"</span>);</span><br><span class="line">        oo.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MethodName: DeserializeCustomer </span></span><br><span class="line"><span class="comment">     * Description: 反序列Customer对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Customer <span class="title">DeserializeCustomer</span><span class="params">()</span> <span class="keyword">throws</span> Exception, IOException </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                <span class="keyword">new</span> File(<span class="string">"E:/Customer.txt"</span>)));</span><br><span class="line">        Customer customer = (Customer) ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">"Customer对象反序列化成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ClassName: Customer&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description: Customer实现了Serializable接口，可以被序列化&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xudp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0 V</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2014-6-9 下午04:20:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Customer类中没有定义serialVersionUID</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @MethodName toString</span></span><br><span class="line"><span class="comment">     * @Description 重写Object类的toString()方法</span></span><br><span class="line"><span class="comment">     * @author xudp</span></span><br><span class="line"><span class="comment">     * @return string</span></span><br><span class="line"><span class="comment">     * @see java.lang.Object#toString()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name="</span> + name + <span class="string">", age="</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面的Customer类没有定义serialVersionUID，执行序列化操作是没有问题的，但是如果我们对这个类进行一些修改。比如新添加一个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Customer类中没有定义serialVersionUID</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新添加的sex属性</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age,String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @MethodName toString</span></span><br><span class="line"><span class="comment">     * @Description 重写Object类的toString()方法</span></span><br><span class="line"><span class="comment">     * @author xudp</span></span><br><span class="line"><span class="comment">     * @return string</span></span><br><span class="line"><span class="comment">     * @see java.lang.Object#toString()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name="</span> + name + <span class="string">", age="</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们新添加一个属性sex，但是现在序列化的同时出现了错误。</p><blockquote><p> Exception in thread “main” java.io.InvalidClassException: Customer; <br><br>local class incompatible: <br><br> stream classdesc serialVersionUID = -88175599799432325, <br><br>local class serialVersionUID = -5182532647273106745<br></p></blockquote><p>其实出现错误的原因是这样的：就是文件中和classpath中的class，现在不一致了。处于安全的考虑，程序此时就出现了错误。并且拒绝载入。如果想解决这种问题，就去自己指定一个serialVersionUID。只要我们的文件进行了修改，得到的UID就不同，可以保证就算有多个类，我们的UID也一致。显示定义的用途已经在下面写了。希望对大家有一点帮助。</p><h3 id="serialVersionUID的取值"><a href="#serialVersionUID的取值" class="headerlink" title="serialVersionUID的取值"></a>serialVersionUID的取值</h3><p>　serialVersionUID的取值是Java运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。<br>　　类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。</p><p>　　显式地定义serialVersionUID有两种用途：<br>　　　　1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；<br>　　　　2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之IO这个硬骨头（二）</title>
    <link href="http://yoursite.com/2018/08/04/Java%E5%9F%BA%E7%A1%80%E4%B9%8BIO%E8%BF%99%E4%B8%AA%E7%A1%AC%E9%AA%A8%E5%A4%B4%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/04/Java基础之IO这个硬骨头（二）/</id>
    <published>2018-08-04T12:32:19.000Z</published>
    <updated>2018-08-05T00:00:45.998Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><p>上一次基本讲解了一下IO中字节流的一些知识点和操作，总的来说字符流的操作和字节流差不多，关键在于编码集的一些问题。这篇文章就主要讲解java中字符流和字符集。</p><h3 id="字符集的操作"><a href="#字符集的操作" class="headerlink" title="字符集的操作"></a>字符集的操作</h3><h4 id="字符集是什么尼？"><a href="#字符集是什么尼？" class="headerlink" title="字符集是什么尼？"></a>字符集是什么尼？</h4><p>字符集就是是各种文字和符号的总称，简单来说就是由字符和对应的数值组成的一张表。 推荐一篇文章    <a href="https://blog.csdn.net/qq_28098067/article/details/53486032" target="_blank" rel="noopener">字符集详解（一看就懂系列）</a> ，这篇文章详细的介绍了字符集的一些知识，以及字符集的演变。</p><h4 id="常见的字符集："><a href="#常见的字符集：" class="headerlink" title="常见的字符集："></a>常见的字符集：</h4><p>下面用一个图片来解释一下简单的字符集：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-4/87471290.jpg" alt=""><br>这张图介绍了常用的字符集。</p><h4 id="java中的CharSet"><a href="#java中的CharSet" class="headerlink" title="java中的CharSet"></a>java中的CharSet</h4><p>这些知识使我们从网上查到的，我们在代码中如何知道有什么字符集尼？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    SortedMap&lt;String, Charset&gt; stringCharsetSortedMap = Charset.availableCharsets ();  </span><br><span class="line">   Set&lt;Map.Entry&lt;String, Charset&gt;&gt; entries = stringCharsetSortedMap.entrySet ();  </span><br><span class="line"> <span class="keyword">for</span> (Map.Entry&lt;String, Charset&gt; entry : entries) &#123;  </span><br><span class="line">        System.out.println (entry.getKey () + <span class="string">"---"</span> \+ entry.getValue ());  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这样，我们可以查找出所有的字符集。</p><h4 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h4><p>对于大多数程序猿来说，乱码都是经常发生的事情，但是为什么会乱码？<br>其实这个问题很简单，就像上面编码表的那张图片一样，就是因为编码和解码用的码制不一样，大家可以看下面的例子，用GBK进行编码，用GBK解码，就可以解码出数据，但是使用UTF-8进行数据的解码，就出现问题，此时的数据就成了乱码，我们就无法解析了。<br>所以说，只要编码和解码的码制一样，就不会乱码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Test  </span><br><span class="line">public <span class="keyword">void</span> test6() throws CharacterCodingException &#123;  </span><br><span class="line">    Charset gbk = Charset.forName (<span class="string">"GBK"</span>);  </span><br><span class="line">   <span class="comment">//获取编码器  </span></span><br><span class="line">   CharsetEncoder ce = gbk.newEncoder ();  </span><br><span class="line">   <span class="comment">//获取解码器  </span></span><br><span class="line">   CharsetDecoder cd = gbk.newDecoder ();  </span><br><span class="line"></span><br><span class="line">   CharBuffer allocate = CharBuffer.allocate (<span class="number">1024</span>);  </span><br><span class="line">   allocate.put (<span class="string">"爱生活爱java"</span>);  </span><br><span class="line">   allocate.flip ();  </span><br><span class="line">   <span class="comment">//编码  </span></span><br><span class="line">   ByteBuffer encode = ce.encode (allocate);  </span><br><span class="line"> <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;  </span><br><span class="line">        System.out.println (encode.get ());  </span><br><span class="line">   &#125;  </span><br><span class="line">    <span class="comment">//解码  </span></span><br><span class="line">   encode.flip ();  </span><br><span class="line">   CharBuffer decode = cd.decode (encode);  </span><br><span class="line">   System.out.println (decode.toString ());  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   System.out.println (<span class="string">"------------------------"</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   encode.flip ();  </span><br><span class="line">   Charset utf = Charset.forName (<span class="string">"UTF-8"</span>);  </span><br><span class="line">   CharBuffer decode1 = utf.decode (encode);  </span><br><span class="line">   System.out.println (decode1.toString ());  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="字符流的基本操作"><a href="#字符流的基本操作" class="headerlink" title="字符流的基本操作"></a>字符流的基本操作</h3><p>上面介绍了编码的一些知识点，之所以解释这个是因为字符流其实就是编码表加上字节流，下来介绍字符流的操作吧。</p><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>转换流是什么尼？其实因为字节流处理中文不是很方便，有时候需要字符流处理文字，所以出现了转换流。转换流的作用就是把一个字节流转换成一个字符流。</p><p>转换流其实本质上就是一个字节流加上编码表</p><p>InputStreamReader代码展示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InputStreamReader(InputStream is):用默认的编码读取数据</span></span><br><span class="line"><span class="comment"> * InputStreamReader(InputStream is,String charsetName):用指定的编码读取数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="comment">// InputStreamReader isr = new InputStreamReader(new FileInputStream(</span></span><br><span class="line"><span class="comment">// "osw.txt"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InputStreamReader isr = new InputStreamReader(new FileInputStream(</span></span><br><span class="line"><span class="comment">// "osw.txt"), "GBK");</span></span><br><span class="line"></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(</span><br><span class="line"><span class="string">"osw.txt"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 一次读取一个字符</span></span><br><span class="line">int ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((ch = isr.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">System.out.print((char) ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">isr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OutputStreamWriter代码展示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OutputStreamWriter(OutputStream out):根据默认编码把字节流的数据转换为字符流</span></span><br><span class="line"><span class="comment"> * OutputStreamWriter(OutputStream out,String charsetName):根据指定编码把字节流数据转换为字符流</span></span><br><span class="line"><span class="comment"> * 把字节流转换为字符流。</span></span><br><span class="line"><span class="comment"> * 字符流 = 字节流 +编码表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamWriterDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="comment">// OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(</span></span><br><span class="line"><span class="comment">// "osw.txt")); // 默认GBK</span></span><br><span class="line"><span class="comment">// OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(</span></span><br><span class="line"><span class="comment">// "osw.txt"), "GBK"); // 指定GBK</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line"><span class="string">"osw.txt"</span>), <span class="string">"UTF-8"</span>); <span class="comment">// 指定UTF-8</span></span><br><span class="line"><span class="comment">// 写数据</span></span><br><span class="line">osw.write(<span class="string">"中国"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">osw.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>其实我们怎么创建一个字符流尼，其实上面的转换流就可以帮我们完成这个需求。但是，每次创建字符流都要先创建一个字节流，感觉很麻烦，所以就有这个流的出现—&gt;FileWriter/FileReaderd，接下来介绍一下具体的代码实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由于我们常见的操作都是使用本地默认编码，所以，不用指定编码。</span></span><br><span class="line"><span class="comment"> * 而转换流的名称有点长，所以，Java就提供了其子类供我们使用。</span></span><br><span class="line"><span class="comment"> * OutputStreamWriter = FileOutputStream + 编码表(GBK)</span></span><br><span class="line"><span class="comment"> * FileWriter = FileOutputStream + 编码表(GBK)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * InputStreamReader = FileInputStream + 编码表(GBK)</span></span><br><span class="line"><span class="comment"> * FileReader = FileInputStream + 编码表(GBK)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> /*</span></span><br><span class="line"><span class="comment"> * 需求：把当前项目目录下的a.txt内容复制到当前项目目录下的b.txt中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数据源：</span></span><br><span class="line"><span class="comment"> * a.txt -- 读取数据 -- 字符转换流 -- InputStreamReader -- FileReader</span></span><br><span class="line"><span class="comment"> * 目的地：</span></span><br><span class="line"><span class="comment"> * b.txt -- 写出数据 -- 字符转换流 -- OutputStreamWriter -- FileWriter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyFileDemo2</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// 封装数据源</span></span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line"><span class="comment">// 封装目的地</span></span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次一个字符</span></span><br><span class="line"><span class="comment">// int ch = 0;</span></span><br><span class="line"><span class="comment">// while ((ch = fr.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">// fw.write(ch);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次一个字符数组</span></span><br><span class="line">char[] chs = <span class="keyword">new</span> char[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fr.read(chs)) != <span class="number">-1</span>) &#123;</span><br><span class="line">fw.write(chs, <span class="number">0</span>, len);</span><br><span class="line">fw.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">fw.close();</span><br><span class="line">fr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是一个简单的字符流的使用方法，实现了一个文件复制的功能。我们在学习字节流的时候，就有缓冲流（BufferInputStream/BufferOutputStream）来实现数据的高速缓冲传送,其实在字符流中也有这个方法。比如（BufferedReader/BufferedWriter），下面就举一个小例子来 看一下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字符缓冲流的特殊方法：</span></span><br><span class="line"><span class="comment"> * BufferedWriter:</span></span><br><span class="line"><span class="comment"> * public void newLine():根据系统来决定换行符</span></span><br><span class="line"><span class="comment"> * BufferedReader:</span></span><br><span class="line"><span class="comment"> * public String readLine()：一次读取一行数据</span></span><br><span class="line"><span class="comment"> * 包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// write();</span></span><br><span class="line">read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> read() throws IOException &#123;</span><br><span class="line"><span class="comment">// 创建字符缓冲输入流对象</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"bw2.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// public String readLine()：一次读取一行数据</span></span><br><span class="line"><span class="comment">// String line = br.readLine();</span></span><br><span class="line"><span class="comment">// System.out.println(line);</span></span><br><span class="line"><span class="comment">// line = br.readLine();</span></span><br><span class="line"><span class="comment">// System.out.println(line);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终版代码</span></span><br><span class="line"><span class="built_in">String</span> line = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> write() throws IOException &#123;</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流对象</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bw2.txt"</span>));</span><br><span class="line"><span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">bw.write(<span class="string">"hello"</span> + x);</span><br><span class="line"><span class="comment">// bw.write("\r\n");</span></span><br><span class="line">bw.newLine();</span><br><span class="line">bw.flush();</span><br><span class="line">&#125;</span><br><span class="line">bw.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>缓冲流的具体实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * BufferedReader</span></span><br><span class="line"><span class="comment"> * 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。</span></span><br><span class="line"><span class="comment"> * 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BufferedReader(Reader in)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 创建字符缓冲输入流对象</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"bw.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="comment">// int ch = 0;</span></span><br><span class="line"><span class="comment">// while ((ch = br.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">// System.out.print((char) ch);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = br.read(chs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.print(<span class="keyword">new</span> String(chs, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字符流为了高效读写，也提供了对应的字符缓冲流。</span></span><br><span class="line"><span class="comment"> * BufferedWriter:字符缓冲输出流</span></span><br><span class="line"><span class="comment"> * BufferedReader:字符缓冲输入流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BufferedWriter:字符缓冲输出流</span></span><br><span class="line"><span class="comment"> * 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。</span></span><br><span class="line"><span class="comment"> * 可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// BufferedWriter(Writer out)</span></span><br><span class="line"><span class="comment">// BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(</span></span><br><span class="line"><span class="comment">// new FileOutputStream("bw.txt")));</span></span><br><span class="line"></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bw.txt"</span>));</span><br><span class="line"></span><br><span class="line">bw.write(<span class="string">"hello"</span>);</span><br><span class="line">bw.write(<span class="string">"world"</span>);</span><br><span class="line">bw.write(<span class="string">"java"</span>);</span><br><span class="line">bw.flush();</span><br><span class="line"></span><br><span class="line">bw.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="IO的常用的流总结"><a href="#IO的常用的流总结" class="headerlink" title="IO的常用的流总结"></a>IO的常用的流总结</h3><p>其实IO简单的字节流和字符流并不难学，总的来说就是太复杂，其实实际操作不是很困难 。现在来总结一下，我们学过的流。</p><pre><code>IO流|--字节流    |--字节输入流        InputStream            int read():一次读取一个字节            int read(byte[] bys):一次读取一个字节数组            |--FileInputStream            |--BufferedInputStream    |--字节输出流        OutputStream            void write(int by):一次写一个字节            void write(byte[] bys,int index,int len):一次写一个字节数组的一部分            |--FileOutputStream            |--BufferedOutputStream|--字符流    |--字符输入流        Reader            int read():一次读取一个字符            int read(char[] chs):一次读取一个字符数组            |--InputStreamReader                |--FileReader            |--BufferedReader                String readLine():一次读取一个字符串    |--字符输出流        Writer            void write(int ch):一次写一个字符            void write(char[] chs,int index,int len):一次写一个字符数组的一部分            |--OutputStreamWriter                |--FileWriter            |--BufferedWriter                void newLine():写一个换行符                void write(String line):一次写一个字符串</code></pre><p>在插入一个图片有助于理解和帮助。</p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-8-4/49905583.jpg" alt=""></p><p>从图中我们就可以看到清晰的一个思路，各种流及其常用的实现类，在上面都有。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之IO这个硬骨头（一）</title>
    <link href="http://yoursite.com/2018/08/01/Java%E5%9F%BA%E7%A1%80%E4%B9%8BIO%E8%BF%99%E4%B8%AA%E7%A1%AC%E9%AA%A8%E5%A4%B4%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/01/Java基础之IO这个硬骨头（一）/</id>
    <published>2018-08-01T14:37:44.000Z</published>
    <updated>2018-08-01T14:41:17.116Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><h3 id="IO的概述"><a href="#IO的概述" class="headerlink" title="IO的概述"></a>IO的概述</h3><p>首先，我们要了解一下什么是IO，首先IO就是计算机中指Input/Output,也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。<br>流的概念：Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p><h3 id="IO如何学习？"><a href="#IO如何学习？" class="headerlink" title="IO如何学习？"></a>IO如何学习？</h3><h4 id="IO重点的类"><a href="#IO重点的类" class="headerlink" title="IO重点的类"></a>IO重点的类</h4><p>IO的学习我认为最主要的就是五个类和一个接口，把这些学好，基本就没什么问题：<br>File、OutputStream、InputStream、Writer、Reader和接口Serializable。</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td>File</td><td>文件类</td></tr><tr><td>OutputStream</td><td>字节输出流</td></tr><tr><td>InputStream</td><td>字节输入流</td></tr><tr><td>Writer</td><td>字符输流</td></tr><tr><td>Reader</td><td>字符输入流</td></tr></tbody></table><ol><li>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。</li><li>InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</li><li>OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。</li><li>Reader（文件格式操作）：抽象类，基于字符的输入操作。</li><li>Writer（文件格式操作）：抽象类，基于字符的输出操作。</li></ol><p>上面是对这几个类的简单概述基本就是这几个较为重点，当然还有扩展的FileInputStream等等，但是我认为最基础的还是这几个。</p><h4 id="IO的分类"><a href="#IO的分类" class="headerlink" title="IO的分类"></a>IO的分类</h4><p>从上面我们学习了流的概念；一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。<br>下图是一个描述输入流和输出流的类层次图。<br><img src="http://www.runoob.com/wp-content/uploads/2013/12/iostream2xx.png" alt="IO"></p><p>从图中我们可以看到简单的分类是字符流与字节流，接下来我在解释一下：<br>先来说一下输入、输出流：</p><ul><li>输入流：程序从输入流读取数据源。数据源包括外界(键盘、文件、网络…)，即是将数据源读入到程序的通信通道</li></ul><ul><li><p>输出流程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络…）的通信通道。</p><pre><code>采用数据流的目的就是使得输出输入独立于设备。输入流( Input  Stream )不关心数据源来自何种设备（键盘，文件，网络）。  输出流( Output Stream )不关心数据的目的是何种设备（键盘，文件，网络）。</code></pre></li></ul><p>流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：</p><p>1)  字节流：数据流中最小的数据单元是字节<br>2)  字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</p><p><strong>字符流的由来：</strong> Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。<br>所以说：<strong>字符流=字节流+编码表</strong>。这个编码表我们后来再进行讲解。</p><blockquote><p>注意：<br>a.如果没有明确说按照什么区分，默认按照数据类型进行分。<br>b.除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。</p></blockquote><h3 id="InputStream-OutputStream的代码实现"><a href="#InputStream-OutputStream的代码实现" class="headerlink" title="InputStream/OutputStream的代码实现"></a>InputStream/OutputStream的代码实现</h3><blockquote><p>通过上面的分析后我们知道要使用：OutputStream<br> 但是通过查看API，我们发现该流对象是一个抽象类，不能实例化。<br> 所以，我们要找一个具体的子类。<br> 而我们要找的子类是什么名字的呢?这个时候，很简单，我们回想一下，我们是不是要往文件中写东西。<br> 文件是哪个单词——&gt;File<br> 然后用的是字节输出流，联起来就是：FileOutputStream<br>注意：每种基类的子类都是以父类名作为后缀名。<br>          XxxOutputStream<br>          XxxInputStream<br>          XxxReader<br>          XxxWriter</p></blockquote><p>所以我们从FileInputStream和FileOutputStream来演示对字节流的操作。</p><h4 id="FileOutputStream读取数据"><a href="#FileOutputStream读取数据" class="headerlink" title="FileOutputStream读取数据"></a>FileOutputStream读取数据</h4><h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><ol><li>创建字节输入流对象</li><li>调用read()方法</li><li>释放资源<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">          <span class="comment">// 创建字节输出流对象</span></span><br><span class="line">          FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建字节输出流对象了做了几件事情：</span></span><br><span class="line"><span class="comment"> * A:调用系统功能去创建文件</span></span><br><span class="line"><span class="comment"> * B:创建fos对象</span></span><br><span class="line"><span class="comment"> * C:把fos对象指向这个文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">fos.write(<span class="string">"hello,IO"</span>.getBytes());</span><br><span class="line">fos.write(<span class="string">"java"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="comment">//关闭此文件输出流并释放与此流有关的所有系统资源。</span></span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><h5 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h5><p><strong>1. 创建字节输出流对象做了几件事情?</strong></p><pre><code>FileOutputStream(File file)File file = new File(&quot;fos.txt&quot;);FileOutputStream fos = new FileOutputStream(file);FileOutputStream(String name)</code></pre><p>其实先根据文件名称，使用File把这个文件创建出来，然后再把这个文件传入FileOutputStream(file);<br><strong>2. 为什么要关闭资源？</strong><br>释放资源的目的是要让流对象变成垃圾，这样就可以被垃圾回收器回收了，其次是通知系统去释放跟该文件相关的资源<br><strong>3. 如何实现数据换行？</strong><br>为什么现在没有换行呢?因为你值写了字节数据，并没有写入换行符号。<br>如何实现呢?写入换行符号即可呗。<br>刚才我们看到了有写文本文件打开是可以的，通过windows自带的那个不行，为什么呢?<br>因为不同的系统针对不同的换行符号识别是不一样的?</p><blockquote><p>windows:\r\n<br>linux:\n<br>Mac:\r</p></blockquote><p>而一些常见的个高级记事本，是可以识别任意换行符号的。<br>为了使得同一个java程序的换行符在所有的操作系统中都有一样的表现，使用 <strong><em>%n</em></strong>，就可以做到平台无关的换行。</p><p><strong>4. 如何实现数据的追加写入？</strong></p><p>用构造方法带第二个参数是true的情况即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个向具有指定 name 的文件中写入数据的输出文件流。如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处。</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos3.txt"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><p>这样创建就可以实现数据的追加。</p><h4 id="FileInputStream读取数据"><a href="#FileInputStream读取数据" class="headerlink" title="FileInputStream读取数据"></a>FileInputStream读取数据</h4><h5 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h5><ol><li>创建字节输入流对象</li><li>调用read()方法</li><li>释放资源</li></ol><h5 id="代码体现："><a href="#代码体现：" class="headerlink" title="代码体现："></a>代码体现：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//创建FileInputStream</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">      <span class="comment">//read（）方法读取数据</span></span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line">int by = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((by=fis.read())!=<span class="number">-1</span>) &#123;</span><br><span class="line">System.out.print((char)by);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(bys))!=<span class="number">-1</span>) &#123;</span><br><span class="line">System.out.print(<span class="keyword">new</span> <span class="built_in">String</span>(bys,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="复制文本文件"><a href="#复制文本文件" class="headerlink" title="复制文本文件"></a>复制文本文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 复制文本文件。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 数据源：从哪里来</span></span><br><span class="line"><span class="comment"> * a.txt--读取数据--FileInputStream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 目的地：到哪里去</span></span><br><span class="line"><span class="comment"> * b.txt--写数据--FileOutputStream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * java.io.FileNotFoundException: a.txt (系统找不到指定的文件。)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这一次复制中文没有出现任何问题，为什么呢?</span></span><br><span class="line"><span class="comment"> * 上一次我们出现问题的原因在于我们每次获取到一个字节数据，就把该字节数据转换为了字符数据，然后输出到控制台。</span></span><br><span class="line"><span class="comment"> * 而这一次呢?确实通过IO流读取数据，写到文本文件，你读取一个字节，我就写入一个字节，你没有做任何的转换。</span></span><br><span class="line"><span class="comment"> * 它会自己做转换。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyFileDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line"><span class="comment">// 封装数据源</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line"><span class="comment">// 封装目的地</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br><span class="line"></span><br><span class="line">byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(bys)) != <span class="number">-1</span>) &#123;</span><br><span class="line">fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源(建议先关后创建的)</span></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复制图片"><a href="#复制图片" class="headerlink" title="复制图片"></a>复制图片</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：把e:\\林青霞.jpg内容复制到当前项目目录下的mn.jpg中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 数据源：</span></span><br><span class="line"><span class="comment"> * e:\\林青霞.jpg--读取数据--FileInputStream</span></span><br><span class="line"><span class="comment"> * 目的地：</span></span><br><span class="line"><span class="comment"> * mn.jpg--写出数据--FileOutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyImageDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 封装数据源</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"e:\\林青霞.jpg"</span>);</span><br><span class="line"><span class="comment">// 封装目的地</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"mn.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制数据</span></span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思考问题：计算机如何识别中文"><a href="#思考问题：计算机如何识别中文" class="headerlink" title="思考问题：计算机如何识别中文"></a>思考问题：计算机如何识别中文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算机是如何识别什么时候该把两个字节转换为一个中文呢?</span></span><br><span class="line"><span class="comment"> * 在计算机中中文的存储分两个字节：</span></span><br><span class="line"><span class="comment"> * 第一个字节肯定是负数。</span></span><br><span class="line"><span class="comment"> * 第二个字节常见的是负数，可能有正数。但是没影响。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// String s = "abcde";</span></span><br><span class="line"><span class="comment">// // [97, 98, 99, 100, 101]</span></span><br><span class="line"></span><br><span class="line">String s = <span class="string">"我爱你中国"</span>;</span><br><span class="line"><span class="comment">// [-50, -46, -80, -82, -60, -29, -42, -48, -71, -6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bys = s.getBytes();</span><br><span class="line">System.out.println(Arrays.toString(bys));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符缓冲区流"><a href="#字符缓冲区流" class="headerlink" title="字符缓冲区流"></a>字符缓冲区流</h3><p>BufferedOutputStream（字符缓冲输出流）/BufferedInputStream（字符缓冲输入流）<br>构造方法为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。创建一个内部缓冲区数组并将其存储在 buf 中,该buf的大小默认为8192。   </span></span><br><span class="line">public   BufferedInputStream(InputStream <span class="keyword">in</span>); </span><br><span class="line"><span class="comment">//创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。创建一个长度为 size 的内部缓冲区数组并将其存储在 buf 中。   </span></span><br><span class="line">public   BufferedInputStream(InputStream <span class="keyword">in</span>,int size);</span><br></pre></td></tr></table></figure></p><p>BufferedOutputStream的思想进行简单说明：<em>BufferedOutputStream通过字节数组来缓冲数据，当缓冲区满或者用户调用flush()函数时，它就会将缓冲区的数据写入到输出流中。</em><br>话不多说，上代码——–&gt;</p><h4 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：把e:\\哥有老婆.mp4复制到当前项目目录下的copy.mp4中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 字节流四种方式复制文件：</span></span><br><span class="line"><span class="comment"> * 基本字节流一次读写一个字节：共耗时：117235毫秒</span></span><br><span class="line"><span class="comment"> * 基本字节流一次读写一个字节数组： 共耗时：156毫秒</span></span><br><span class="line"><span class="comment"> * 高效字节流一次读写一个字节： 共耗时：1141毫秒</span></span><br><span class="line"><span class="comment"> * 高效字节流一次读写一个字节数组： 共耗时：47毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyMp4Demo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// method1("e:\\哥有老婆.mp4", "copy1.mp4");</span></span><br><span class="line"><span class="comment">// method2("e:\\哥有老婆.mp4", "copy2.mp4");</span></span><br><span class="line"><span class="comment">// method3("e:\\哥有老婆.mp4", "copy3.mp4");</span></span><br><span class="line">method4(<span class="string">"e:\\哥有老婆.mp4"</span>, <span class="string">"copy4.mp4"</span>);</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"共耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效字节流一次读写一个字节数组：</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> method4(<span class="built_in">String</span> srcString, <span class="built_in">String</span> destString)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">srcString));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line"><span class="keyword">new</span> FileOutputStream(destString));</span><br><span class="line"></span><br><span class="line">byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = bis.read(bys)) != <span class="number">-1</span>) &#123;</span><br><span class="line">bos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效字节流一次读写一个字节：</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> method3(<span class="built_in">String</span> srcString, <span class="built_in">String</span> destString)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">srcString));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line"><span class="keyword">new</span> FileOutputStream(destString));</span><br><span class="line"></span><br><span class="line">int by = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((by = bis.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">bos.write(by);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本字节流一次读写一个字节数组</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> method2(<span class="built_in">String</span> srcString, <span class="built_in">String</span> destString)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcString);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destString);</span><br><span class="line"></span><br><span class="line">byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">int len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(bys)) != <span class="number">-1</span>) &#123;</span><br><span class="line">fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本字节流一次读写一个字节</span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> method1(<span class="built_in">String</span> srcString, <span class="built_in">String</span> destString)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcString);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destString);</span><br><span class="line"></span><br><span class="line">int by = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((by = fis.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">fos.write(by);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出，经过BufferedxxxputStream修饰的字节流，速度快了很多，其实这也是一种设计模式的体现，装饰者设计模式。<br>今天就到这里，明天再来讲解字符流和其他流的知识。谢谢！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>java基础之异常</title>
    <link href="http://yoursite.com/2018/07/31/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2018/07/31/java基础之异常/</id>
    <published>2018-07-31T13:44:51.000Z</published>
    <updated>2018-07-31T13:45:48.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还是梦想！</p></blockquote><hr><p>本来今天是准备写一点IO的东西，但是想了一下，想之前先说一下File类，但是File的时候还会出现很多错误，所以先写一篇异常的文章。就从异常开始说吧！</p><h3 id="异常的概述"><a href="#异常的概述" class="headerlink" title="异常的概述"></a>异常的概述</h3><p>异常：异常就是Java程序在运行过程中出现的错误。<br>异常由来：问题也是现实生活中一个具体事务，也可以通过java 的类的形式进行描述，并封装成对象。其实就是Java对不正常情况进行描述后的对象体现。</p><h3 id="异常的体系"><a href="#异常的体系" class="headerlink" title="异常的体系"></a>异常的体系</h3><p>下面是异常的大概分类：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-31/73011655.jpg" alt=""></p><p>我们可以看到Throwable类是 Java 语言中所有错误或异常的超类。下面具体有两个异常类：Error、Exception。</p><pre><code>Error：用于指示合理的应用程序不应该试图捕获的严重问题。（不需要我们处理）Exception：合理的应用程序想要获取的条件。        |---RuntimeException    运行期异常，我们需要修正代码        |---非RuntimeException 编译期异常，必须处理的，否则程序编译不通过 RuntimeException有以下一些例子：        NullPointerException - 空指针引用异常          ClassCastException - 类型强制转换异常。          IllegalArgumentException - 传递非法参数异常。          ArithmeticException - 算术运算异常          IndexOutOfBoundsException - 下标越界异常          NumberFormatException - 数字格式异常          UnsupportedOperationException - 不支持的操作异常</code></pre><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><ol><li>JVM默认的处理<br> 把异常的名称，原因，位置打印在控制台，但是不处理，程序停止，不在执行。</li><li>自己处理<pre><code>1.  try...catch...finally           自己编写处理代码,后面的程序可以继续执行    2.throws        把自己处理不了的，在方法上声明，告诉调用者，这里有问题。</code></pre><h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3></li><li><p>finally用于释放资源（JDBC、流操作），它的代码永远会执行。特殊情况：在执行到finally之前jvm退出。下面的打印是不会执行的，因为JVM已经退出了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;   </span><br><span class="line"><span class="comment">// do something Syst...   </span></span><br><span class="line"> System.exit(<span class="number">1</span>);  </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line"> System.out.println(<span class="string">"Hello,World!"</span>);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>异常处理的变形</p><pre><code>   try...catch...finallytry...catch...try...catch...catch...try...catch...catch...fianllytry...finally</code></pre><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可。<br>这个不是考察的重点，不做多的赘述。</p><h3 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h3></li><li>父类方法有异常抛出，子类方法的重写方法在抛出异常时必须小于等于父类的异常。</li><li>父类的方法没有异常抛出，子类的重写方法不能有异常抛出。</li><li>父类的方法抛出多个异常，子类的重写方法必须必父类少或者小。</li></ol><h3 id="异常的面试题"><a href="#异常的面试题" class="headerlink" title="异常的面试题"></a>异常的面试题</h3><h4 id="编译期异常和运行期异常的区别"><a href="#编译期异常和运行期异常的区别" class="headerlink" title="编译期异常和运行期异常的区别?"></a>编译期异常和运行期异常的区别?</h4><p>答：编译期异常，必须要处理的，否则无法通过编译，程序不能运行。<br>   运行期异常不一定会发生，不一定处理，也可以处理，比如空指针异常，这就不一定会发生。</p><h4 id="throw和throws是的区别？"><a href="#throw和throws是的区别？" class="headerlink" title="throw和throws是的区别？"></a>throw和throws是的区别？</h4><p>答：throw：</p><blockquote><p>在方法体中,后面跟的是异常对象名,并且只能是一个<br>    throw抛出的是一个异常对象，说明这里肯定有一个异常产生了.</p></blockquote><p>throws：</p><blockquote><p>在方法声明上,后面跟的是异常的类名,可以是多个<br>throws是声明方法有异常，是一种可能性，这个异常并不一定会产生.</p></blockquote><h4 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final,finally,finalize的区别?"></a>final,finally,finalize的区别?</h4><p>这个问题我之前做过深入的解析，可以查看我的博文    <a href="https://blog.jh0904.top/2018/07/09/final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">final、finally、finalize的区别</a>    </p><h4 id="如果在catch里面有return-请问finally还执行吗-如果执行-在return前还是后"><a href="#如果在catch里面有return-请问finally还执行吗-如果执行-在return前还是后" class="headerlink" title="如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后"></a>如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后</h4><p>答：会，前。<br>finally和return<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String\[\] args)</span> </span>&#123;  </span><br><span class="line">   System.out.println(getInt());  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">      System.out.println(a / <span class="number">0</span>);  </span><br><span class="line">   a = <span class="number">20</span>;  </span><br><span class="line">   &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;  </span><br><span class="line">      a = <span class="number">30</span>;  </span><br><span class="line"> <span class="keyword">return</span> a;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">      System.out.println (<span class="string">"hello"</span>);  </span><br><span class="line">   <span class="comment">//return a;  </span></span><br><span class="line">   &#125;  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行结果</p><pre><code>hello30</code></pre><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>这个是JDK1.7新加入的一个异常的新特性。<br>try-with-resources语句是一个声明一个或多个资源的try语句。一个资源作为一个对象，必须在程序结束之后关闭。try-with-resources语句确保在语句的最后每个资源都被关闭，任何实现了java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resource来实现异常处理和关闭资源。<br>具体使用见下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;  </span><br><span class="line"> <span class="keyword">return</span> br.readLine();  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>把需要关闭的对象写在括号中，其中要关闭的对象必须实现java.lang.AutoCloseable和java.io.Closeable。</p><h3 id="finally和return这些事"><a href="#finally和return这些事" class="headerlink" title="finally和return这些事"></a>finally和return这些事</h3><h4 id="在finally中return数值？"><a href="#在finally中return数值？" class="headerlink" title="在finally中return数值？"></a>在finally中return数值？</h4><p>在finally中return数值，最后的返回值是finally中的值。可以参考代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String\[\] args)</span> </span>&#123;  </span><br><span class="line">      System.out.println(getInt());  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">         System.out.println(a / <span class="number">0</span>);  </span><br><span class="line">   a = <span class="number">20</span>;  </span><br><span class="line">   &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;  </span><br><span class="line">         a = <span class="number">30</span>;  </span><br><span class="line"> <span class="keyword">return</span> a;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">         a=<span class="number">40</span>;</span><br><span class="line">         <span class="keyword">return</span> a;  </span><br><span class="line">   &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的运行结果是40,并且其中有提示说：</p><pre><code>不能在finally块中使用return，finally块中的return返回后方法结束执行，不会再执行try块中的return语句。 Negative example:    public static Long readFileLength(String fileName) {        try {            File file = new File(fileName);            RandomAccessFile randomAccessFile = new RandomAccessFile(file, &quot;r&quot;);            return randomAccessFile.length();        } catch (Exception e) {            logger.error(e.getMessage(), e);        } finally {            countDownLatch.countDown();            return 0L;        }    }</code></pre><h4 id="catch捕获异常时，finally改变返回值"><a href="#catch捕获异常时，finally改变返回值" class="headerlink" title="catch捕获异常时，finally改变返回值"></a>catch捕获异常时，finally改变返回值</h4><p>我们可以从上面看出来，当finally块中有return语句时，将会覆盖函数中其他的return语句。</p><blockquote><p>此外，由于一个方法内部定义的变量都存储子在栈中，当这个函数结束后，其对应的栈就被回收，此时方法中的变量就不存在了。因此return在返回时不是直接返回变量的值，而是复制一份，然后返回。<br>因此，对于基本数据类型的数据，在finally块中改变return的值，不会有影响，对于引用数据类型会有影响。</p></blockquote><p>可以参考下面代码理解<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package Exception;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> \* Exception * \* @author jh  </span></span><br><span class="line"><span class="comment"> \* @date 2018/7/31 20:26  </span></span><br><span class="line"><span class="comment"> \* description: */</span>public <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;  </span><br><span class="line">   public <span class="keyword">static</span> int testFinally1()&#123;  </span><br><span class="line">      int result=<span class="number">1</span>;  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">         result=<span class="number">2</span>;  </span><br><span class="line"> <span class="keyword">return</span> result;  </span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">         result=<span class="number">3</span>;  </span><br><span class="line">   System.out.println (<span class="string">"testFinally1"</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   public <span class="keyword">static</span> StringBuffer testFinally2()&#123;  </span><br><span class="line">      StringBuffer s=<span class="keyword">new</span> StringBuffer (<span class="string">"hello"</span>);  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> s;  </span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">         s.append (<span class="string">"world"</span>);  </span><br><span class="line">   System.out.println (<span class="string">"testFinally2"</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>\[\] args) &#123;  </span><br><span class="line">      int i = testFinally1 ();  </span><br><span class="line">   System.out.println (i);  </span><br><span class="line">   StringBuffer finally2 = testFinally2 ();  </span><br><span class="line">   System.out.println (finally2);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码我们可以看出程序在执行return时会首先将返回值存储在一个指定的位置，其次去执行finally块，最后再返回。在方法testFinally1中调用return前，先把return的值存储在一个指定的位置，然后再去执行finally块中的代码，此时修改result的值不会影响程序的返回结果。<br>testFinally2中，在调用return之前把s保存在一个指定的位置，但是因为s为引用类型，因此在finally块中修改s的值会发生变化。会影响程序的返回结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每天晚上疲劳的睡在床上时，才感觉真真切切地过了一天。人生最重要的不仅是努力，还有方向。压力不是有人比你努力，而是比你牛叉几倍的人比你更努力。即使看不到未来，即使看不到希望，也依然相信，自己错不了，自己选的人生错不了。第二天叫醒我的不是闹钟，其实，还
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机（一）</title>
    <link href="http://yoursite.com/2018/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/28/深入理解java虚拟机（一）/</id>
    <published>2018-07-28T04:14:26.000Z</published>
    <updated>2018-07-28T04:21:20.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>今天主要学习了《深入理解java虚拟机》的前两章节，第一章主要讲解了java语法的一些特性，及java发展的历史，还有java虚拟机的一些知识。<br>第二章主要讲了java内存区域与内存溢出异常。主要的内容我都总结了思维导图，如果需要导图，可以从百度云下载<a href="https://pan.baidu.com/s/1esP5YDPv_5UZ_neUvGo2BQ" target="_blank" rel="noopener">java虚拟机导图</a>  ，密码是0n73</p><p>好了，废话不说，直接上图。有不正确的地方，欢迎大家指正。</p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-28/92420488.jpg" alt="java"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天主要学习了《深入理解java虚拟机》的前两章节，第一章主要讲解了java语法的一些特性，及java发展的历史，还有java虚
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>阶段性总结</title>
    <link href="http://yoursite.com/2018/07/24/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/07/24/阶段性总结/</id>
    <published>2018-07-24T15:44:43.000Z</published>
    <updated>2018-07-24T15:45:42.276Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="实训总结"><a href="#实训总结" class="headerlink" title="实训总结"></a>实训总结</h3><p>今天是实训结束，实训期间主要还是自己状态不是很好，主要学习了Mybatis和Spring MVC的一些东西。其次实训单位让做一个简单的项目。我们小组做了一个简单的易买网项目.具体项目我已经上传到服务器，大家可以去访问。链接放在这里：<a href="http://www.jh0904.top/MStorage" target="_blank" rel="noopener">易买网</a>。时间短，任务比较重，所以就大概这个样子啦，其中还有很多缺陷，还要继续完善，希望大家指正。</p><h3 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h3><p>现在在学校东门租了房子，准备利用这个时间，好好的去复习一下之前的知识，并且去加深印象。去备战9月的秋招。<br>大概学习计划如下：</p><h4 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h4><ul><li>反射的总结、集合的总结、IO的总结、NIO的总结。（博客）</li><li>对于基础部分，还有笔试题的任务，每天规定做20-30道牛客的题目。编程题1道。（习题）</li><li>每日的博客（主要是面试题）</li><li>其次，还有对高并发的学习。java8的了解，java9暂时不考虑。</li><li>还有对java虚拟机的学习。</li><li>对之前几本武林秘籍的复习。</li></ul><h4 id="框架和web开发"><a href="#框架和web开发" class="headerlink" title="框架和web开发"></a>框架和web开发</h4><ul><li>学习《web开发指南》了解web开发的基本业务逻辑。</li><li>首先前段时间学习了Mybatis和Spring MVC,但是基础不牢靠，需要总结。（博客）</li><li>学习SSM的整合项目，并且根据尚硅谷的视频搭载一个简单的项目。</li><li>复习Spring的开发，复习方法有：1.学习spring的注解开发（视频）2.阅读spring实战（书籍）<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4></li><li>复习数据库的知识，简单的操作，并且还有高级的开发（索引的一些东西）</li><li>学习NoSQL数据库（Redis），主要以视频为主，书籍为辅导资料。</li><li>练习简单的sql语句练习题（牛客网）</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>熟悉简单的排序方法，了解基本思想，每周写一遍。</li><li>练习编程题，每日一道。</li><li>学习java视频（主要是简单的算法和letcood的视频）</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>以上是我对假期的一些安排和期望，希望我能在接下来的一个月中，砥砺前行，不忘初心。加油！！！</p><p>我对我的寄语：</p><h1 id="加油，相信自己。想要改变世界，先改变自己。"><a href="#加油，相信自己。想要改变世界，先改变自己。" class="headerlink" title=" 加油，相信自己。想要改变世界，先改变自己。 "></a><font style="color:red"> 加油，相信自己。想要改变世界，先改变自己。 </font></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实训总结&quot;&gt;&lt;a href=&quot;#实训总结&quot; class=&quot;headerlink&quot; title=&quot;实训总结&quot;&gt;&lt;/a&gt;实
      
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="自我总结" scheme="http://yoursite.com/tags/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93/"/>
    
      <category term="学习计划" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>纪念一次json解析错误！！！</title>
    <link href="http://yoursite.com/2018/07/23/%E7%BA%AA%E5%BF%B5%E4%B8%80%E6%AC%A1json%E8%A7%A3%E6%9E%90%E9%94%99%E8%AF%AF%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://yoursite.com/2018/07/23/纪念一次json解析错误！！！/</id>
    <published>2018-07-23T14:38:38.000Z</published>
    <updated>2018-07-23T14:41:09.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>今天做了一个简单的ssm项目，在用spring mvc解析json数据时，网页一直返回数据显示406错误。对于这个错误，头疼了一天。首先介绍一下我的小项目。</p><h3 id="项目代码与思路"><a href="#项目代码与思路" class="headerlink" title="项目代码与思路"></a>项目代码与思路</h3><p>首先先创建一个jsp页面，json数据的传输有两种：</p><ul><li>一、请求json，输出是json </li><li>二、请求key/value，输出是json</li></ul><p>接下来首先分析一下请求json返回也是json的形式（第二种不做简述，照猫画虎，思想一致，只提供代码）<br>使用jquery的ajax提交json串，对输出的json结果进行解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        //请求json，输出是json</span><br><span class="line">        function requestJson() &#123;</span><br><span class="line">            alert(&quot;requestJson&quot;);</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type: &apos;post&apos;,</span><br><span class="line">                url: &apos;$&#123;pageContext.request.contextPath &#125;/requestJson&apos;,</span><br><span class="line">                contentType: &apos;application/json;charset=utf-8&apos;,</span><br><span class="line">                //数据格式是json串,商品信息</span><br><span class="line">                data: &apos;&#123;&quot;name&quot;:&quot;手机&quot;,&quot;price&quot;:999&#125;&apos;,</span><br><span class="line">                success: function (data) &#123;//返回json结果</span><br><span class="line">                    alert(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;input type=&quot;button&quot; onclick=&quot;requestJson()&quot; value=&quot;请求json，输出是json&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>然后在controller中写一个JsonTest类存储方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.how2java.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.ItemsCustom;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JsonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求json串(商品信息)，输出json(商品信息)</span></span><br><span class="line"><span class="comment">//@RequestBody将请求的商品信息的json串转成itemsCustom对象</span></span><br><span class="line"><span class="comment">//@ResponseBody将itemsCustom转成json输出</span></span><br><span class="line">@RequestMapping(<span class="string">"/requestJson"</span>)</span><br><span class="line">public @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom)&#123;</span><br><span class="line"><span class="comment">//@ResponseBody将itemsCustom转成json输出</span></span><br><span class="line"><span class="keyword">return</span> itemsCustom;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个代码的意思就是从jsp发送到controller中，然后其中的@RequestBody标明传输json数据，最后在返回数据到页面上。</p><h3 id="错误问题"><a href="#错误问题" class="headerlink" title="错误问题"></a>错误问题</h3><p>在写完上述代码之后，出现了网页无法解析json数据的状况，检查头文件发现后端传数据过来到前端了，但是显示406错误。总共出现了两个问题：</p><h4 id="问题一：jar问题"><a href="#问题一：jar问题" class="headerlink" title="问题一：jar问题"></a>问题一：jar问题</h4><p>导入的jar包不正确，之前一直使用的是1.9.2版本的下面三个jar包，在网上查询了之后发现，spring3.* 支持1.9.2 ,在spring4.0之后已经不支持了，所以把jar全部更新到2.4.1的jar包。我使用的是maven工程，具体的依赖可以看下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">             &lt;!--jackson--&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;jackson-core&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;jackson-annotations&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;jackson-databind&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-23/91348004.jpg" alt=""></p><h4 id="问题二：spring-MVC-xml配置文件出现问题"><a href="#问题二：spring-MVC-xml配置文件出现问题" class="headerlink" title="问题二：spring MVC.xml配置文件出现问题"></a>问题二：spring MVC.xml配置文件出现问题</h4><p>在需要解析json1的时候需要在spring MVC.xml添加如下配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 避免IE执行AJAX时,返回<span class="built_in">JSON</span>出现下载文件 --&gt;</span><br><span class="line">   &lt;bean id=<span class="string">"mappingJacksonHttpMessageConverter"</span></span><br><span class="line">         <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"supportedMediaTypes"</span>&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">               &lt;value&gt;text/html;charset=UTF<span class="number">-8</span>&lt;<span class="regexp">/value&gt;</span></span><br><span class="line"><span class="regexp">           &lt;/</span>list&gt;</span><br><span class="line">       &lt;<span class="regexp">/property&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 启动Spring MVC的注解功能，完成请求和注解POJO的映射 --&gt;</span><br><span class="line">   &lt;bean</span><br><span class="line">           <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"messageConverters"</span>&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">               &lt;ref bean=<span class="string">"mappingJacksonHttpMessageConverter"</span> /&gt;&lt;!-- json转换器 --&gt;</span><br><span class="line">           &lt;/list&gt;</span><br><span class="line">       &lt;<span class="regexp">/property&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>bean&gt;</span><br></pre></td></tr></table></figure></p><p>但是加入之后依然报错，显示无法加载<font style="color : red">org.springframework.http.converter.json.MappingJacksonHttpMessageConverter</font></p><p>网上查询之后发现，在导入jackson2.0版本以上的时候，其中的配置文件已经更换了<br>更换为</p><blockquote><p>org.springframework.http.converter.json.MappingJackson2HttpMessageConverter</p></blockquote><p>配置完成之后，重新启动项目，发现项目没有问题了，成功运行。<br>这次再配置的过程中浪费太多时间，为了避免下次还是出现此类问题，故此写了这篇文章，以便以后查阅和修改代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天做了一个简单的ssm项目，在用spring mvc解析json数据时，网页一直返回数据显示406错误。对于这个错误，头疼了一
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
      <category term="java项目" scheme="http://yoursite.com/tags/java%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>java提供了那些IO方式？NIO如何实现多路复用？</title>
    <link href="http://yoursite.com/2018/07/21/java%E6%8F%90%E4%BE%9B%E4%BA%86%E9%82%A3%E4%BA%9BIO%E6%96%B9%E5%BC%8F%EF%BC%9FNIO%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/21/java提供了那些IO方式？NIO如何实现多路复用？/</id>
    <published>2018-07-21T00:57:55.000Z</published>
    <updated>2018-07-21T00:58:30.708Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。</p><p>首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p><p>java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p><p>很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p><p>第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p><p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>上面所列出的回答是一种常见的分类方式，即所谓的BIO、NIO、AIO。</p><p>主要考察的点有：</p><ul><li>基础的API设计与功能<br>InputStream/OutputStream和Reader/Writer的区别和使用。</li><li>NIO、NIO2的基本组成。</li><li>不同场景下，分析BIO和NIO的设计和实现原理。</li><li>NIO提供高性能的原理</li><li><p>NIO还存在那些问题？改进的想法？</p><h3 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4></li><li>区分同步或异步（synchronous/asynchronous）<blockquote><p>所谓同步是指一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成，这是一个可靠的任务序列。要成功都成功，要失败都失败，两个任务的状态可以保持一致。<br>异步不需要等待依赖的任务完成。只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了，至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p></blockquote></li><li>区分阻塞与非阻塞（blocking/non-blocking）<blockquote><p>在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</p></blockquote></li></ul><p>对于IO，做一下总结：</p><ul><li>IO不仅仅是对文件的操作，在网络编程中，比如socket通信，都是典型的IO操作目标。</li><li>输入流、输出流（InputStream/OutputStream）适用于读取或者写入字节，例如图片操作文件。</li><li>Reader/Writer则是用于操作字符的，增加字符编解码的功能，适用于从文件中读取或者写入文本信息2，本质上计算机操作的都是字节，不管是从网络通信还是文件读取，Reader/Writer相当于构建了应用逻辑与原始数据之间的桥梁。</li><li>BufferedOutputStream等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。</li><li>参考下面这张类图，很多 IO工具类都实现了 Closeable接口，因为需要进行资源的释放。比如，打开 FileInputStream，它就会获取相应的文件描述符（ FileDescriptor），需要利用 try- with- resources、 try- finally等机制保证 FileInputStream被明确关闭，进而相应文件描述符也会失效，否则将导致资源无法被释放。利用专栏前面的内容提到的 Cleaner或 finalize机制作为资源释放的最后把关，也是必要的。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-21/67006062.jpg" alt=""></li></ul><h4 id="NIO的概览"><a href="#NIO的概览" class="headerlink" title="NIO的概览"></a>NIO的概览</h4><ol><li>首先了解一下NIO的基本组成部分：</li></ol><ul><li><p>Chnnel</p><blockquote><p>由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。<br>Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。<br>类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。<br>File 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过 Socket 获取 Channel，反之亦然。</p></blockquote></li><li><p>Buffer</p><blockquote><p>一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p></blockquote></li><li>Selector<blockquote><p>是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在 Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理。<br>Selector 同样是基于底层操作系统机制，不同模式、不同版本都存在区别，例如，在最新的代码库里，相关实现如下：<br>在Linux中依赖于epoll<br>在Windows中依赖于iocp模型</p></blockquote></li><li>Chartset<blockquote><p>提供 Unicode 字符串定义，NIO 也提供了相应的编解码器等，例如，通过下面的方式进行字符串到 ByteBuffer 的转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharSet.defaultCharSet().encode(<span class="string">"Hello,World"</span>)</span><br></pre></td></tr></table></figure></blockquote></li></ul><ol start="2"><li>NIO的具体作用</li></ol><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>对比HashMap、HashTable、TreeMap之间的区别</title>
    <link href="http://yoursite.com/2018/07/18/%E5%AF%B9%E6%AF%94HashMap%E3%80%81HashTable%E3%80%81TreeMap%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/07/18/对比HashMap、HashTable、TreeMap之间的区别/</id>
    <published>2018-07-18T13:41:46.000Z</published>
    <updated>2018-07-18T13:42:57.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。</p><p>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</p><p>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</p><p>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>我感觉这三个Map中最重要的肯定是HashMap，首先看一下我之前的文章了解一下：<a href="https://blog.jh0904.top/2018/06/08/hashmap/" target="_blank" rel="noopener">HashMap的源码解析</a>，我认为学习集合框架，首先要了解基本的操作用法，这个应该去读API。其次，应当去学习源码，去了解怎么实现的具体代码。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-18/32923831.jpg" alt=""></p><p>对于三者的区别，我主要从三方面来说：</p><h4 id="1-语法上面的区别："><a href="#1-语法上面的区别：" class="headerlink" title="1.语法上面的区别："></a>1.语法上面的区别：</h4><p>1）HashMap允许键值为空，Hashtable不允许。</p><p>2）HashMap包含了containsvalue和containsKey，不包含有contains。</p><h4 id="2-安全方面的区别"><a href="#2-安全方面的区别" class="headerlink" title="2.安全方面的区别"></a>2.安全方面的区别</h4><p>HashTable支持线程安全的，而HashMap不支持线程同步，是非线程安全的。因此，HashMap相对来说效率可能会高于Hashtable。</p><h4 id="3-源码级别的区别"><a href="#3-源码级别的区别" class="headerlink" title="3.源码级别的区别"></a>3.源码级别的区别</h4><p>Hashtable，hash数组默认的大小是11，增加的方式是old*2+1,而HashMap中，hash数组的默认大小是16，而且一定是2的指数。</p><p>相较于HashMap和HashTable，TreeMap是利用红黑树来实现的，实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap来进行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多线程（二）</title>
    <link href="http://yoursite.com/2018/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/17/多线程（二）/</id>
    <published>2018-07-17T14:30:53.000Z</published>
    <updated>2018-07-17T14:31:26.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><p>这是多线程的第二篇文章，主要介绍一写java多线程的简单锁机制和死锁、线程池等一些概念，多线程的高级部分过一段时间加上。</p><h3 id="1-JDK5以后的针对线程的锁定操作和释放操作"><a href="#1-JDK5以后的针对线程的锁定操作和释放操作" class="headerlink" title="(1)JDK5以后的针对线程的锁定操作和释放操作"></a>(1)JDK5以后的针对线程的锁定操作和释放操作</h3><p>之前的同步方法，我们学习了简单的synchronized同步代码块，还有用synchronized修饰方法，形成同步方法。还有静态同步方法。<br>现在我们要了解简单的锁机制。<br>Lock锁是JDK5之后加入的，为了更清晰的表达如何加锁和释放锁。具体的使用方法参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义锁对象</span></span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的Main方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，</span></span><br><span class="line"><span class="comment"> * 为了更清晰的表达如何加锁和释放锁,JDK5以后提供了一个新的锁对象Lock。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Lock：</span></span><br><span class="line"><span class="comment"> * void lock()： 获取锁。</span></span><br><span class="line"><span class="comment"> * void unlock():释放锁。  </span></span><br><span class="line"><span class="comment"> * ReentrantLock是Lock的实现类.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个窗口</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>Lock的主要方法还是<br>Lock<br>    &nbsp;&nbsp;&nbsp;&nbsp;  void lock()<br>    &nbsp;&nbsp;&nbsp;&nbsp;  void unlock()<br>   &nbsp;&nbsp;&nbsp;&nbsp; <font style="color:red"> ReentrantLock</font></p></blockquote><h3 id="死锁问题的描述和代码体现"><a href="#死锁问题的描述和代码体现" class="headerlink" title="死锁问题的描述和代码体现"></a>死锁问题的描述和代码体现</h3><p>死锁问题是java中一个比较重要的问题。一般面试经常会问，这个需要牢记。</p><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><blockquote><p>我们先看看这样一个生活中的例子：在一条河上有一座桥，桥面较窄，只能容纳一辆汽车通过，无法让两辆汽车并行。如果有两辆汽车A和B分别由桥的两端驶上该桥，则对于A车来说，它走过桥面左面的一段路（即占有了桥的一部分资源），要想过桥还须等待B车让出右边的桥面，此时A车不能前进；对于B车来说，它走过桥面右边的一段路（即占有了桥的一部分资源），要想过桥还须等待A车让出左边的桥面，此时B车也不能前进。两边的车都不倒车，结果造成互相等待对方让出桥面，但是谁也不让路，就会无休止地等下去。这种现象就是死锁。如果把汽车比做进程，桥面作为资源，那麽上述问题就描述为：进程A占有资源R1，等待进程B占有的资源Rr；进程B占有资源Rr，等待进程A占有的资源R1。而且资源R1和Rr只允许一个进程占用，即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。  </p></blockquote><h4 id="死锁的原因"><a href="#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h4><p>主要有以下四个必要条件。总的来说死锁的原因还是资源的相互占有，无法释放。</p><blockquote><ol><li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li><li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，⋯⋯，Pn正在等待已被P0占用的资源。即肯定存在相互等待的死循环。</li></ol></blockquote><h4 id="死锁的代码"><a href="#死锁的代码" class="headerlink" title="死锁的代码"></a>死锁的代码</h4><p>DieLock的实现（zhonmgdi）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_02;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DieLock</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">private boolean flag;</span><br><span class="line"></span><br><span class="line">public DieLock(boolean flag) &#123;</span><br><span class="line"><span class="keyword">this</span>.flag = flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">synchronized (MyLock.objA) &#123;</span><br><span class="line">System.out.println(<span class="string">"if objA"</span>);</span><br><span class="line">synchronized (MyLock.objB) &#123;</span><br><span class="line">System.out.println(<span class="string">"if objB"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">synchronized (MyLock.objB) &#123;</span><br><span class="line">System.out.println(<span class="string">"else objB"</span>);</span><br><span class="line">synchronized (MyLock.objA) &#123;</span><br><span class="line">System.out.println(<span class="string">"else objA"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MyLock—-&gt;创建锁对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_02;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建两把锁对象</span></span><br><span class="line">public <span class="keyword">static</span> final <span class="built_in">Object</span> objA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">public <span class="keyword">static</span> final <span class="built_in">Object</span> objB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Demo类，开启线程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 同步的弊端：</span></span><br><span class="line"><span class="comment"> * A:效率低</span></span><br><span class="line"><span class="comment"> * B:容易产生死锁</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 死锁：</span></span><br><span class="line"><span class="comment"> * 两个或两个以上的线程在争夺资源的过程中，发生的一种相互等待的现象。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 举例：</span></span><br><span class="line"><span class="comment"> * 中国人，美国人吃饭案例。</span></span><br><span class="line"><span class="comment"> * 正常情况：</span></span><br><span class="line"><span class="comment"> * 中国人:筷子两支</span></span><br><span class="line"><span class="comment"> * 美国人:刀和叉</span></span><br><span class="line"><span class="comment"> * 现在：</span></span><br><span class="line"><span class="comment"> * 中国人：筷子1支，刀一把</span></span><br><span class="line"><span class="comment"> * 美国人：筷子1支，叉一把</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DieLockDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">DieLock dl1 = <span class="keyword">new</span> DieLock(<span class="literal">true</span>);</span><br><span class="line">DieLock dl2 = <span class="keyword">new</span> DieLock(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">dl1.start();</span><br><span class="line">dl2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="生产者和消费者多线程体现-线程间通信问题"><a href="#生产者和消费者多线程体现-线程间通信问题" class="headerlink" title="生产者和消费者多线程体现(线程间通信问题)"></a>生产者和消费者多线程体现(线程间通信问题)</h3><p>具体的生产者消费者的模式如下图：<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-17/63313147.jpg" alt=""><br>以学生作为资源来实现的</p><pre><code>资源类：Student设置数据类：SetThread(生产者)获取数据类：GetThread(消费者)测试类：StudentDemo</code></pre><p><img src="https://images2015.cnblogs.com/blog/868641/201703/868641-20170303152707641-1755807475.png" alt=""><br>上图就是对生产者消费者的解释。<br>具体的代码实现：<br>Student<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="built_in">String</span> name;</span><br><span class="line">int age;</span><br><span class="line">boolean flag; <span class="comment">// 默认情况是没有数据，如果是true，说明有数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SetThread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SetThread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">private Student s;</span><br><span class="line">private int x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">public SetThread(Student s) &#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">synchronized (s) &#123;</span><br><span class="line"><span class="comment">//判断有没有</span></span><br><span class="line"><span class="keyword">if</span>(s.flag)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.wait(); <span class="comment">//t1等着，释放锁</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">s.name = <span class="string">"林青霞"</span>;</span><br><span class="line">s.age = <span class="number">27</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s.name = <span class="string">"刘意"</span>;</span><br><span class="line">s.age = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line">x++; <span class="comment">//x=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改标记</span></span><br><span class="line">s.flag = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//唤醒线程</span></span><br><span class="line">s.notify(); <span class="comment">//唤醒t2,唤醒并不表示你立马可以执行，必须还得抢CPU的执行权。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//t1有，或者t2有</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetThread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">private Student s;</span><br><span class="line"></span><br><span class="line">public GetThread(Student s) &#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">synchronized (s) &#123;</span><br><span class="line"><span class="keyword">if</span>(!s.flag)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.wait(); <span class="comment">//t2就等待了。立即释放锁。将来醒过来的时候，是从这里醒过来的时候</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(s.name + <span class="string">"---"</span> + s.age);</span><br><span class="line"><span class="comment">//林青霞---27</span></span><br><span class="line"><span class="comment">//刘意---30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改标记</span></span><br><span class="line">s.flag = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//唤醒线程</span></span><br><span class="line">s.notify(); <span class="comment">//唤醒t1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StudentDemo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_05;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> * 资源类：Student</span></span><br><span class="line"><span class="comment"> * 设置学生数据:SetThread(生产者)</span></span><br><span class="line"><span class="comment"> * 获取学生数据：GetThread(消费者)</span></span><br><span class="line"><span class="comment"> * 测试类:StudentDemo</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题1：按照思路写代码，发现数据每次都是:null---0</span></span><br><span class="line"><span class="comment"> * 原因：我们在每个线程中都创建了新的资源,而我们要求的时候设置和获取线程的资源应该是同一个</span></span><br><span class="line"><span class="comment"> * 如何实现呢?</span></span><br><span class="line"><span class="comment"> * 在外界把这个数据创建出来，通过构造方法传递给其他的类。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题2：为了数据的效果好一些，我加入了循环和判断，给出不同的值,这个时候产生了新的问题</span></span><br><span class="line"><span class="comment"> * A:同一个数据出现多次</span></span><br><span class="line"><span class="comment"> * B:姓名和年龄不匹配</span></span><br><span class="line"><span class="comment"> * 原因：</span></span><br><span class="line"><span class="comment"> * A:同一个数据出现多次</span></span><br><span class="line"><span class="comment"> * CPU的一点点时间片的执行权，就足够你执行很多次。</span></span><br><span class="line"><span class="comment"> * B:姓名和年龄不匹配</span></span><br><span class="line"><span class="comment"> * 线程运行的随机性</span></span><br><span class="line"><span class="comment"> * 线程安全问题：</span></span><br><span class="line"><span class="comment"> * A:是否是多线程环境是</span></span><br><span class="line"><span class="comment"> * B:是否有共享数据是</span></span><br><span class="line"><span class="comment"> * C:是否有多条语句操作共享数据是</span></span><br><span class="line"><span class="comment"> * 解决方案：</span></span><br><span class="line"><span class="comment"> * 加锁。</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * A:不同种类的线程都要加锁。</span></span><br><span class="line"><span class="comment"> * B:不同种类的线程加的锁必须是同一把。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题3:虽然数据安全了，但是呢，一次一大片不好看，我就想依次的一次一个输出。</span></span><br><span class="line"><span class="comment"> * 如何实现呢?</span></span><br><span class="line"><span class="comment"> * 通过Java提供的等待唤醒机制解决。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 等待唤醒：</span></span><br><span class="line"><span class="comment"> * Object类中提供了三个方法：</span></span><br><span class="line"><span class="comment"> * wait():等待</span></span><br><span class="line"><span class="comment"> * notify():唤醒单个线程</span></span><br><span class="line"><span class="comment"> * notifyAll():唤醒所有线程</span></span><br><span class="line"><span class="comment"> * 为什么这些方法不定义在Thread类中呢?</span></span><br><span class="line"><span class="comment"> * 这些方法的调用必须通过锁对象调用，而我们刚才使用的锁对象是任意锁对象。</span></span><br><span class="line"><span class="comment"> * 所以，这些方法必须定义在Object类中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">//创建资源</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取的类</span></span><br><span class="line">SetThread st = <span class="keyword">new</span> SetThread(s);</span><br><span class="line">GetThread gt = <span class="keyword">new</span> GetThread(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程类</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(gt);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是具体的实现方法和操作，其中的注释可以参考着观看，有助于理解程序代码。</p><h3 id="线程的转化状态"><a href="#线程的转化状态" class="headerlink" title="线程的转化状态"></a>线程的转化状态</h3><p>主要参考下图<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-17/99854255.jpg" alt=""></p><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>线程组（ThreadGroup）就是由线程组成的管理线程的类，这个类是java.lang.ThreadGroup类。</p><blockquote><p>在Java中每一个线程都归属于某个线程组管理的一员，例如在主函数main()主工作流程中产生一个线程，则产生的线程属于main这个线程组管理的一员。<br>定义一个线程组，通过以下代码可以实现。<br>ThreadGroup group=new ThreadGroup(“group”);<br>Thread thread=new Thread(group,”the first thread of group”);<br>具体的java例子代码可以见下：</p></blockquote><p>MyRunnable—–&gt;实现线程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_06;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadGroupDemo—–&gt;首先先构建一个线程组，然后在线程构造的时候指定线程组，设置好线程可以通过tg.getThreadGroup().getName()获取当前的线程组名称。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_06;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程组： 把多个线程组合到一起。</span></span><br><span class="line"><span class="comment"> * 它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// method1();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们如何修改线程所在的组呢?</span></span><br><span class="line"><span class="comment">// 创建一个线程组</span></span><br><span class="line"><span class="comment">// 创建其他线程的时候，把其他线程的组指定为我们自己新建线程组</span></span><br><span class="line">method2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// t1.start();</span></span><br><span class="line"><span class="comment">// t2.start();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> method2() &#123;</span><br><span class="line"><span class="comment">// ThreadGroup(String name)</span></span><br><span class="line">ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">"这是一个新的组"</span>);</span><br><span class="line"></span><br><span class="line">MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"><span class="comment">// Thread(ThreadGroup group, Runnable target, String name)</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(tg, my, <span class="string">"林青霞"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(tg, my, <span class="string">"刘意"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(t1.getThreadGroup().getName());</span><br><span class="line">System.out.println(t2.getThreadGroup().getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过组名称设置后台线程，表示该组的线程都是后台线程</span></span><br><span class="line">tg.setDaemon(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">void</span> method1() &#123;</span><br><span class="line">MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(my, <span class="string">"林青霞"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(my, <span class="string">"刘意"</span>);</span><br><span class="line"><span class="comment">// 我不知道他们属于那个线程组,我想知道，怎么办</span></span><br><span class="line"><span class="comment">// 线程类里面的方法：public final ThreadGroup getThreadGroup()</span></span><br><span class="line">ThreadGroup tg1 = t1.getThreadGroup();</span><br><span class="line">ThreadGroup tg2 = t2.getThreadGroup();</span><br><span class="line"><span class="comment">// 线程组里面的方法：public final String getName()</span></span><br><span class="line"><span class="built_in">String</span> name1 = tg1.getName();</span><br><span class="line"><span class="built_in">String</span> name2 = tg2.getName();</span><br><span class="line">System.out.println(name1);</span><br><span class="line">System.out.println(name2);</span><br><span class="line"><span class="comment">// 通过结果我们知道了：线程默认情况下属于main线程组</span></span><br><span class="line"><span class="comment">// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组</span></span><br><span class="line">System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。</p><h4 id="线程池的实现方法"><a href="#线程池的实现方法" class="headerlink" title="线程池的实现方法"></a>线程池的实现方法</h4><blockquote><p>线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。<br>在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池</p></blockquote><h5 id="线程池具体方法"><a href="#线程池具体方法" class="headerlink" title="线程池具体方法"></a>线程池具体方法</h5><p>JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法</p><pre><code>public static ExecutorService newCachedThreadPool()创建一个具有缓存功能的线程池缓存：百度浏览过的信息再次访问public static ExecutorService newFixedThreadPool(int nThreads)创建一个可重用的，具有固定线程数的线程池public static ExecutorService newSingleThreadExecutor()创建一个只有单线程的线程池，相当于上个方法的参数是1    </code></pre><p>这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法</p><pre><code>Future&lt;?&gt; submit(Runnable task)&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></pre><h5 id="线程池的代码实现"><a href="#线程池的代码实现" class="headerlink" title="线程池的代码实现"></a>线程池的代码实现</h5><p>MyRunnable接口实现线程。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ExecutorsDemo<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast_08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程池的好处：线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如何实现线程的代码呢?</span></span><br><span class="line"><span class="comment"> * A:创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line"><span class="comment"> * public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment"> * B:这种线程池的线程可以执行：</span></span><br><span class="line"><span class="comment"> * 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line"><span class="comment"> * 做一个类实现Runnable接口。</span></span><br><span class="line"><span class="comment"> * C:调用如下方法即可</span></span><br><span class="line"><span class="comment"> * Future&lt;?&gt; submit(Runnable task)</span></span><br><span class="line"><span class="comment"> *&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</span></span><br><span class="line"><span class="comment"> *D:我就要结束，可以吗?</span></span><br><span class="line"><span class="comment"> *可以。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// 创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line"><span class="comment">// public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多线程的面试题"><a href="#多线程的面试题" class="headerlink" title="多线程的面试题"></a>多线程的面试题</h3><p>具体的面试题可以参考我的往期文章：<a href="https://blog.jh0904.top/2018/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" rel="noopener">多线程面试题</a></p><p>在看面试题的时候，要注意，自己是否是自己真的理解了透彻了。先去思考问题，再去想自己的语言如何回答，自己如果面试遇到这种问题了应该如何处理。之后再去看答案和解析，这样更有收获，一起加油ヾ(◍°∇°◍)ﾉﾞ。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是多线程的第二篇文章，主要介绍一写java多线程的简单锁机制和死锁、线程池等一些概念，多线程的高级部分过一段时间加上。&lt;/p&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程（一）</title>
    <link href="http://yoursite.com/2018/07/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/16/多线程（一）/</id>
    <published>2018-07-16T15:55:35.000Z</published>
    <updated>2018-07-16T15:57:02.647Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font style="color:blue">爱女票，爱Java❤❤❤ </font></blockquote><h2 id="多线程-一"><a href="#多线程-一" class="headerlink" title="多线程(一)"></a>多线程(一)</h2><h3 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h3><p>多线程：一个应用程序有多条执行路径<br>        进程：正在执行的应用程序<br>        线程：进程的执行单元，执行路径<br>        单线程：一个应用程序只有一条执行路径<br>        多线程：一个应用程序有多条执行路径</p><blockquote><p>并发和并行的区别：简单的说，并行是指同一时刻同时做多件事情，而并发是指同一时间间隔内做多件事情。</p><font style="color:red;font-size:12px">  并发是两个任务可以在重叠的时间段内启动，运行和完成。并行是任务在同一时间运行，例如，在多核处理器上。<br>并发是独立执行过程的组合，而并行是同时执行（可能相关的）计算。<br>并发是一次处理很多事情，并行是同时做很多事情。<br>应用程序可以是并发的，但不是并行的，这意味着它可以同时处理多个任务，但是没有两个任务在同一时刻执行。<br>应用程序可以是并行的，但不是并发的，这意味着它同时处理多核CPU中的任务的多个子任务。<br>一个应用程序可以即不是并行的，也不是并发的，这意味着它一次一个地处理所有任务。<br>应用程序可以即是并行的也是并发的，这意味着它同时在多核CPU中同时处理多个任务。</font></blockquote><h4 id="多进程的意义"><a href="#多进程的意义" class="headerlink" title="多进程的意义?"></a>多进程的意义?</h4><p>单进程的计算机只能做一件事情,而我们现在的计算机都可以做多件事情。<br>    举例:一边玩游戏(游戏进程),一边听音乐(音乐进程)。<br>    也就是说现在的计算机都是支持多进程的,可以在一个时间段内执行多个任务。<br>    并且呢,可以提高CPU的使用率。</p><h4 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义?"></a>多线程的意义?</h4><p>多线程的存在,不是提高程序的执行速度。其实是为了提高应用程序的使用率。<br>    程序的执行其实都是在抢CUP的资源,CPU的执行权。<br>    多个进程是在抢这个资源,而其中的某一个进程如果执行路径比较多,就会有更高的几率抢到CPU的执行权。<br>    我们是不敢保证哪一个线程在哪个时刻抢到,所以线程的执行有随机性。<br>    举例:一个美女抛绣球(CPU执行权),A,B,C…等,ABC(进程)三个人抢绣球(CPU执行权),但是由于B(进程)使用分身术(多条执行路径),而他抢到绣球的机率将会很高,但是不一定能抢到</p><h3 id="Java程序的运行原理及JVM的启动是多线程的吗"><a href="#Java程序的运行原理及JVM的启动是多线程的吗" class="headerlink" title="Java程序的运行原理及JVM的启动是多线程的吗?"></a>Java程序的运行原理及JVM的启动是多线程的吗?</h3><ol><li>Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。</li><li>JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。<h3 id="多线程的实现方案"><a href="#多线程的实现方案" class="headerlink" title="多线程的实现方案"></a>多线程的实现方案</h3></li><li><p>继承Thread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cn.thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/2 18:18</span></span><br><span class="line"><span class="comment"> * description:实现Thread方法，继承Thread类，然后再去重写run（）方法。</span></span><br><span class="line"><span class="comment"> * 不是所有类需要被多线程执行，run（）方法里面是被线程执行的代码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            System.out.println (getName ()+<span class="string">"------&gt;"</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep (<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace ();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* getName ()源码</span></span><br><span class="line"><span class="comment">public Thread() &#123;</span></span><br><span class="line"><span class="comment">         init(null, null, "Thread-" + nextThreadNum(), 0);</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest1 t = <span class="keyword">new</span> ThreadTest1 ();</span><br><span class="line">        ThreadTest1 t1 = <span class="keyword">new</span> ThreadTest1 ();</span><br><span class="line"></span><br><span class="line">        t.setName (<span class="string">"magic"</span>);</span><br><span class="line">        t1.setName (<span class="string">"jh"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        启动线程</span></span><br><span class="line"><span class="comment">        t.run ();</span></span><br><span class="line"><span class="comment">        t.run ();*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// java.lang.IllegalThreadStateException(非法的状态异常，相当于main线程启动了两次)</span></span><br><span class="line">       <span class="comment">/* t.start ();</span></span><br><span class="line"><span class="comment">        t.start ();*/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//如何获取线程的名称  public String getName()</span></span><br><span class="line">        t.start ();</span><br><span class="line">        t1.start ();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * run方法调用就相当于普通方法的调用，单线程的执行</span></span><br><span class="line"><span class="comment">         * 面试题：start和run的区别：</span></span><br><span class="line"><span class="comment">         * run：仅仅是封装被线程执行的代码，直接是调用是普通方法。</span></span><br><span class="line"><span class="comment">         * start：首先启动线程，然后再由JVM虚拟机调用该线程的run（）方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口<br>首先先实现一个线程，其次重写run()方法；下面这是一个卖票的多线程程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cn.thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/3 8:22</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj=<span class="keyword">new</span> Object ();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println (Thread.currentThread ().getName ()+<span class="string">"正在售票---&gt;"</span>+(count--));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>接下来是Main的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread1 my = <span class="keyword">new</span> MyThread1 ();</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread (my, <span class="string">"一号窗口"</span>);</span><br><span class="line">        Thread tt = <span class="keyword">new</span> Thread (my, <span class="string">"二号窗口"</span>);</span><br><span class="line">        Thread ttt = <span class="keyword">new</span> Thread (my, <span class="string">"三号窗口"</span>);</span><br><span class="line"></span><br><span class="line">        t.start ();</span><br><span class="line">        tt.start ();</span><br><span class="line">        ttt.start ();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>实现Callable接口<br>实现Callable接口，重写call（）方法；<br>具体代码见下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程求和案例(实现Callable接口，重写了call()方法)</span></span><br><span class="line"><span class="comment"> * Callable:是带泛型的接口。</span></span><br><span class="line"><span class="comment"> * 这里指定的泛型其实是call()方法的返回值类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= number; x++) &#123;</span><br><span class="line">sum += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多线程实现的方式3：</span></span><br><span class="line"><span class="comment"> *  A:创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line"><span class="comment"> * public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment"> * B:这种线程池的线程可以执行：</span></span><br><span class="line"><span class="comment"> * 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line"><span class="comment"> * 做一个类实现Runnable接口。</span></span><br><span class="line"><span class="comment"> * C:调用如下方法即可</span></span><br><span class="line"><span class="comment"> * Future&lt;?&gt; submit(Runnable task)</span></span><br><span class="line"><span class="comment"> *&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</span></span><br><span class="line"><span class="comment"> *D:我就要结束，可以吗?</span></span><br><span class="line"><span class="comment"> *可以。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"><span class="comment">// 创建线程池对象</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">Future&lt;Integer&gt; f1 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">100</span>));</span><br><span class="line">Future&lt;Integer&gt; f2 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// V get()</span></span><br><span class="line">Integer i1 = f1.get();</span><br><span class="line">Integer i2 = f2.get();</span><br><span class="line"></span><br><span class="line">System.out.println(i1);</span><br><span class="line">System.out.println(i2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line">pool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结：总的来说，虽然实现多线程有两种方式，但是还是推荐使用实现Runable接口的方式，让程序具有可扩展性。</p><h3 id="线程的调度和优先级问题"><a href="#线程的调度和优先级问题" class="headerlink" title="线程的调度和优先级问题"></a>线程的调度和优先级问题</h3><ol><li>线程的调度</li></ol><ul><li>分时调度，所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</li><li>抢占式调度 (Java采用的是该调度方式)，优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 </li></ul><ol start="2"><li>获取和设置线程优先级</li></ol><ul><li>默认是5</li><li>范围是1-10<br>在Java中，线程的优先级用setPriority()方法就行，线程的优先级分为1-10这10个等级，如果小于1或大于10，则抛出异常throw new IllegalArgumentException()，默认是5。<br>主要的方法是：<blockquote><p>public final int getPriority()      获取线程优先级<br>public final void setPriority(int newPriority)设置线程优先级（1-10）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriority</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>Main方法示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们的线程没有设置优先级,肯定有默认优先级。</span></span><br><span class="line"><span class="comment"> * 那么，默认优先级是多少呢?</span></span><br><span class="line"><span class="comment"> * 如何获取线程对象的优先级?</span></span><br><span class="line"><span class="comment"> * public final int getPriority():返回线程对象的优先级</span></span><br><span class="line"><span class="comment"> * 如何设置线程对象的优先级呢?</span></span><br><span class="line"><span class="comment"> * public final void setPriority(int newPriority)：更改线程的优先级。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 线程默认优先级是5。</span></span><br><span class="line"><span class="comment"> * 线程优先级的范围是：1-10。</span></span><br><span class="line"><span class="comment"> * 线程优先级高仅仅表示线程获取的 CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到比较好的效果。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * IllegalArgumentException:非法参数异常。</span></span><br><span class="line"><span class="comment"> * 抛出的异常表明向方法传递了一个不合法或不正确的参数。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriorityDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadPriority tp1 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line">ThreadPriority tp2 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line">ThreadPriority tp3 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line"></span><br><span class="line">tp1.setName(<span class="string">"东方不败"</span>);</span><br><span class="line">tp2.setName(<span class="string">"岳不群"</span>);</span><br><span class="line">tp3.setName(<span class="string">"林平之"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取默认优先级</span></span><br><span class="line"><span class="comment">// System.out.println(tp1.getPriority());</span></span><br><span class="line"><span class="comment">// System.out.println(tp2.getPriority());</span></span><br><span class="line"><span class="comment">// System.out.println(tp3.getPriority());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程优先级</span></span><br><span class="line"><span class="comment">// tp1.setPriority(100000);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置正确的线程优先级</span></span><br><span class="line">tp1.setPriority(<span class="number">10</span>);</span><br><span class="line">tp2.setPriority(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">tp1.start();</span><br><span class="line">tp2.start();</span><br><span class="line">tp3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="线程的控制-常见方法"><a href="#线程的控制-常见方法" class="headerlink" title="线程的控制(常见方法)"></a>线程的控制(常见方法)</h4><p>A:休眠线程  (public static void sleep(long millis))<br>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x + <span class="string">",日期："</span> + <span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">// 睡眠</span></span><br><span class="line"><span class="comment">// 困了，我稍微休息1秒钟</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程休眠</span></span><br><span class="line"><span class="comment"> *public static void sleep(long millis)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleepDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadSleep ts1 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">ThreadSleep ts2 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">ThreadSleep ts3 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line"></span><br><span class="line">ts1.setName(<span class="string">"林青霞"</span>);</span><br><span class="line">ts2.setName(<span class="string">"林志玲"</span>);</span><br><span class="line">ts3.setName(<span class="string">"林志颖"</span>);</span><br><span class="line"></span><br><span class="line">ts1.start();</span><br><span class="line">ts2.start();</span><br><span class="line">ts3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>B:加入线程  (public final void join())<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public final void join():等待该线程终止。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadJoin tj1 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">ThreadJoin tj2 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">ThreadJoin tj3 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line"></span><br><span class="line">tj1.setName(<span class="string">"李渊"</span>);</span><br><span class="line">tj2.setName(<span class="string">"李世民"</span>);</span><br><span class="line">tj3.setName(<span class="string">"李元霸"</span>);</span><br><span class="line"></span><br><span class="line">tj1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">tj1.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tj2.start();</span><br><span class="line">tj3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C:礼让线程  (public static void yield())<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYield</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">Thread.yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public static void yield():暂停当前正在执行的线程对象，并执行其他线程。 </span></span><br><span class="line"><span class="comment"> * 让多个线程的执行更和谐，但是不能靠它保证一人一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYieldDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadYield ty1 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line">ThreadYield ty2 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line"></span><br><span class="line">ty1.setName(<span class="string">"林青霞"</span>);</span><br><span class="line">ty2.setName(<span class="string">"刘意"</span>);</span><br><span class="line"></span><br><span class="line">ty1.start();</span><br><span class="line">ty2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>D:后台线程  (public final void setDaemon(boolean on))<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemon</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public final void setDaemon(boolean on):将该线程标记为守护线程或用户线程。</span></span><br><span class="line"><span class="comment"> * 当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 游戏：坦克大战。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemonDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadDaemon td1 = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line">ThreadDaemon td2 = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line"></span><br><span class="line">td1.setName(<span class="string">"关羽"</span>);</span><br><span class="line">td2.setName(<span class="string">"张飞"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置收获线程</span></span><br><span class="line">td1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">td2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">td1.start();</span><br><span class="line">td2.start();</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setName(<span class="string">"刘备"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>E:终止线程  (public final void stop()/public void interrupt())<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStop</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始执行："</span> + <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我要休息10秒钟，亲，不要打扰我哦</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// e.printStackTrace();</span></span><br><span class="line">System.out.println(<span class="string">"线程被终止了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"结束执行："</span> + <span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public final void stop():让线程停止，过时了，但是还可以使用。</span></span><br><span class="line"><span class="comment"> * public void interrupt():中断线程。 把线程的状态终止，并抛出一个InterruptedException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadStop ts = <span class="keyword">new</span> ThreadStop();</span><br><span class="line">ts.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你超过三秒不醒过来，我就干死你</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// ts.stop();</span></span><br><span class="line">ts.interrupt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程的生命周期-参照-线程生命周期图解-bmp"><a href="#线程的生命周期-参照-线程生命周期图解-bmp" class="headerlink" title="线程的生命周期(参照    线程生命周期图解.bmp)"></a>线程的生命周期(参照    线程生命周期图解.bmp)</h3><p>A:新建<br>B:就绪<br>C:运行<br>D:阻塞<br>E:死亡<br><strong>如图所示：</strong><br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-16/99895317.jpg" alt=""></p><h3 id="电影院卖票程序的实现"><a href="#电影院卖票程序的实现" class="headerlink" title="电影院卖票程序的实现"></a>电影院卖票程序的实现</h3><p>A:继承Thread类<br>B:实现Runnable接口</p><h3 id="电影院卖票程序出问题"><a href="#电影院卖票程序出问题" class="headerlink" title="电影院卖票程序出问题"></a>电影院卖票程序出问题</h3><ol><li>为了更符合真实的场景，加入了休眠100毫秒。</li><li>卖票问题</li></ol><ul><li>同票多次</li><li>负数票<h3 id="多线程安全问题的原因"><a href="#多线程安全问题的原因" class="headerlink" title="多线程安全问题的原因"></a>多线程安全问题的原因</h3></li><li>是否有多线程环境</li><li>是否有共享数据</li><li>是否有多条语句操作共享数据<h3 id="同步解决线程安全问题"><a href="#同步解决线程安全问题" class="headerlink" title="同步解决线程安全问题"></a>同步解决线程安全问题</h3></li></ul><ol><li><p>同步代码块</p><pre><code>synchronized(对象) {    需要被同步的代码;}</code></pre><p> 这里的锁对象可以是任意对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//创建锁对象</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//while (true) &#123;</span></span><br><span class="line"><span class="comment">//synchronized(new Object())&#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100); </span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName() + "正在出售第"</span></span><br><span class="line"><span class="comment">//+ (tickets--) + "张票");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_09;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何解决线程安全问题呢?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 要想解决问题，就要知道哪些原因会导致出问题:(而且这些原因也是以后我们判断一个程序是否会有线程安全问题的标准)</span></span><br><span class="line"><span class="comment"> * A:是否是多线程环境</span></span><br><span class="line"><span class="comment"> * B:是否有共享数据</span></span><br><span class="line"><span class="comment"> * C:是否有多条语句操作共享数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 我们来回想一下我们的程序有没有上面的问题呢?</span></span><br><span class="line"><span class="comment"> * A:是否是多线程环境是</span></span><br><span class="line"><span class="comment"> * B:是否有共享数据是</span></span><br><span class="line"><span class="comment"> * C:是否有多条语句操作共享数据是</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 由此可见我们的程序出现问题是正常的，因为它满足出问题的条件。</span></span><br><span class="line"><span class="comment"> * 接下来才是我们要想想如何解决问题呢?</span></span><br><span class="line"><span class="comment"> * A和B的问题我们改变不了，我们只能想办法去把C改变一下。</span></span><br><span class="line"><span class="comment"> * 思想：</span></span><br><span class="line"><span class="comment"> * 把多条语句操作共享数据的代码给包成一个整体，让某个线程在执行的时候，别人不能来执行。</span></span><br><span class="line"><span class="comment"> * 问题是我们不知道怎么包啊?其实我也不知道，但是Java给我们提供了：同步机制。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步代码块：</span></span><br><span class="line"><span class="comment"> * synchronized(对象)&#123;</span></span><br><span class="line"><span class="comment"> * 需要同步的代码;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * A:对象是什么呢?</span></span><br><span class="line"><span class="comment"> * 我们可以随便创建一个对象试试。</span></span><br><span class="line"><span class="comment"> * B:需要同步的代码是哪些呢?</span></span><br><span class="line"><span class="comment"> * 把多条语句操作共享数据的代码的部分给包起来</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。</span></span><br><span class="line"><span class="comment"> * 多个线程必须是同一把锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个线程对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>同步方法</p><pre><code>把同步加在方法上。</code></pre><p> 这里的锁对象是this</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义同一把锁</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// t1,t2,t3都能走到这里</span></span><br><span class="line"><span class="comment">// 假设t1抢到CPU的执行权，t1就要进来</span></span><br><span class="line"><span class="comment">// 假设t2抢到CPU的执行权，t2就要进来,发现门是关着的，进不去。所以就等着。</span></span><br><span class="line"><span class="comment">// 门(开,关)</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123; <span class="comment">// 发现这里的代码将来是会被锁上的，所以t1进来后，就锁了。(关)</span></span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>); <span class="comment">// t1就睡眠了</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line"><span class="comment">//窗口1正在出售第100张票</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//t1就出来可，然后就开门。(开)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_10;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 举例：</span></span><br><span class="line"><span class="comment"> * 火车上厕所。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步的特点：</span></span><br><span class="line"><span class="comment"> * 前提：</span></span><br><span class="line"><span class="comment"> * 多个线程</span></span><br><span class="line"><span class="comment"> *解决问题的时候要注意：</span></span><br><span class="line"><span class="comment"> *多个线程使用的是同一个锁对象</span></span><br><span class="line"><span class="comment"> * 同步的好处 </span></span><br><span class="line"><span class="comment"> *同步的出现解决了多线程的安全问题。</span></span><br><span class="line"><span class="comment"> * 同步的弊端</span></span><br><span class="line"><span class="comment"> *当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个线程对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>静态同步方法</p><pre><code>把同步加在方法上。</code></pre><p> 这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义同一把锁</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步代码块用obj做锁</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//while (true) &#123;</span></span><br><span class="line"><span class="comment">//synchronized (obj) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同步代码块用任意对象做锁</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//while (true) &#123;</span></span><br><span class="line"><span class="comment">//synchronized (d) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SellTicket.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//synchronized (d) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">sellTicket();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private void sellTicket() &#123;</span></span><br><span class="line"><span class="comment">//synchronized (d) &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果一个方法一进去就看到了代码被同步了，那么我就再想能不能把这个同步加在方法上呢?</span></span><br><span class="line"><span class="comment">// private synchronized void sellTicket() &#123;</span></span><br><span class="line"><span class="comment">//if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println(Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment">//+ "正在出售第" + (tickets--) + "张票 ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_11;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A:同步代码块的锁对象是谁呢?</span></span><br><span class="line"><span class="comment"> * 任意对象。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * B:同步方法的格式及锁对象问题?</span></span><br><span class="line"><span class="comment"> * 把同步关键字加在方法上。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步方法是谁呢?</span></span><br><span class="line"><span class="comment"> * this</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * C:静态方法及锁对象问题?</span></span><br><span class="line"><span class="comment"> * 静态方法的锁对象是谁呢?</span></span><br><span class="line"><span class="comment"> * 类的字节码文件对象。(反射会讲)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建资源对象</span></span><br><span class="line">SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个线程对象</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="回顾以前的线程安全的类"><a href="#回顾以前的线程安全的类" class="headerlink" title="回顾以前的线程安全的类"></a>回顾以前的线程安全的类</h3><blockquote><p> StringBuffer<br>Vector<br>Hashtable</p></blockquote><p>如何把一个线程不安全的集合类变成一个线程安全的集合类<br>有两种方法，首先寻找原本就线程安全的类：CopyOnWriteArrayList、ConcurrentHashMap等方法来实现。<br>用Collections工具类的方法即可。比如synchronizedSet(Set<t> s)的静态方法，具体见下图。<br><img src="http://magic-jh.oss-cn-beijing.aliyuncs.com/18-7-16/80203006.jpg" alt=""></t></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font style=&quot;color:blue&quot;&gt;爱女票，爱Java❤❤❤ &lt;/font&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;多线程-一&quot;&gt;&lt;a href=&quot;#多线程-一&quot; class=&quot;headerlink&quot; title=&quot;多线程(一)&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
